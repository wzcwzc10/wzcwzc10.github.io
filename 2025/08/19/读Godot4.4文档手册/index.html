<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>读Godot4.4文档手册 | 微光zc的网络小窝</title><meta name="author" content="微光zc"><meta name="copyright" content="微光zc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="读Godot4.4文档手册">
<meta property="og:type" content="article">
<meta property="og:title" content="读Godot4.4文档手册">
<meta property="og:url" content="https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/index.html">
<meta property="og:site_name" content="微光zc的网络小窝">
<meta property="og:description" content="读Godot4.4文档手册">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wzcwzc10.github.io/img/jufufu-ht.gif">
<meta property="article:published_time" content="2025-08-19T11:00:00.000Z">
<meta property="article:modified_time" content="2025-08-29T13:04:04.738Z">
<meta property="article:author" content="微光zc">
<meta property="article:tag" content="Godot">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="文档">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wzcwzc10.github.io/img/jufufu-ht.gif"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "读Godot4.4文档手册",
  "url": "https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/",
  "image": "https://wzcwzc10.github.io/img/jufufu-ht.gif",
  "datePublished": "2025-08-19T11:00:00.000Z",
  "dateModified": "2025-08-29T13:04:04.738Z",
  "author": [
    {
      "@type": "Person",
      "name": "微光zc",
      "url": "https://wzcwzc10.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/./img/loading.gif"><link rel="canonical" href="https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '读Godot4.4文档手册',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/ziti.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="/components/bilibili-card/bilibili-card.dark.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/./img/page-bg.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/jufufu-ht.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 微光闲话</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/./img/page-ym.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/./img/yx.png" alt="Logo"><span class="site-name">微光zc的网络小窝</span></a><a class="nav-page-title" href="/"><span class="site-name">读Godot4.4文档手册</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 微光闲话</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">读Godot4.4文档手册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-19T11:00:00.000Z" title="发表于 2025-08-19 19:00:00">2025-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-29T13:04:04.738Z" title="更新于 2025-08-29 21:04:04">2025-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Godot/">Godot</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">54.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>174分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>本文参考<a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh-cn/4.x/index.html">Godot4.4中文文档</a>中<br>手册的内容进行了总结改进，去除了个人感觉无用的部分</p>
<h1 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h1><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="在-Godot-中应用面向对象原则"><a href="#在-Godot-中应用面向对象原则" class="headerlink" title="在 Godot 中应用面向对象原则"></a>在 Godot 中应用面向对象原则</h3><p>Godot 引擎主要提供了两种创建可复用对象的方式：脚本和场景。<br>虽没有真正在底层定义类但面向对象的编程原则仍可应用。</p>
<h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>引擎提供了内置的类，如<strong>Node</strong>。<br>使用脚本扩展类来创建派生类型。<br>脚本严格来说并不是类，而是一种资源，用来告知引擎在内置类的基础上执行的初始化操作。</p>
<p>Godot 的内部类可以将一个类的数据注册进一个名为<strong>ClassDB</strong>的数据库<br>可以在运行时访问类的信息（例：属性 方法 常量 信号）。</p>
<p>当对象在执行访问属性或调用方法等操作时，就会检查<strong>ClassDB</strong>中对象和对象基类的记录，确定对象是否支持该操作。<br>将<strong>Script</strong>附加到对象上，可以扩展<strong>ClassDB</strong>中该对象的方法、属性和信号。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
脚本即使没有使用 extends 关键字，也会隐式继承引擎的基础 RefCounted 类。
因此，你可以从代码中实例化不使用 extends 关键字的脚本。
不过由于扩展的是 RefCounted，无法把它们附加到 Node 上。
</p>

<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>场景是可复用、可实例化、可继承的节点组。<br>创建场景就类似于，有一个脚本去创建一些节点，并使用 add_child() 将它们添加为子节点。</p>
<p>我们经常为场景搭配一个带有脚本的根节点，并在脚本中使用这个场景下的节点。脚本是通过使用命令式代码为场景添加行为来扩展场景的。</p>
<p>场景的内容有助于定义：<br>脚本可使用哪些节点。<br>如何组织，初始化。<br>彼此之间有什么信号连接。</p>
<p>为什么这些对组织场景很重要？<br>因为场景的实例都是对象。<br>因此，许多适用于面向对象原则也适用于场景：单一职责、封装等。</p>
<p>场景就是对附着在根节点上的脚本的扩展，所以你可以将其解释为类的一部分。<br>此系列最佳实践中所解释的大部分技术都建立在这一点上。</p>
<h3 id="场景组织"><a href="#场景组织" class="headerlink" title="场景组织"></a>场景组织</h3><h4 id="如何有效地建立关系？"><a href="#如何有效地建立关系？" class="headerlink" title="如何有效地建立关系？"></a>如何有效地建立关系？</h4><ul>
<li>应尽可能设计没有依赖的场景。（创建的场景应该将其所需的一切保留在其内部）</li>
<li>如果场景必须与外部环境交互，建议使用依赖注入。</li>
<li>依赖注入涉及使高级 API 提供低级 API 的依赖关系。</li>
<li>为什么？依赖于其外部环境的类可能会无意中触发 Bug 和意外行为。</li>
</ul>
<p>✅ 核心目标：松耦合 + 高内聚<br>“一个类不应依赖外部环境来完成其核心功能。”</p>
<p>要做到这一点，就必须暴露数据，然后依靠父级上下文对其进行初始化<br>下面是五种方法：</p>
<ol>
<li>连接信号。<br>这样做极其安全，但只能用于“响应”行为，而不是启动行为。<br>按惯例，信号名称通常是过去式动词，如“entered”“skill_activated”“item_collected”（已进入、已激活技能、已收集道具）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.signal_name.connect(method_on_the_object)</span><br><span class="line"></span><br><span class="line"># Child 子 → 父（通知）</span><br><span class="line">signal_name.emit() # 触发父级定义的行为</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>调用方法。<br>用于启动行为。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.method_name = &quot;do&quot;</span><br><span class="line"></span><br><span class="line"># Child 父 → 子（指令）</span><br><span class="line">call(method_name) # Call parent-defined method (which child must own).</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>初始化 Callable 属性。<br>比调用方法更安全，因为不需要拥有这个方法的所有权。用于启动行为。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.func_property = object_with_method.method_on_the_object</span><br><span class="line"></span><br><span class="line"># Child 父 → 子（注入行为）</span><br><span class="line">func_property.call() # Call parent-defined method (can come from anywhere).</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>初始化 Node 或其他 Object 的引用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.target = self</span><br><span class="line"></span><br><span class="line"># Child 父 → 子（提供数据源）</span><br><span class="line">print(target) # Use parent-defined node.</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>初始化 NodePath。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.target_path = &quot;..&quot;</span><br><span class="line"></span><br><span class="line"># Child 子 → 外部（通过路径查找）</span><br><span class="line">get_node(target_path) # Use parent-defined NodePath.</span><br></pre></td></tr></table></figure>
<p>这些选项隐藏了子节点的访问点。这反过来又使子节点与环境保持<strong>松耦合</strong> （loosely coupled）。<br>人们可以在另外一个上下文中重新使用它，而不需要对API做任何额外的改变。</p>
<mark class="hl-label red">警告</mark>
<p>应倾向于将数据保存在场景内部，尽管它对外部内容有一个依赖关系，甚至是一个松散耦合的依赖，仍然意味着节点将期望其环境中的某些内容为真。<br>项目的设计理念应避免这种情况的发生。如果不这样做，代码的继承关系将迫使开发人员使用文档, 以在微观尺度上跟踪对象关系；这就是所谓的开发地狱。通常情况下，编写依赖于外部文档才能安全使用的代码，是很容易出错的。<br>为了避免创建和维护此类文档，可以将依赖节点（上面的子级）转换为工具脚本，该脚本实现 _get_configuration_warnings()。<br>从中返回的一个非空字符串紧缩数组（PackedStringArray）将使场景停靠面板生成警告图标，其中包含上述字符串作为节点的工具提示。<br>这个警告图标和没有定义 CollisionShape2D 子节点时 Area2D 节点旁出现的图标是一样的。这样，编辑器通过脚本代码自记录（self-document）场景，也就不需要在文档里记录一些与之重复的内容了。<br>这样的GUI可以更好地通知项目用户有关节点的关键信息. 它具有外部依赖性吗？这些依赖性是否得到满足？其他程序员, 尤其是设计师和作家, 将需要消息中的明确指示, 告诉他们如何进行配置.</p>
<h4 id="选择节点树结构"><a href="#选择节点树结构" class="headerlink" title="选择节点树结构"></a>选择节点树结构</h4><p>构造节点树的方法有无数种。但对于没把握的人而言，这份有用的指南可以给他们一个不错的结构样本作为开始。<br>main.gd, 脚本将作为你的游戏的主要控制器。<br>Node2D&#x2F;Node3D, 真正的游戏“世界”（2D或3D）。<br>GUI, 来管理项目所需的各种菜单和部件。<br>“Main”节点（main.gd）</p>
<ul>
<li>Node2D&#x2F;Node3D “World”（game_world.gd）</li>
<li>Control“GUI”（gui.gd）</li>
</ul>
<p>当变更关卡时，可以稍后换出“World”节点的子级。手动更换场景让用户完全控制他们的游戏世界如何过渡。<br>下一步是考虑项目需要什么样的游戏系统。如果有这么一个系统……<br>跟踪所有的内部数据<br>应该是全局可访问的<br>应该是独立存在的<br>…接下来他该创建一个自动加载“单例”节点了。</p>
<blockquote>
<p>对于较小的游戏，一个更简单且更少控制的做法是使用一个“Game”单例<br>简单地调用 SceneTree.change_scene_to_file() 方法，用于置换出主场景的内容。这种结构多少保留了“World”作为主要游戏节点。<br>任一 GUI 也需要是一个单例；作为 “World” 的临时部分，或被手动添加到根节点作为其直接子节点。否则 GUI 节点也会在场景转换时自行删除。</p>
</blockquote>
<p>如果一个系统需要修改另一个系统的数据，那么就应该把它们分别定义成单独的脚本或者场景，不应该使用自动加载。</p>
<p>游戏中的每个子系统都应该在 SceneTree 中占有自己的一席之地。只有在节点确实是父节点中的元素时才应当使用父子关系。如果移除父节点的话，同时将这些子节点移除是否说得通？说不通的话，就应该在层级结构中单独列出，两者成为兄弟节点或者其他关系。</p>
<blockquote>
<p>某些情况下，我们仍然会需要让这些单独的节点进行相对定位。<br>此时可以使用 RemoteTransform &#x2F; RemoteTransform2D 节点。让目标节点有条件地从 Remote* 节点继承选定的变换元素。<br>要分配 target 的 NodePath，请使用以下方法之一：</p>
<ol>
<li>一个可靠的第三方, 可能是一个父节点, 来协调分配任务.</li>
<li>一个分组, 轻松提取对所需节点的引用(假设只有一个目标).<br>什么时候你该这样做？当你必须精细管理，且一个节点必须在场景树上来回移动以保留自己时，就会出现两难的局面。例如……<br>添加一个“玩家”节点到一个“房间”节点。<br>需要改变房间了，所以必须删除当前房间节点。<br>在房间能被删除前，你必须保留玩家并&#x2F;或将其移走。</li>
</ol>
<ul>
<li>如果不关心内存，你可以……<ul>
<li>创建新的房间节点。</li>
<li>将玩家节点移动到新的房间节点。</li>
<li>删除旧房间。</li>
</ul>
</li>
<li>如果比较关注内存情况，那么就需要这样……<ul>
<li>将玩家节点移动到节点树的其他地方。</li>
<li>删除房间节点。</li>
<li>实例化并添加新的房间节点。</li>
<li>重新添加玩家节点到新房间中。<br>问题在于这里的角色是一种“特殊情况”；开发者必须知道需要以这种方式处理项目中的角色。因此，在团队中可靠地分享这些信息的唯一方法就是写文档。然而，在文档中记录实现细节是很危险的，会成为一种维护负担，使代码可读性下降，不必要地膨胀项目的知识内容。<br>在拥有更多的资产的，更复杂的游戏中，将整个玩家节点保留在 SceneTree 中的其他地方会更好。这样的好处是：<br>一致性更高。<br>没有“特殊情况”，不必写入文档也不必进行维护。<br>因为不需要考虑这些细节，所以也没有出错的机会。<br>相比之下，如果需要子节点不继承父节点的变换，那么就有以下选项：<br>声明式解决方案：在它们之间放置一个 Node。作为没有变换的节点，Node 不会将这些信息传递给其子节点。<br>命令式解决方案：对 CanvasItem 或者 Node3D 节点使用 top_level 属性。这样就会让该节点忽略其继承的变换（transform）。</li>
</ul>
</li>
</ul>
</blockquote>
<p>如果构建的是网络游戏，请记住哪些节点和游戏系统与所有玩家相关，而哪些只与权威服务器相关。<br>例如，用户并不需要所有人都拥有每个玩家的“PlayerController”逻辑的副本。相反，他们只需要自己的。<br>将它们保持在从“世界”分离的独立的分支中，可以帮助简化游戏连接等的管理。</p>
<p>场景组织的关键是用关系树而不是空间树来考虑 SceneTree。节点是否依赖于其父节点的存在？如果不是，那么它们可以自己在别的地方茁壮成长。如果它们是依赖性的，那么理所当然它们应该是父节点的子节点（如果它们还不是父节点场景的一部分，那么很可能是父节点场景的一部分）。</p>
<p>这是否意味着节点本身就是组件？并不是这样。Godot 的节点树形成的是聚合关系，不是组合关系。虽然依旧可以灵活地移动节点，但在默认情况下是没有进行移动的必要的。</p>
<h3 id="何时使用场景与脚本"><a href="#何时使用场景与脚本" class="headerlink" title="何时使用场景与脚本"></a>何时使用场景与脚本</h3><h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h4><p>单独使用脚本 可以 完全定义场景的内容. 从本质上讲,Godot编辑器所做的, 仅在其对象的C++构造函数中.<br>但是, 选择哪个来使用, 可能是一个两难问题. 创建脚本实例与创建引擎类相同, 而处理场景需要更改API:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const MyNode = preload(&quot;my_node.gd&quot;)</span><br><span class="line">const MyScene = preload(&quot;my_scene.tscn&quot;)</span><br><span class="line">var node = Node.new()</span><br><span class="line">var my_node = MyNode.new() # Same method call.</span><br><span class="line">var my_scene = MyScene.instantiate() # Different method call.</span><br><span class="line">var my_inherited_scene = MyScene.instantiate(PackedScene.GEN_EDIT_STATE_MAIN) # Create scene inheriting from MyScene.</span><br></pre></td></tr></table></figure>
<p>此外, 由于引擎和脚本代码之间的速度差异, 脚本的运行速度将比场景慢一些. 节点越大和越复杂, 将它构建为场景的理由就越多.</p>
<h4 id="命名的类型"><a href="#命名的类型" class="headerlink" title="命名的类型"></a>命名的类型</h4><p>脚本可以在编辑器中被注册为一个新类型。<br>这样做之后，在节点或资源创建对话框中，它就会被显示为一个新类型，并带有可选图标。<br>这样，用户就可以更加便捷地使用脚本，而不是必须…</p>
<ul>
<li>了解他们想要使用的脚本的基本类型.</li>
<li>创建一个该基本类型的实例.</li>
<li>将脚本添加到节点.</li>
</ul>
<p>通过注册一个脚本，该脚本类型将像系统中的其他节点和资源一样成为一个可以被创建的选项。创建对话框甚至还有一个搜索栏，可以按名称查找类型。<br>用于注册类型的系统有两种：</p>
<ol>
<li><p>自定义类型<br>仅限编辑器. 类型名称在运行时中不可访问.<br>不支持继承的自定义类型.<br>一个初始化工具. 使用脚本创建节点. 仅此而已.<br>编辑器没有对该脚本的类型感知, 或其与其他引擎类型或脚本的关系.<br>允许用户定义一个图标.<br>适用于所有脚本语言, 因为它抽象处理脚本资源.<br>设置使用 EditorPlugin.add_custom_type.<br>使用 EditorPlugin.add_custom_type 设置。</p>
</li>
<li><p>Script 类<br>编辑器和运行时均可访问.<br>显示全部继承关系.<br>使用脚本创建节点, 但也可以从编辑器更改或扩展类型.<br>编辑器知道脚本, 脚本类和引擎c++类之间的继承关系.<br>允许用户定义一个图标.<br>引擎开发人员必须手动添加对语言的支持(名称公开和运行时可访问性两者).<br>编辑器扫描项目文件夹, 并为所有脚本语言注册任何公开的名称. 为公开此信息, 每种脚本语言都必须实现自己的支持.</p>
</li>
</ol>
<p>这两种方法都向创建对话框添加名称, 特别是脚本类, 还允许用户在不加载脚本资源的情况下访问类别名称. 在任何地方都可以创建实例, 和访问常量或静态方法.</p>
<p>有了这些功能, 由于它赋予用户易用性, 人们可能希望它们的类型是没有场景的脚本. 那些正在开发的插件或创建供设计人员使用的内部工具, 将以这种方式使事情变得更轻松.</p>
<p>不足之处在于, 这也意味着很大程度上必须使用命令式编程.</p>
<h4 id="Script-与-PackedScene-的性能"><a href="#Script-与-PackedScene-的性能" class="headerlink" title="Script 与 PackedScene 的性能"></a>Script 与 PackedScene 的性能</h4><p>在选择场景和脚本时, 最后一个需要考虑的方面是执行速度.<br>随着对象内容的增加, 脚本创建和初始化所需的内容也会大大增加. 创建节点层次结构就说明了这一点. 每个Node的逻辑可能有几百行代码.<br>下面的代码示例创建一个新的 Node, 更改名称, 分配脚本, 将其未来的父级设置为其所有者, 以便保存到磁盘中, 最后将其添加为 “主” 节点的子级:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># main.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">func _init():</span><br><span class="line">	var child = Node.new()</span><br><span class="line">	child.name = &quot;Child&quot;</span><br><span class="line">	child.script = preload(&quot;child.gd&quot;)</span><br><span class="line">	add_child(child)</span><br><span class="line">	child.owner = self</span><br></pre></td></tr></table></figure>
<p>这样的脚本代码比引擎端的C++代码要慢很多. 每条指令都要调用脚本API, 导致后端要进行多次 “查找”, 以找到要执行的逻辑.</p>
<p>场景有助于避免这个性能问题。PackedScene （场景包）是场景继承的基础类型，定义了使用序列化数据创建对象的资源。引擎可以在后端批量处理场景，并提供比脚本好得多的性能。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最好的方法是考虑以下几点:<br>如果希望创建一个基本工具, 它将在几个不同的项目中重用, 以及可能提供给不同技能水平的人使用. 它很可能是一个脚本, 有一个自定义名称&#x2F;图标.<br>如果有人想创造一个特定于他们的游戏的概念, 那么它应该是一个场景. 场景比脚本更容易跟踪&#x2F;编辑, 并提供更多的安全性.<br>如果你想命名一个场景，那么你可以通过声明一个脚本类并给它一个场景作为常量来实现这一点。实际上，该脚本变成了一个命名空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># game.gd</span><br><span class="line">class_name Game # 它继承自 RefCounted，因此不会出现在节点创建对话框中。</span><br><span class="line">extends RefCounted</span><br><span class="line"></span><br><span class="line">const MyScene = preload(&quot;my_scene.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># main.gd</span><br><span class="line">extends Node</span><br><span class="line">func _ready():</span><br><span class="line">	add_child(Game.MyScene.instantiate())</span><br></pre></td></tr></table></figure>

<h3 id="自动加载与常规节点"><a href="#自动加载与常规节点" class="headerlink" title="自动加载与常规节点"></a>自动加载与常规节点</h3><p>Godot 提供了一个在项目根节点自动加载节点的功能，允许你在全局范围内访问它们，从而完成单例作用 单例（自动加载） 。<br>当你在代码中使用 SceneTree.change_scene_to_file 更改场景时，这些自动加载的节点不会被释放。<br>在本指南中, 你将学习到何时使用自动加载功能, 以及避免使用该功能的方法.</p>
<h4 id="切割音频问题"><a href="#切割音频问题" class="headerlink" title="切割音频问题"></a>切割音频问题</h4><p>其他引擎可能鼓励使用创建管理类, 单例将很多功能组织到一个全局可访问的对象中.<br>由于节点树和信号,Godot提供了许多避免全局状态的方法.</p>
<p>例如, 假设我们正在构建一个平台游戏, 并希望收集能够播放声音效果的硬币, 那么就有一个节点 AudioStreamPlayer. 如果在 AudioStreamPlayer 已经在播放声音时调用它, 新的声音就会打断第一个声音.</p>
<p>一种解决方案是写一个全局的、自动加载的音效管理器类。它会生成一个 AudioStreamPlayer 的节点池，每当一个新的音效请求出现时，它就会在这个节点池中找到可用的节点来播放。我们不妨就把该类命名为 Sound ，你可以通过 Sound.play(“coin_pickup.ogg”) 从你项目中的任何位置使用它。这在短期内解决了问题但是却造成了更多的麻烦：</p>
<ol>
<li>全局状态 : 一个对象现在负责所有对象的数据. 如果音效有错误, 或没有一个可用的 AudioStreamPlayer , 一切都会崩溃.</li>
<li>全局访问 : 意味着任何对象都可以从任何地方调用 Sound.play(sound_path) , 便不容易找到错误的来源了.</li>
<li>全局资源分配 : 由于从一开始就存储了一个 AudioStreamPlayer 节点池, 如果数量太少会遇到bug, 而数量太多则会占用更多的内存.</li>
</ol>
<blockquote>
<p>全局访问的问题在于，任何地方的代码都可能将错误的数据传递给我们例子中的 Sound 自动加载。因此，为了修复这个 bug，你需要检索的区域涵盖了整个项目。<br>当你将代码保存在场景中时, 音频可能仅涉及一个或两个脚本.</p>
</blockquote>
<p>与之形成对比的是, 每个场景在其内部, 保留尽可能多的 AudioStreamPlayer 节点, 所有这些问题都会消失:</p>
<ol>
<li>每个场景管理自己的状态信息. 如果数据有问题, 则只会在该场景中引起问题.</li>
<li>每个场景只访问自己的节点. 那么如果有一个bug, 很容易找到哪个节点有问题.</li>
<li>每个场景只分配所需数量的资源.</li>
</ol>
<h4 id="管理共享功能或数据"><a href="#管理共享功能或数据" class="headerlink" title="管理共享功能或数据"></a>管理共享功能或数据</h4><p>使用自动加载的另一个原因可能是你希望在许多场景中重复使用相同的方法或数据.<br>对于函数，可以使用 GDScript 中的 class_name 关键字创建一种新的 Node 类型，为单个场景提供该功能。<br>当涉及到数据时, 你可以:</p>
<ol>
<li>创建一个新类型的 Resource 来共享数据.</li>
<li>将数据存储在每个节点可以访问的对象中, 例如使用 owner 属性来访问场景的根节点.</li>
</ol>
<h4 id="何时应使用自动加载"><a href="#何时应使用自动加载" class="headerlink" title="何时应使用自动加载"></a>何时应使用自动加载</h4><p>GDScript 支持使用 static func 创建 static （静态） 函数，与 class_name 结合使用时还可以创建辅助函数库，无需创建实例来调用这些函数。 静态函数也有一些限制：不能引用成员变量、非静态（non-static）函数或 self。<br>从 Godot 4.1 开始，GDScript 还支持使用 static var 的 static （静态）变量，意味着你现在可以在类的实例之间共享变量，而无需创建单独的自动加载节点或脚本。<br>尽管如此，对于那些涵盖范围广泛的系统来说，使用自动加载的节点仍然可以简化你的代码。如果自动加载的节点管理自己的信息并且不侵入其他对象的数据，那么这就是一个创建处理广泛任务的系统（例如，任务或对话系统）的好方法。</p>
<blockquote>
<p>自动加载 不 完全是一个单例。没有什么可以阻止你实例化自动加载的节点的副本。它只是一个使节点作为场景树的根的子节点自动加载的工具，而与游戏的节点结构或运行哪个场景（比如通过按 F6 键运行当前场景）无关。<br>因此，你可以像这样，通过调用 get_node(“&#x2F;root&#x2F;Sound”) 来获取名为 Sound 的自动加载节点。</p>
</blockquote>
<h3 id="何时以及如何避免为任何事情使用节点"><a href="#何时以及如何避免为任何事情使用节点" class="headerlink" title="何时以及如何避免为任何事情使用节点"></a>何时以及如何避免为任何事情使用节点</h3><ol>
<li>Object：终极轻量级对象，原始的 Object 必须使用手动内存管理。尽管如此，创建自己的自定义数据结构——甚至是节点结构——也并不难，并且比 Node 类更轻量。</li>
</ol>
<p>示例：参见 Tree 节点。它支持对具有任意行数和列数的内容表，进行高级定制。用来生成可视化的数据实际上是 TreeItem 对象的树。</p>
<p>优势： 将 API 简化为较小范围的对象，有助于提高其可访问性、改善迭代时间。与其使用整个 Node 库，不如创建一组简略的 Object，节点可以从这些 Object 中生成和管理相应的子节点。</p>
<blockquote>
<p>处理它们时要小心. 可以将 Object 存储到变量中, 但是这些引用可能在没有警告的情况下失效. 例如, 如果对象的创建者决定删除它, 这将在下一次访问时, 触发错误状态.</p>
</blockquote>
<ol start="2">
<li>RefCounted：只比 Object 稍微复杂一点。它们会记录对自己的引用，只有当对自己没有另外的引用存在时，才会删除加载的内存。在大多数需要在自定义类中存取数据的情况下，很有用。</li>
</ol>
<p>示例：见 FileAccess 对象。它的功能就像普通 Object 一样，只是不需要人为删除。</p>
<p>优势: 与 Object 相同.</p>
<ol start="3">
<li>Resource ：只比 RefCounted 稍微复杂一点。它们天然具有将其对象属性序列化（即保存）到 Godot 资源文件，或从 Godot 资源文件中反序列化（即加载）的能力。</li>
</ol>
<p>示例 : 脚本, PackedScene (用于场景文件), 以及其他类型, 比如 AudioEffect 类. 每一个都可以保存和加载, 因此它们均是从 Resource 继承而来的.</p>
<p>优势：关于 Resource 与传统数据存储方法相比的优势已经说了 很多。然而，在使用 Resource 替代 Node 的情境下，Resource 的主要优点是与检查器的兼容性。虽然几乎和 Object&#x2F;Reference 一样轻量，它们仍然可以在检查器中显示并导出属性。这使它们在易用性上，可以媲美使用子节点的方式，而且如果有人计划在其场景中包含许多这类 Resource&#x2F;Node，它们还可以提高性能。</p>
<h3 id="Godot-接口"><a href="#Godot-接口" class="headerlink" title="Godot 接口"></a>Godot 接口</h3><p>脚本常常需要依赖其他对象来获取功能。这个过程分为两部分：</p>
<ol>
<li>获取对可能具有这些功能的对象的引用。</li>
<li>从对象访问数据或逻辑。</li>
</ol>
<h4 id="获取对象引用"><a href="#获取对象引用" class="headerlink" title="获取对象引用"></a>获取对象引用</h4><p>对所有 Object 来说，获得引用的最基础的方法，是通过另一个已获得引用的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = node.object # Property access.</span><br><span class="line">var obj = node.get_object() # Method access.</span><br></pre></td></tr></table></figure>
<p>同样的原则也适用于 RefCounted 对象。虽然用户经常以这种方式访问 Node 和 Resource，但还有其他方法可用。<br>除了访问属性和方法，也可以通过加载来获得 Resource。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># If you need an &quot;export const var&quot; (which doesn&#x27;t exist), use a conditional</span><br><span class="line"># setter for a tool script that checks if it&#x27;s executing in the editor.</span><br><span class="line"># The `@tool` annotation must be placed at the top of the script.</span><br><span class="line">@tool</span><br><span class="line"></span><br><span class="line"># Load resource during scene load.</span><br><span class="line">var preres = preload(path)</span><br><span class="line"># Load resource when program reaches statement.</span><br><span class="line">var res = load(path)</span><br><span class="line"></span><br><span class="line"># Note that users load scenes and scripts, by convention, with PascalCase</span><br><span class="line"># names (like typenames), often into constants.</span><br><span class="line">const MyScene = preload(&quot;my_scene.tscn&quot;) # Static load</span><br><span class="line">const MyScript = preload(&quot;my_script.gd&quot;)</span><br><span class="line"></span><br><span class="line"># This type&#x27;s value varies, i.e. it is a variable, so it uses snake_case.</span><br><span class="line">@export var script_type: Script</span><br><span class="line"></span><br><span class="line"># Must configure from the editor, defaults to null.</span><br><span class="line">@export var const_script: Script:</span><br><span class="line">	set(value):</span><br><span class="line">		if Engine.is_editor_hint():</span><br><span class="line">			const_script = value</span><br><span class="line"></span><br><span class="line"># Warn users if the value hasn&#x27;t been set.</span><br><span class="line">func _get_configuration_warnings():</span><br><span class="line">	if not const_script:</span><br><span class="line">		return [&quot;Must initialize property &#x27;const_script&#x27;.&quot;]</span><br><span class="line"></span><br><span class="line">	return []</span><br></pre></td></tr></table></figure>
<p>请注意以下几点：</p>
<ol>
<li>在一种语言中，有许多加载这些资源的方法。</li>
<li>在设计对象如何访问数据时，不要忘记，还可以将资源作为引用传递。</li>
<li>请记住，加载资源时只会获取引擎维护的缓存资源实例。如果要获取一个新对象，必须 复制 一个现有引用，或者使用 new() 从头实例化一个对象。</li>
</ol>
<p>节点同样也有另一种访问方式：场景树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">extends Node</span><br><span class="line"></span><br><span class="line"># Slow.</span><br><span class="line">func dynamic_lookup_with_dynamic_nodepath():</span><br><span class="line">	print(get_node(&quot;Child&quot;))</span><br><span class="line"></span><br><span class="line"># Faster. GDScript only.</span><br><span class="line">func dynamic_lookup_with_cached_nodepath():</span><br><span class="line">	print($Child)</span><br><span class="line"></span><br><span class="line"># Fastest. Doesn&#x27;t break if node moves later.</span><br><span class="line"># Note that `@onready` annotation is GDScript-only.</span><br><span class="line"># Other languages must do...</span><br><span class="line">#     var child</span><br><span class="line">#     func _ready():</span><br><span class="line">#         child = get_node(&quot;Child&quot;)</span><br><span class="line">@onready var child = $Child</span><br><span class="line">func lookup_and_cache_for_future_access():</span><br><span class="line">	print(child)</span><br><span class="line"></span><br><span class="line"># Fastest. Doesn&#x27;t break if node is moved in the Scene tree dock.</span><br><span class="line"># Node must be selected in the inspector as it&#x27;s an exported property.</span><br><span class="line">@export var child: Node</span><br><span class="line">func lookup_and_cache_for_future_access():</span><br><span class="line">	print(child)</span><br><span class="line"></span><br><span class="line"># Delegate reference assignment to an external source.</span><br><span class="line"># Con: need to perform a validation check.</span><br><span class="line"># Pro: node makes no requirements of its external structure.</span><br><span class="line">#      &#x27;prop&#x27; can come from anywhere.</span><br><span class="line">var prop</span><br><span class="line">func call_me_after_prop_is_initialized_by_parent():</span><br><span class="line">	# Validate prop in one of three ways.</span><br><span class="line"></span><br><span class="line">	# Fail with no notification.</span><br><span class="line">	if not prop:</span><br><span class="line">		return</span><br><span class="line"></span><br><span class="line">	# Fail with an error message.</span><br><span class="line">	if not prop:</span><br><span class="line">		printerr(&quot;&#x27;prop&#x27; wasn&#x27;t initialized&quot;)</span><br><span class="line">		return</span><br><span class="line"></span><br><span class="line">	# Fail and terminate.</span><br><span class="line">	# NOTE: Scripts run from a release export template don&#x27;t run `assert`s.</span><br><span class="line">	assert(prop, &quot;&#x27;prop&#x27; wasn&#x27;t initialized&quot;)</span><br><span class="line"></span><br><span class="line"># Use an autoload.</span><br><span class="line"># Dangerous for typical nodes, but useful for true singleton nodes</span><br><span class="line"># that manage their own data and don&#x27;t interfere with other objects.</span><br><span class="line">func reference_a_global_autoloaded_variable():</span><br><span class="line">	print(globals)</span><br><span class="line">	print(globals.prop)</span><br><span class="line">	print(globals.my_getter())</span><br></pre></td></tr></table></figure>

<h4 id="从对象访问数据或逻辑"><a href="#从对象访问数据或逻辑" class="headerlink" title="从对象访问数据或逻辑"></a>从对象访问数据或逻辑</h4><p>Godot 的脚本 API 是鸭子类型（duck-typed）的。<br>这意味着，当脚本执行某项操作时，Godot 不会通过<strong>类型</strong>来验证其是否支持该操作。相反，它会检查对象是否<strong>实现</strong>了这个被调用的方法。</p>
<p>例如，CanvasItem 类具有 visible&#96; 属性。暴露给脚本 API 的所有属性实际上都是与名称绑定的 setter 和 getter 对。如果有人尝试访问 CanvasItem.visible，那么 Godot 将按顺序执行以下检查：</p>
<ul>
<li>如果对象附加了脚本，它将尝试通过脚本设置属性。这使得脚本有机会通过覆盖属性的 setter 方法来覆盖在基础对象上定义的属性。</li>
<li>如果脚本没有该属性，它会在 ClassDB 中针对 CanvasItem 类及其所有继承类型执行 HashMap 查找以查找“visible”属性。如果找到，它会调用绑定的 setter 或 getter。有关 HashMap 的更多信息，请参阅《数据偏好》文档。</li>
<li>如果没有找到, 它会进行显式检查, 以查看用户是否要访问 script 或 meta 属性.</li>
<li>如果没有, 它将在 CanvasItem 及其继承的类型中检查 _set&#x2F;_get 实现(取决于访问类型). 这些方法可以执行逻辑, 从而给人一种对象具有属性的印象. _get_property_list 方法也是如此.<ul>
<li>请注意，即使对于不合法的符号名称也会发生这种情况，例如以数字开头或包含斜杠（&#x2F;）的名称。</li>
</ul>
</li>
</ul>
<p>因此，这个鸭子类型的系统可以在脚本、对象的类，或对象继承的任何类中定位属性，但仅限于扩展 Object 的对象。</p>
<p>Godot 提供了多种选项，来对这些访问执行运行时检查：</p>
<ul>
<li>鸭子类型属性的访问。Godot 将像上文所述的那样对它进行属性检查。如果对象不支持该操作，则执行将停止。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 所有对象都有类似鸭子类型（duck-typed）的 get、set 和 call 包装方法</span><br><span class="line">get_parent().set(&quot;visible&quot;, false)</span><br><span class="line"></span><br><span class="line"># 在方法调用中使用符号（symbol）访问器而非字符串，</span><br><span class="line"># 会隐式地调用 set 方法，而 set 方法又会通过属性查找顺序，</span><br><span class="line"># 调用绑定到该属性的 setter 方法。</span><br><span class="line">get_parent().visible = false</span><br><span class="line"></span><br><span class="line"># 请注意，如果定义了 _set 和 _get 方法来描述某个属性的存在，</span><br><span class="line"># 但该属性未在任何 _get_property_list 方法中被识别，</span><br><span class="line"># 那么 set() 和 get() 方法仍然可以正常工作，</span><br><span class="line"># 但符号访问方式会提示找不到该属性。</span><br></pre></td></tr></table></figure>
<p>方法检查。在 CanvasItem.visible 的例子中，我们可以像访问任何其他方法一样，访问 set_visible 和 is_visible。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">var child = get_child(0)</span><br><span class="line"></span><br><span class="line"># Dynamic lookup.</span><br><span class="line">child.call(&quot;set_visible&quot;, false)</span><br><span class="line"></span><br><span class="line"># Symbol-based dynamic lookup.</span><br><span class="line"># GDScript aliases this into a &#x27;call&#x27; method behind the scenes.</span><br><span class="line">child.set_visible(false)</span><br><span class="line"></span><br><span class="line"># Dynamic lookup, checks for method existence first.</span><br><span class="line">if child.has_method(&quot;set_visible&quot;):</span><br><span class="line">	child.set_visible(false)</span><br><span class="line"></span><br><span class="line"># Cast check, followed by dynamic lookup.</span><br><span class="line"># Useful when you make multiple &quot;safe&quot; calls knowing that the class</span><br><span class="line"># implements them all. No need for repeated checks.</span><br><span class="line"># Tricky if one executes a cast check for a user-defined type as it</span><br><span class="line"># forces more dependencies.</span><br><span class="line">if child is CanvasItem:</span><br><span class="line">	child.set_visible(false)</span><br><span class="line">	child.show_on_top = true</span><br><span class="line"></span><br><span class="line"># If one does not wish to fail these checks without notifying users,</span><br><span class="line"># one can use an assert instead. These will trigger runtime errors</span><br><span class="line"># immediately if not true.</span><br><span class="line">assert(child.has_method(&quot;set_visible&quot;))</span><br><span class="line">assert(child.is_in_group(&quot;offer&quot;))</span><br><span class="line">assert(child is CanvasItem)</span><br><span class="line"></span><br><span class="line"># Can also use object labels to imply an interface, i.e. assume it</span><br><span class="line"># implements certain methods.</span><br><span class="line"># There are two types, both of which only exist for Nodes: Names and</span><br><span class="line"># Groups.</span><br><span class="line"></span><br><span class="line"># Assuming...</span><br><span class="line"># A &quot;Quest&quot; object exists and 1) that it can &quot;complete&quot; or &quot;fail&quot; and</span><br><span class="line"># that it will have text available before and after each state...</span><br><span class="line"></span><br><span class="line"># 1. Use a name.</span><br><span class="line">var quest = $Quest</span><br><span class="line">print(quest.text)</span><br><span class="line">quest.complete() # or quest.fail()</span><br><span class="line">print(quest.text) # implied new text content</span><br><span class="line"></span><br><span class="line"># 2. Use a group.</span><br><span class="line">for a_child in get_children():</span><br><span class="line">	if a_child.is_in_group(&quot;quest&quot;):</span><br><span class="line">		print(quest.text)</span><br><span class="line">		quest.complete() # or quest.fail()</span><br><span class="line">		print(quest.text) # implied new text content</span><br><span class="line"></span><br><span class="line"># Note that these interfaces are project-specific conventions the team</span><br><span class="line"># defines (which means documentation! But maybe worth it?).</span><br><span class="line"># Any script that conforms to the documented &quot;interface&quot; of the name or</span><br><span class="line"># group can fill in for it.</span><br></pre></td></tr></table></figure>

<p>将访问权限外包给 Callable。当需要最大程度地摆脱依赖时，这种方法可能很有用。在这种情况下，人们依赖外部上下文来设置该方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># child.gd</span><br><span class="line">extends Node</span><br><span class="line">var fn = null</span><br><span class="line"></span><br><span class="line">func my_method():</span><br><span class="line">	if fn:</span><br><span class="line">		fn.call()</span><br><span class="line"></span><br><span class="line"># parent.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">@onready var child = $Child</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	child.fn = print_me</span><br><span class="line">	child.my_method()</span><br><span class="line"></span><br><span class="line">func print_me():</span><br><span class="line">	print(name)</span><br></pre></td></tr></table></figure>

<h3 id="Godot-通知"><a href="#Godot-通知" class="headerlink" title="Godot 通知"></a>Godot 通知</h3><p>Godot 中的每个对象都实现了 _notification 方法。其目的是允许对象响应可能与之相关的各种引擎级回调。<br>例如，如果引擎告诉 CanvasItem 去“绘制”，则它将调用 _notification(NOTIFICATION_DRAW)。</p>
<p>在所有这些通知之中，有很多类似“绘制”这样经常需要在脚本中去覆盖的通知，多到 Godot 要提供专用函数的地步：<br>_ready(): NOTIFICATION_READY<br>_enter_tree(): NOTIFICATION_ENTER_TREE<br>_exit_tree(): NOTIFICATION_EXIT_TREE<br>_process(delta): NOTIFICATION_PROCESS<br>_physics_process(delta): NOTIFICATION_PHYSICS_PROCESS<br>_draw(): NOTIFICATION_DRAW</p>
<p>用户可能不会意识到 Node 之外的类型也有通知，例如：<br>Object::NOTIFICATION_POSTINITIALIZE：在对象初始化期间触发的回调。脚本无法访问。<br>Object::NOTIFICATION_PREDELETE：在引擎删除 Object 之前触发的回调，即析构函数。<br>并且 Node 中存在的许多回调没有任何专用的方法，但仍然非常有用。<br>Node::NOTIFICATION_PARENTED: 将子节点添加到另一个节点时，会触发此回调。<br>Node::NOTIFICATION_UNPARENTED: 将子节点从另一个节点下删除时，会触发此回调。<br>你可以在通用的 _notification() 方法中访问所有这些自定义通知。</p>
<blockquote>
<p>文档中被标记为“virtual”的方法（即虚方法）可以被脚本覆盖重写。<br>一个经典的例子是 Object 中的 <em>init 方法。虽然它没有等效的 NOTIFICATION</em>* 通知，但是引擎仍然会调用该方法。大多数语言（C#除外）都将其用作构造函数。</p>
</blockquote>
<p>所以说，应该在哪些情况下使用这些通知或虚函数呢？</p>
<h4 id="对比-process、-physics-process、-input"><a href="#对比-process、-physics-process、-input" class="headerlink" title="对比 _process、_physics_process、*_input"></a>对比 _process、_physics_process、*_input</h4><p>当需要使用“依赖于帧速率的 delta 时间增量”时，请使用 _process。如果需要尽可能频繁地更新对象数据，也应该在这里处理。频繁执行的逻辑检查和数据缓存操作，大多数都在这里执行。但也需要注意执行频率，如果不需要每帧都执行，则可以选择用定时器循环来替代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Allows for recurring operations that don&#x27;t trigger script logic</span><br><span class="line"># every frame (or even every fixed frame).</span><br><span class="line">func _ready():</span><br><span class="line">	var timer = Timer.new()</span><br><span class="line">	timer.autostart = true</span><br><span class="line">	timer.wait_time = 0.5</span><br><span class="line">	add_child(timer)</span><br><span class="line">	timer.timeout.connect(func():</span><br><span class="line">		print(&quot;This block runs every 0.5 seconds&quot;)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>当需要与帧速率无关的时间增量时，请使用 _physics_process。如果代码需要随着时间的推移进行一致的更新，不管时间推进速度是快还是慢，那么就应该在这里执行代码。频繁执行的运动学和对象变换操作，应在此处执行。</p>
<p>为了获得最佳性能，应尽可能避免在这些回调期间进行输入检查。_process 和 _physics_process 每次都会触发（默认情况下这些更新回调不会 “休眠”）。相反，*_input 回调仅在引擎实际检测到输入的帧上触发。</p>
<p>在 input 回调中同样可以检查输入动作。如果要使用增量时间，则可以使用相关的增量时间获取方法来获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Called every frame, even when the engine detects no input.</span><br><span class="line">func _process(delta):</span><br><span class="line">	if Input.is_action_just_pressed(&quot;ui_select&quot;):</span><br><span class="line">		print(delta)</span><br><span class="line"></span><br><span class="line"># Called during every input event.</span><br><span class="line">func _unhandled_input(event):</span><br><span class="line">	match event.get_class():</span><br><span class="line">		&quot;InputEventKey&quot;:</span><br><span class="line">			if Input.is_action_just_pressed(&quot;ui_accept&quot;):</span><br><span class="line">				print(get_process_delta_time())</span><br></pre></td></tr></table></figure>
<h4 id="对比-init、初始化、导出"><a href="#对比-init、初始化、导出" class="headerlink" title="对比 _init、初始化、导出"></a>对比 _init、初始化、导出</h4><p>如果脚本初始化它自己的没有场景的节点子树，则该代码将会在 _init() 中执行。其他属性或独立于 SceneTree 的初始化也应在此处运行。<br>_init() 在 _enter_tree() 或 _ready() 之前触发，但在脚本创建并初始化其属性之后。实例化场景时，属性值将按照以下顺序设置：<br>初始值赋值：为属性赋初始值，未指定初始值时赋默认值。Setter 函数即便存在也不会使用。<br><code>_init()</code> 赋值：在 _init() 中通过各种赋值改变属性的取值，会触发 setter 函数。<br>导出值赋值：如果在“检查器”中修改了导出属性的值，就会再次修改该属性的值，会触发 setter 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># test is initialized to &quot;one&quot;, without triggering the setter.</span><br><span class="line">@export var test: String = &quot;one&quot;:</span><br><span class="line">	set(value):</span><br><span class="line">		test = value + &quot;!&quot;</span><br><span class="line"></span><br><span class="line">func _init():</span><br><span class="line">	# Triggers the setter, changing test&#x27;s value from &quot;one&quot; to &quot;two!&quot;.</span><br><span class="line">	test = &quot;two&quot;</span><br><span class="line"></span><br><span class="line"># If someone sets test to &quot;three&quot; from the Inspector, it would trigger</span><br><span class="line"># the setter, changing test&#x27;s value from &quot;two!&quot; to &quot;three!&quot;</span><br></pre></td></tr></table></figure>
<p>因此，选择实例化脚本还是实例化场景，对初始化和引擎调用 setter 的次数都会产生影响。</p>
<h4 id="对比-ready、-enter-tree、NOTIFICATION-PARENTED"><a href="#对比-ready、-enter-tree、NOTIFICATION-PARENTED" class="headerlink" title="对比 _ready、_enter_tree、NOTIFICATION_PARENTED"></a>对比 _ready、_enter_tree、NOTIFICATION_PARENTED</h4><p>将场景实例化并首次添加到运行的场景树时，Godot 会沿着场景树从上至下实例化节点（调用 _init() 函数），再从根节点出发从上至下构建场景树。因此 _enter_tree() 是按照树的顺序从上至下一级一级调用的。场景树构建完成后，所有叶节点就会调用 _ready。一个节点的所有子节点都调用完该方法后，就会轮到该节点自己调用。此时就是逆着树的顺序从下至上一级一级调用的，最终到达根节点。</p>
<p>当实例化脚本或独立的场景时，节点不会在创建时被添加到 SceneTree 中，所以未触发 _enter_tree 回调。而只有 _init 调用发生。当场景被添加到 SceneTree 时，才会调用 _enter_tree 和 _ready。</p>
<p>如果需要触发作为节点设置父级到另一个节点而发生的行为, 无论它是否作为在主要&#x2F;活动场景中的部分发生, 都可以使用 PARENTED 通知. 例如, 这有一个将节点方法连接到其父节点上自定义信号, 而不会失败的代码段。对可能在运行时创建并以数据为中心的节点很有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">var parent_cache</span><br><span class="line"></span><br><span class="line">func connection_check():</span><br><span class="line">	return parent_cache.has_user_signal(&quot;interacted_with&quot;)</span><br><span class="line"></span><br><span class="line">func _notification(what):</span><br><span class="line">	match what:</span><br><span class="line">		NOTIFICATION_PARENTED:</span><br><span class="line">			parent_cache = get_parent()</span><br><span class="line">			if connection_check():</span><br><span class="line">				parent_cache.interacted_with.connect(_on_parent_interacted_with)</span><br><span class="line">		NOTIFICATION_UNPARENTED:</span><br><span class="line">			if connection_check():</span><br><span class="line">				parent_cache.interacted_with.disconnect(_on_parent_interacted_with)</span><br><span class="line"></span><br><span class="line">func _on_parent_interacted_with():</span><br><span class="line">	print(&quot;I&#x27;m reacting to my parent&#x27;s interaction!&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="数据偏好"><a href="#数据偏好" class="headerlink" title="数据偏好"></a>数据偏好</h3><h4 id="数组、字典、对象"><a href="#数组、字典、对象" class="headerlink" title="数组、字典、对象"></a>数组、字典、对象</h4><p>Godot 把脚本 API 中的所有变量都存储在 Variant 中。Variant 可以存储兼容数据结构。<br>例如 Array （数组）、 Dictionary （字典）、 Object （对象）。</p>
<p>Godot 使用 Vector<Variant> 实现数组。引擎会将数组内容存储在一段连续的内存之中，也就是说，元素与元素之间是相邻的。</p>
<blockquote>
<p>这里的 Vector 是传统 C++ STL 库中数组对象的名称，是个“模板”类型，即它只能存储特定类型的数据（用尖括号表示）。<br>例如，PackedStringArray 其实就类似于 Vector<String>。<br>因为是在内存中连续存储，所以执行各种操作的性能如下：<br>迭代：最快，非常适合循环。</p>
</blockquote>
<ul>
<li>操作：把计数器加一即可获取下一个元素。</li>
</ul>
<p>插入、删除、移动：与位置相关，一般较慢。</p>
<ul>
<li>操作：元素的添加、删除、移动需要移动与之相邻的元素（腾出地方或者填充空缺）。</li>
<li>在末尾添加、删除很快。</li>
<li>在任意位置添加、删除较慢。</li>
<li>在开头添加、删除最慢。</li>
<li>如果需要在开头执行多次插入、删除操作，那么……<ol>
<li>反转数组。</li>
<li>通过循环在末尾执行数组更改。</li>
<li>再把数组反转回来。<br>  这样就只复制了两次数组（虽然比较慢，但还是常数时间），否则就得把平均大概一半的数组复制 N 遍（线性时间）。</li>
</ol>
</li>
</ul>
<p>取值、设值：因为是按位置存取的，所以最快。例如你可以请求第 0 个、第 2 个、第 10 个等等的元素，但不能按照元素的值来请求。</p>
<ul>
<li>操作：把起始位置做一次加法，得到所需的索引。</li>
</ul>
<p>查找：最慢。根据值获取索引，也就是位置。</p>
<ul>
<li><p>操作：必须遍历数组，一个个元素做比较，直到找到匹配的为止。</p>
<ul>
<li>性能同时也取决于是否需要查遍整个数组才能找到目标。</li>
</ul>
</li>
<li><p>如果数组能够保持一定的顺序，自定义搜索操作可以缩短到对数时间（相对而言很快）。不过外行用户不会对此感到满意。做法是每次编辑后都重新对 Array 进行排序，编写利用已排序特性的搜索算法。</p>
</li>
</ul>
<p>Godot 将 Dictionary 实现为 HashMap&lt;Variant, Variant, VariantHasher, StringLikeVariantComparator&gt; .引擎存储一个键值对的小数组（初始化为 2^3 或 8 条记录）。当人们尝试访问一个值时，他们会为其提供一个密钥。然后它对密钥进行哈希处理 ，即将它转换为一个数字。“哈希”用于计算数组中的索引。作为一个数组，HM 在映射到值的键的“表”中进行快速查找。当 HashMap 变得太满时，它会增加到 2 的下一个幂（因此，16 条记录，然后是 32 条记录，依此类推）并重建结构。</p>
<p>使用哈希是为了减少键的冲突几率。发生冲突时，哈希表必须重新计算索引号，将占据原有位置的值纳入考虑范围。<br>总之，这样做就能够以牺牲内存和一些较小的操作效率为代价，让所有记录的访问都达到常数时间。</p>
<ol>
<li><p>对每个键进行任意次哈希。<br>哈希操作是常量时间的，因此即使某个算法必须执行多次，只要哈希的计算次数与表的密度没有什么大关系，那么就能够保持较快的速度。这样……</p>
</li>
<li><p>保持不断增长的表规模.<br>HashMaps为了减少哈希冲突, 并保持访问速度, 在表中保留了未使用的内存的间隙. 这就是为什么它总是会以2幂为倍数扩展其容量.</p>
</li>
</ol>
<p>如大家所知，字典擅长的任务是数组所不擅长的。其操作细节概述如下：</p>
<ul>
<li>迭代 : 快速.<ul>
<li>操作: 遍历映射的内部散列向量. 返回每个键. 之后, 用户使用该键跳转到并返回所需的值.</li>
</ul>
</li>
<li>插入, 删除, 移动 : 最快.<ul>
<li>操作: 散列给定的键. 执行1个加法操作来查找适当的值(数组开始+偏移量). 移动其中的两个(一个插入, 一个擦除). 映射必须进行一些维护, 以保留其功能:<ol>
<li>更新记录的有序列表.</li>
<li>确定列表密度, 是否需要扩展列表容量.</li>
</ol>
</li>
<li>字典会记住用户插入键的顺序. 这使它能够执行可靠的迭代.</li>
</ul>
</li>
<li>取值, 设值 : 最快. 和 根据键 查找相同.<ul>
<li>操作: 和插入&#x2F;删除&#x2F;移动类似.</li>
</ul>
</li>
<li>查找 : 最慢. 标识值的键.<ul>
<li>操作: 必须遍历记录并比较该值, 直到找到匹配的为止.</li>
<li>请注意,Godot并未开箱即用地提供此功能(因为它们并非用于此任务).</li>
</ul>
</li>
</ul>
<p>Godot用愚蠢, 但动态的方式容纳数据容器实现对象. 提出问题时, 对象将查询数据源. 例如, 要回答”你是否有一个名为 position 的属性？”的问题, 它可能会询问其 script 或 ClassDB. 你可以在 在 Godot 中应用面向对象原则 文章中, 找到有关什么是对象以及它们如何工作的更多信息.</p>
<p>这里重要的细节是对象任务的复杂性. 每次执行这些多源查询时, 它运行 几个 迭代循环和哈希表查找. 此外, 查询是线性时间操作, 依赖于对象的继承层次结构大小. 如果 Object 查询的类(当前类)什么都没有找到, 则该请求将一直推迟到下一个基类, 一直到原始 Object 类为止. 虽然这些都是单独的快速操作, 但它必须进行如此多的检查, 于是这一事实使得它们比查找数据的两种方法都要慢.</p>
<blockquote>
<p>当开发人员提到脚本API有多慢时, 所引用的正是这一系列查询. 与编译后的, 应用程序知道在哪里可以找到任何东西的,C++代码相比, 不可避免的是, 脚本API操作将花费更长的时间. 他们必须定位任何相关数据的来源, 然后才能尝试访问它.<br>GDScript 很慢的原因是, 它执行的每个操作都要经过这个系统.<br>C#可以通过更优化的字节码, 以更快的速度处理一些内容. 但是, 如果C#脚本调用引擎类的内容, 或者脚本试图访问它的外部内容, 它会通过这个管道.<br>NativeScript C++甚至更进一步, 默认将所有内容都保持在内部. 对外部结构的调用将通过脚本API进行. 在NativeScript C++中, 注册方法以将其公开给脚本API是一项手动任务. 至此, 外部非C++类将使用API来查找它们.</p>
</blockquote>
<p>因此, 假设从引用扩展到创建数据结构, 比如一个 Array 或 Dictionary, 为什么选择一个 Object 而不是其他两个选项？<br>控件 : 对象能够创建更复杂的结构. 可以在数据上分层抽象, 以确保外部API不会响应内部数据结构的更改. 更重要的是, 对象可以有信号, 允许响应式行为. 对象带来了创建更复杂结构的能力.<br>清晰 : 当涉及到脚本和引擎类为对象定义的数据时, 对象是一个可靠的数据源. 属性可能不包含期望的值, 但是无需担心这个属性是否首先存在.<br>便利 : 如果已经有了类似的数据结构, 之后从现有类扩展, 可以使构建数据结构的任务变得容易得多. 相比之下, 数组和字典不能满足所有的用例.</p>
<p>对象还让用户有机会创建更专门化的数据结构。有了它，一个人可以设计自己的列表、二叉搜索树、堆、散列树、图、不相交集，以及其他选择。<br>“为什么不在树结构中使用节点？” 有人可能会问. 节点类包含与自定义数据结构无关的内容. 因此在构建树结构时, 构造自己的节点类型是很有帮助的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extends Object</span><br><span class="line">class_name TreeNode</span><br><span class="line"></span><br><span class="line">var _parent: TreeNode = null</span><br><span class="line">var _children := []</span><br><span class="line"></span><br><span class="line">func _notification(p_what):</span><br><span class="line">	match p_what:</span><br><span class="line">		NOTIFICATION_PREDELETE:</span><br><span class="line">			# Destructor.</span><br><span class="line">			for a_child in _children:</span><br><span class="line">				a_child.free()</span><br></pre></td></tr></table></figure>
<p>这里开始, 然后就可以创建具有特定功能的结构, 只会受到他们想象力的限制.</p>
<h4 id="枚举：整数-VS-字符串"><a href="#枚举：整数-VS-字符串" class="headerlink" title="枚举：整数 VS 字符串"></a>枚举：整数 VS 字符串</h4><p>大多数语言都提供了枚举类型，GDScript 也不例外。但与其他大多数语言不同的是，GDScript 的枚举允许开发者使用整数或字符串作为枚举值（后者只有在 GDScript 中使用 @export_enum 注解时才可以使用）。 那么问题来了：“该用哪一种枚举？”<br>简单回答一下就是：“你觉得哪个更舒服就选哪个。” 这是 GDScript 特有的特性，并非（C++、C#等）一般的 Godot 脚本所特有的特性；该语言将可用性置于性能之上。<br>在技术层面上，整数比较（常量时间）比字符串比较（线性时间）更快，若想保持其他语言中使用枚举的习惯，则应使用整数来表示枚举值。<br>当你想要 打印 枚举值时，使用整数的主要问题就出现了：尝试直接打印以 int 型保存的枚举 MY_ENUM 会打印 5 之类的东西，而不是像 MyEnum 这样的字符。若要打印以 int 型保存的枚举。必须编写一个字典来映射每个枚举所对应的字符串值。<br>如果开发者使用枚举的主要目的是打印值，并希望将它们作为相关概念组合在一起，那么将枚举作为字符串使用是有意义的。这样一来，也就不需要在打印上执行单独的数据结构了。</p>
<h4 id="AnimatedTexture-vs-AnimatedSprite2D-vs-AnimationPlayer-vs-AnimationTree"><a href="#AnimatedTexture-vs-AnimatedSprite2D-vs-AnimationPlayer-vs-AnimationTree" class="headerlink" title="AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree"></a>AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree</h4><p>在什么情况下应该使用Godot的各种动画类？对于Godot的新用户来说, 可能不是马上清楚答案.</p>
<p>AnimatedTexture 是引擎绘制一个动画循环, 而不是一个静态图像的纹理. 用户可以进行如下操作：</p>
<ol>
<li>它在纹理的每个部分移动的速率（FPS）。</li>
<li>纹理中包含的区域数(帧).</li>
</ol>
<p>Godot 的 RenderingServer 会按照规定的速度依次绘制区块。好处是不涉及引擎部分额外的逻辑。坏处是用户几乎没有控制权。</p>
<p>另外请注意，AnimatedTexture 是一种 Resource，与此处讨论的其他 Node 对象不同。可以创建 Sprite2D 节点，使用 AnimatedTexture 作为其纹理。或者（仅在其他方法无法满足要求时）可以将 AnimatedTexture 作为图块添加到 TileSet 中并将其与 TileMapLayer 集成到一起，从而获得自动动画化的背景。使用此方法时所有的渲染将在单个批处理内绘制调用。</p>
<p>AnimatedSprite2D 节点可以与 SpriteFrames 资源结合使用，使用户可以通过精灵表创建各种动画序列、在动画之间切换并控制它们的速度、区域偏移量和方向。这使得它们非常适合控制基于二维的帧动画。</p>
<p>若需要触发与动画更改相关的其他效果，例如创建粒子效果、调用函数或操作与帧动画无关的其他外围元素，则需要将一个 AnimationPlayer 节点与 AnimatedSprite2D 关联。</p>
<p>如果你想设计更复杂的二维动画系统，AnimationPlayer 也是你的必备工具，例如：</p>
<ol>
<li>剪纸动画：在运行时编辑精灵的变换。</li>
<li>二维网格动画：为精灵的纹理划分一个区域，并将骨架绑定在上面。然后动画化其中的骨骼，使骨骼按照彼此之间的关系，成比例地拉伸和弯曲纹理。</li>
</ol>
<p>虽然我们需要一个 AnimationPlayer, 来为游戏设计每个独立的动画序列, 它也可以用来混合复合动画, 也就是说, 在这些动画之间实现平滑的转换. 在为对象规划的动画之间, 也可能存在一个层次结构. 在这些情况下使用 AnimationTree 效果很出色. 可以在 这里 找到关于使用 AnimationTree 的深入指南.</p>
<h3 id="逻辑偏好"><a href="#逻辑偏好" class="headerlink" title="逻辑偏好"></a>逻辑偏好</h3><h4 id="先添加节点还是先修改属性？"><a href="#先添加节点还是先修改属性？" class="headerlink" title="先添加节点还是先修改属性？"></a>先添加节点还是先修改属性？</h4><p>运行时使用脚本初始化节点时，你可能需要对节点的名称、位置等属性进行修改。常见的纠结点在于，你应该什么时候去修改？</p>
<p>最佳实践是在节点加入场景树之前修改取值。部分属性的 setter 代码会更新其他对应的值，可能会比较慢！大多数情况下，这样的代码不会对游戏的性能产生影响，但对于程序式生成之类的重型使用场景，就可能让游戏卡成 PPT。</p>
<p>综上，最佳的做法就是先为节点设置初始值，然后再把它添加到场景树中。有值在被加入场景树之前不能被设置的例外情况，比如设置世界坐标的时候。</p>
<h4 id="加载-VS-预加载"><a href="#加载-VS-预加载" class="headerlink" title="加载 VS 预加载"></a>加载 VS 预加载</h4><p>在 GDScript 中，存在全局 preload 方法。它尽可能早地加载资源，以便提前进行“加载”操作，并避免在执行性能敏感的代码时加载资源。</p>
<p>其对应的 load 方法只有在执行 load 语句时才会加载资源。也就是说，它将立即加载资源。所以，在敏感进程中加载资源会造成速度减慢。load() 函数是可以被 所有 脚本语言访问的 ResourceLoader.load(path) 的别名。</p>
<p>那么, 预加载和加载到底在什么时候发生, 又应该什么时候使用这两种方法呢？我们来看一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># my_buildings.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line"># Note how constant scripts/scenes have a different naming scheme than</span><br><span class="line"># their property variants.</span><br><span class="line"></span><br><span class="line"># This value is a constant, so it spawns when the Script object loads.</span><br><span class="line"># The script is preloading the value. The advantage here is that the editor</span><br><span class="line"># can offer autocompletion since it must be a static path.</span><br><span class="line">const BuildingScn = preload(&quot;res://building.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># 1. The script preloads the value, so it will load as a dependency</span><br><span class="line">#    of the &#x27;my_buildings.gd&#x27; script file. But, because this is a</span><br><span class="line">#    property rather than a constant, the object won&#x27;t copy the preloaded</span><br><span class="line">#    PackedScene resource into the property until the script instantiates</span><br><span class="line">#    with .new().</span><br><span class="line">#</span><br><span class="line"># 2. The preloaded value is inaccessible from the Script object alone. As</span><br><span class="line">#    such, preloading the value here actually does not benefit anyone.</span><br><span class="line">#</span><br><span class="line"># 3. Because the user exports the value, if this script stored on</span><br><span class="line">#    a node in a scene file, the scene instantiation code will overwrite the</span><br><span class="line">#    preloaded initial value anyway (wasting it). It&#x27;s usually better to</span><br><span class="line">#    provide null, empty, or otherwise invalid default values for exports.</span><br><span class="line">#</span><br><span class="line"># 4. It is when one instantiates this script on its own with .new() that</span><br><span class="line">#    one will load &quot;office.tscn&quot; rather than the exported value.</span><br><span class="line">@export var a_building : PackedScene = preload(&quot;office.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># Uh oh! This results in an error!</span><br><span class="line"># One must assign constant values to constants. Because `load` performs a</span><br><span class="line"># runtime lookup by its very nature, one cannot use it to initialize a</span><br><span class="line"># constant.</span><br><span class="line">const OfficeScn = load(&quot;res://office.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># Successfully loads and only when one instantiates the script! Yay!</span><br><span class="line">var office_scn = load(&quot;res://office.tscn&quot;)</span><br></pre></td></tr></table></figure>
<p>预加载允许脚本在加载脚本时处理所有加载. 预加载是有用的, 但也有一些时候, 人们并不希望这样. 为了区分这些情况, 我们可以考虑以下几点:</p>
<ol>
<li>如果无法确定何时可以加载脚本, 则预加载资源, 尤其是场景或脚本, 可能会导致进一步加载, 这是人们所不希望的. 这可能会导致无意中, 在原始脚本的加载操作之上的可变长度加载时间. 在原始脚本的加载操作之上, 这可能导致意外的, 可变长度的加载时间.</li>
<li>如果其他东西可以代替该值(例如场景导出的初始化), 则预加载该值没有任何意义. 如果打算总是自己创建脚本, 那么这一点并不是重要因素.</li>
<li>如果只希望“导入”另一个类资源（脚本或者场景），那么最好的解决方法就是使用预加载常量（Preloaded Constant）。不过也有例外的情况：<ol>
<li>如果“导入”的类有可能发生变化，那么就应该是属性，使用 @export 或 load() 初始化（或者甚至更晚一些才初始化）。</li>
<li>如果脚本需要大量依赖关系，又不想消耗太多内存，则可以在环境变化时动态地加载或卸载各种依赖关系。如果将资源预加载为常量，则卸载这些资源的唯一方法是卸载整个脚本。如果改为加载属性，则可以将它们设置为 null 并完全删除对资源的所有引用（扩展自 RefCounted 的类型会在指向其的所有引用均已消失时自动释放内存）。</li>
</ol>
</li>
</ol>
<h4 id="大型关卡：静态-VS-动态"><a href="#大型关卡：静态-VS-动态" class="headerlink" title="大型关卡：静态 VS 动态"></a>大型关卡：静态 VS 动态</h4><p>如果正在创建一个大型关卡, 哪种情况是最合适的？他们应该将关卡创建为一个静态空间吗？还是他们应该分阶段加载关卡, 并根据需要改变世界的内容？<br>答案很简单，“当性能需要的时候”。与这两种选择有关的困境是一种古老的编程选择：优化内存还是速度？<br>最简单的方法是使用静态关卡, 它可以一次加载所有内容. 但是, 这取决于项目, 这可能会消耗大量内存. 浪费用户的运行内存会导致程序运行缓慢, 或者计算机在同一时间尝试做的所有其他事情都会崩溃.<br>无论如何，应该将较大的场景分解为较小的场景（以利于资产重用）。然后，开发人员可以设计一个节点，该节点实时管理资源和节点的创建&#x2F;加载和删除&#x2F;卸载。具有大型多样环境或程序生成的元素的游戏，通常会实行这些策略，以避免浪费内存。<br>另一方面, 对动态系统进行编码更复杂, 即, 使用更多的编程逻辑, 这会导致出现错误和bug的机会. 如果不小心的话, 开发的系统, 会增加应用程序的技术成本.</p>
<p>因此, 最好的选择是…</p>
<ol>
<li>在小型游戏中使用静态关卡.</li>
<li>在开发中型&#x2F;大型游戏时, 如果有时间&#x2F;资源, 可以去创建一个可以对节点和资源的管理进行编码的库或插件. 如果随着时间的流逝而改进, 以提高可用性和稳定性, 那么它可能会演变成跨项目的可靠工具.</li>
<li>为一款中&#x2F;大型游戏编写动态逻辑代码, 因为你拥有编程技能, 但却没有时间或资源去完善代码(必须要完成游戏). 以后可能会进行重构, 将代码外包到插件中.</li>
</ol>
<p>有关在运行时中, 可以交换场景的各种方式的示例, 请参见文档 手动更改场景 .</p>
<h3 id="项目组织"><a href="#项目组织" class="headerlink" title="项目组织"></a>项目组织</h3><h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>Godot本质上是基于场景的, 并按原样使用文件系统, 而没有元数据或资产数据库.<br>与其他引擎不同, 场景本身包含许多资源, 因此文件系统中的文件数量要少得多.<br>考虑到这一点, 最常见的方法是将资产编组得尽可能接近场景；当项目变大时, 它使其更易于维护.<br>举例来说，人们通常可以将基本资产（例如精灵图像、3D 模型网格、材质和音乐等）放入一个文件夹中。然后，它们可以使用一个单独的文件夹来存储使用它们的构建关卡。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/project.godot</span><br><span class="line">/docs/.gdignore  # See &quot;Ignoring specific folders&quot; below</span><br><span class="line">/docs/learning.html</span><br><span class="line">/models/town/house/house.dae</span><br><span class="line">/models/town/house/window.png</span><br><span class="line">/models/town/house/door.png</span><br><span class="line">/characters/player/cubio.dae</span><br><span class="line">/characters/player/cubio.png</span><br><span class="line">/characters/enemies/goblin/goblin.dae</span><br><span class="line">/characters/enemies/goblin/goblin.png</span><br><span class="line">/characters/npcs/suzanne/suzanne.dae</span><br><span class="line">/characters/npcs/suzanne/suzanne.png</span><br><span class="line">/levels/riverdale/riverdale.scn</span><br></pre></td></tr></table></figure>

<h4 id="风格指南"><a href="#风格指南" class="headerlink" title="风格指南"></a>风格指南</h4><p>为了项目之间的一致性，我们建议遵循以下规范：</p>
<ol>
<li>使用 snake_case 风格为文件夹和文件命名(除了c#脚本). 这避免了在 Windows 上导出项目时可能出现的大小写敏感问题.C# 脚本是这个规则的一个例外, 因为按照惯例是用类名来对它们命名, 而类名应该是 PascalCase 风格.</li>
<li>使用 PascalCase 风格对节点进行命名, 这与内置的节点大小写风格一致.</li>
<li>通常, 将第三方资源放在顶级的 addons&#x2F; 文件夹中, 即使它们不是编辑器插件. 这样更加容易跟踪哪些文件是第三方文件. 当然这个规则也有一些例外: 如果你要使用第三方游戏资源创建角色, 将这些资源和角色场景及脚本放在同一文件夹下会更好.</li>
</ol>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>因此，现在可以从项目文件夹中透明地导入资产。</p>
<p>忽略具体文件夹<br>为防止 Godot 导入特定文件夹中的文件, 请在文件夹中创建一个名为 .gdignore 的空文件(以 . 号开头). 这对于加快初始项目导入非常有用.</p>
<blockquote>
<p>要在 Windows 上创建文件名以点开头的文件，请在文件名的前后都写一个点（“.gdignore.”）。确认之后 Windows 会自动移除末尾的点。<br>你也可以使用文本编辑器来创建它，例如记事本。或在命令提示符中输入以下命令：type nul &gt; .gdignore<br>一旦文件夹被忽略，其中资源就不能再使用 load() 和 preload() 方法加载。被忽略文件夹会从文件系统栏目中隐藏，从而减少混乱。<br>请注意 .gdignore 文件的内容会被忽略，因此该文件应当为空。它不像 .gitignore 文件一样支持模式匹配。</p>
</blockquote>
<h4 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h4><p>Windows 和最近版本的 macOS 默认使用不区分大小写的文件系统，而 Linux 发行版默认使用区分大小写的文件系统。由于 Godot 的 PCK 虚拟文件系统区分大小写，因此在导出项目后可能会导致问题。为了避免这种情况，建议对项目中的所有文件都使用 snake_case 蛇形命名法（一般使用小写）。</p>
<h3 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h3><p>版本控制插件<br>Godot 旨在对版本控制系统（Version Control System，VCS）友好，并尽量生成可读且可合并的文件。<br>Godot 支持通过插件在编辑器本身中使用 VCS。可以在编辑器中的项目&gt; 版本控制下设置或关闭 VCS。</p>
<p>截至 2023 年 7 月，尚且只有一个 Git 插件可用，但社区可能会创建其他的 VCS 插件。</p>
<p>官方 Git 插件<br>有一个官方插件可以让你在编辑器中使用 Git。你可以在GitHub找到最新的版本。</p>
<p>最新的更新、文档和源代码可以在Godot iOS插件库找到 Godot iOS plugins repository。<br>最新的更新、文档和源代码可以在 Godot iOS 插件库找到 Godot iOS plugins repository。</p>
<p>从 VCS 中排除的文件<br>当第一次在编辑器中打开项目时，Godot 会自动创建一些文件和文件夹。 为了避免生成的数据使版本控制仓库膨胀，你应该将它们添加到 VCS 忽略中：<br>.godot&#x2F;：此文件夹存储各种项目缓存数据。</p>
<p>*.translation：这些文件是从 CSV 文件生成的导入后的的二进制翻译文件。</p>
<p>你可以选择在 Godot 项目管理器创建项目时自动生成版本控制元数据。当选择 Git 选项时，将在项目根目录中创建 .gitignore 和 .gitattributes 文件：<br>在现有的项目中，选择编辑器顶部的 项目 菜单，然后选择 版本控制 &gt; 生成版本控制元数据。这将与在项目管理器中执行的操作一样创建相同的文件。</p>
<p>在 Windows 上使用 Git<br>大多数 Git for Windows 客户端都将 core.autocrlf 设置为 true。可能会导致部分文件错误地被 Git 标记为已修改，因为这些文件的行尾被自动从 LF 转换成了 CRLF。</p>
<p>最好将此选项设置为：</p>
<p>git config –global core.autocrlf input</p>
<p>使用项目管理器或编辑器创建版本控制元数据时，会使用 .gitattributes 文件自动强制使用 LF 行尾，因此无需更改 Git 配置。</p>
<p>Git LFS<br>Git LFS（大文件存储）是一个 Git 扩展，允许您管理存储库中的大文件。它用 Git 中的文本指针替换大文件，同时将文件内容存储在远程服务器上。这对于管理大型资产（例如纹理、音频文件和 3D 模型）非常有用，而不会使 Git 存储库膨胀。</p>
<blockquote>
<p>使用 Git LFS 时，您需要确保在将任何文件提交到存储库之前已设置它。如果您已经将文件提交到存储库，则需要将它们从存储库中删除，并在设置 Git LFS 后重新添加它们。<br>可以使用 git lfs migrate 来转换存储库中的现有文件，但这更深入，需要对 Git 有很好的了解。<br>一种常见的方法是使用 Git LFS（和适当的 .gitattributes）设置一个新存储库，然后将文件从旧存储库复制到新存储库。这样，您可以确保所有文件从一开始就被 LFS 跟踪。</p>
</blockquote>
<p>要将 Git LFS 与 Godot 一起使用，您需要安装 Git LFS 扩展并将其配置为跟踪要管理的文件类型。您可以通过在终端中运行以下命令来执行此作：<br>这将在您的存储库中创建一个 .gitattributes 文件，该文件告诉 Git 对指定的文件类型使用 LFS。您可以通过修改 .gitattributes 文件来添加更多文件类型。例如，要跟踪所有 GLB 文件，您可以通过在终端中运行以下命令来执行此作：<br>git lfs track “*.glb”</p>
<p>当您添加或修改 LFS 跟踪的文件时，Git 会自动将它们存储在 LFS 中，而不是常规的 Git 历史记录中。您可以像常规 Git 文件一样推送和拉取 LFS 文件，但请记住，LFS 文件与 Git 历史记录的其余部分分开存储。这意味着您可能需要在将存储库克隆到的任何计算机上安装 Git LFS 才能访问 LFS 文件。<br>下面是一个示例 .gitattributes 文件，您可以将其用作 Git LFS 的起点。之所以选择这些文件类型，是因为它们常用，但您可以修改列表以包含项目中可能拥有的任何二进制类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># Normalize EOL for all files that Git considers text files.</span><br><span class="line">* text=auto eol=lf</span><br><span class="line"></span><br><span class="line"># Git LFS Tracking (Assets)</span><br><span class="line"></span><br><span class="line"># 3D Models</span><br><span class="line">*.fbx filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.gltf filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.glb filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.blend filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.obj filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Images</span><br><span class="line">*.png filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.svg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.jpg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.jpeg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.gif filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.tga filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.webp filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.exr filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.hdr filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.dds filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Audio</span><br><span class="line">*.mp3 filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.wav filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.ogg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Font &amp; Icon</span><br><span class="line">*.ttf filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.otf filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.ico filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Godot LFS Specific</span><br><span class="line">*.scn filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.res filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.material filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.anim filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.mesh filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.lmbake filter=lfs diff=lfs merge=lfs -text</span><br></pre></td></tr></table></figure>
<p>有关 Git LFS 的更多信息，请查看官方文档： <a target="_blank" rel="noopener" href="https://git-lfs.github.com/">https://git-lfs.github.com/</a> 和 <a target="_blank" rel="noopener" href="https://docs.github.com/en/repositories/working-with-files/managing-large-files%E3%80%82">https://docs.github.com/en/repositories/working-with-files/managing-large-files。</a></p>
<h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><ol>
<li>编辑器运行缓慢，占用所有的 CPU 和 GPU 资源<br>尤其是在 macOS 上，因为大多数 Mac 都有 Retina 显示屏。<br>由于 Retina 显示器的像素密度更高，因此所有内容都必须以更高的分辨率渲染。会增加 GPU 上的负载并降低感知性能。</li>
</ol>
<p>有几种衡量性能和电池续航的方法：</p>
<ul>
<li>在 3D 模式下，单击左上角的透视按钮并启用半分辨率。现在 3D 视口就会以半分辨率渲染，速度最多可以提高到原来的 4 倍。</li>
<li>打开编辑器设置并将低处理器模式睡眠（微秒）的值增加到 33000（30 FPS）。该值决定了渲染每帧画面之间所间隔的时间（微秒单位）。 较高的值将会使编辑器操作起来没有那么跟手，但可显著降低 CPU 和 GPU 使用率。</li>
<li>如果有某个节点导致编辑器连续重新绘制（例如粒子），请将其隐藏并在脚本中使用 _ready() 方法显示它。这样，它将隐藏在编辑器中，但仍在正在运行的项目中可见。</li>
</ul>
<ol start="2">
<li>编辑器在我的可变刷新率显示器（G-Sync&#x2F;FreeSync）上出现卡顿和闪烁的情<br>可变刷新率显示器需要不断调整其伽玛曲线，以便随着时间的推移发出一致的光量。<br>当刷新率变化很大时，这可能会导致图像的黑暗区域出现闪烁，这是因为 Godot 编辑器仅在必要时重绘。</li>
</ol>
<p>这有几种解决办法：</p>
<ul>
<li>在编辑器设置中启用界面 &gt; 编辑器 &gt; 持续更新。即使画面没有变化，编辑器也将不断渲染。请注意，这会增加功耗、加大热量和噪音排放。<br>为了缓解这种情况，你可以在编辑器设置中将低处理器模式睡眠（微秒）增加到 33000（30 FPS）。<br>该值决定了渲染每帧画面之间所间隔的时间（微秒单位）。<br>较高的值将会使编辑器操作起来没有那么跟手，但可显著降低 CPU 和 GPU 使用率。</li>
<li>在显示器或图形驱动程序中禁用可变刷新率。</li>
<li>VRR 闪烁这个问题在某些显示器上，可以通过你的显示器的 OSD 中的 VRR 控制或微调暗区选项来减少。这些选项可能会增加输入延迟或导致黑色失真。</li>
<li>如果使用 OLED 显示器，可以在编辑器设置中使用 Black (OLED) 编辑器主题预设。因为 OLED 显示器的出色的黑阶表现，这可以隐藏 VRR 闪烁。</li>
</ul>
<ol start="3">
<li>编辑器或项目花了很长时间才启动<br>使用基于 Vulkan 的渲染器（Forward+ 或 Mobile）时，首次启动将会花费较长的时间。<br>这是因为着色器需要先编译才能进行缓存。更新 Godot、更新显卡驱动或切换显卡后，着色器也需要重新缓存。</li>
</ol>
<p>如果这个问题在首次启动后依然存在，那么这是 Windows 上的一个已知错误，当你连接了特定的 USB 外设时就会出现 。特别是，海盗船的 iCUE 软件似乎引起了该错误。尝试将 USB 外设的驱动程序更新为最新版本。如果错误仍然存在，则需要在打开编辑器之前断开故障外围设备的连接。然后，你可以再次连接外围设备。</p>
<p>Portmaster 等防火墙软件可能会屏蔽调试端口，导致项目启动时间变长，并且无法在编辑器中使用调试功能（例如查看 print() 的输出）。变通方法是在“编辑器设置”中修改项目所使用的调试端口（网络 &gt; 调试 &gt; 远程端口）。默认值是 6007；可以尝试设成大于 1024 的值，比如 7007。</p>
<p>在 Windows 上，当首次加载项目时，如果电脑刚开机，Windows Defender 会导致项目启动时文件系统缓存验证耗时显著增加。对于文件较多的项目尤为明显。考虑通过以下步骤将项目文件夹添加到排除列表中：病毒与威胁防护 &gt; 病毒与威胁防护设置 &gt; 添加或删除排除项。</p>
<ol start="4">
<li>点击系统控制台后 Godot 编辑器没有响应<br>在启用了系统控制台的 Windows 上运行 Godot 时，你可以通过在命令窗口中单击来意外启用选择模式。Windows 的这种特定行为会暂停应用程序，以便你在系统控制台内选择文本。Godot 无法覆盖此系统特定的行为。</li>
</ol>
<p>要解决此问题，请选择系统控制台窗口，然后按 Enter 退出选择模式。</p>
<ol start="5">
<li>手动移动 Godot 编辑器的 macOS Dock 图标之后出现多余的编辑器图标<br>如果你打开 Godot 编辑器并手动改变 dock 图标的位置，然后重启编辑器，你会在 dock 的最右边看到一个重复的 dock 图标。</li>
</ol>
<p>这是由于 macOS dock 的设计限制造成的。解决这个问题的唯一已知方法是将项目管理器和编辑器合并为一个进程，这意味着项目管理器在启动编辑器时不再产生一个单独的进程。虽然使用单一进程实例会带来一些好处，但由于任务的复杂性，完成这个功能没有列入我们近期的工作计划。</p>
<p>为了避免这个问题，保持 Godot 编辑器的 dock 图标在 macOS 创建的默认位置。</p>
<ol start="6">
<li>在项目管理器和编辑器窗口的左上角出现“NO DC”之类的文本<br>这是由于 NVIDIA 显卡驱动程序注入了覆盖显示信息造成的。</li>
</ol>
<p>要在 Windows 上禁用此覆盖，请在 NVIDIA 控制面板中将图形驱动程序设置恢复为默认值。</p>
<p>要在 Linux 上禁用此覆盖，请打开 nvidia-settings，转到 X Screen 0 &gt; OpenGL Settings，然后取消选中 Enable Graphics API Visual Indicator。</p>
<ol start="7">
<li>在项目管理器和编辑器窗口右下角出现一个麦克风或刷新的图标<br>这是由于 NVIDIA 图形驱动程序注入覆盖以显示 ShadowPlay 录制的即时重播信息造成的。此覆盖只能在 Windows 上看到，因为 Linux 不支持 ShadowPlay。</li>
</ol>
<p>要禁用此覆盖，请按 Alt + Z（NVIDIA 覆盖的默认快捷方式）并在 NVIDIA 覆盖中禁用设置 &gt; HUD 布局 &gt; 状态指示器。</p>
<p>你也可以选择安装取代 GeForce Experience 的新的 NVIDIA 程序 <a target="_blank" rel="noopener" href="https://www.nvidia.com/en-us/software/nvidia-app/">https://www.nvidia.com/en-us/software/nvidia-app/</a>，这样就不会遇到这个问题。与 GeForce Experience 不同的是，NVIDIA 程序会在屏幕的角落而不是每个窗口的角落绘制回放指示器。</p>
<ol start="8">
<li>编辑器或项目显示得过于锐利或模糊<br>可能是由于你的图形驱动程序强制对所有 Vulkan 或 OpenGL 应用程序进行图像锐化。</li>
</ol>
<p>你可以在图形驱动程序的控制面板中禁用此行为：<br>NVIDIA（Windows）：打开开始菜单，选择 NVIDIA 控制面板。打开左侧的管理 3D 设置选项卡。在中间的列表中，滚动到图像锐化，并将其设置为关闭锐化。<br>AMD（Windows）：打开开始菜单，选择 AMD 软件。点击右上角的设置 “齿轮 “图标。转到图形选项卡，然后禁用 Radeon 图像锐化。<br>如果编辑器或者项目看起来过于模糊，这可能是由于 FXAA 被你的显卡驱动强制应用到所有的 Vulkan 或者 OpenGL 应用程序上。<br>NVIDIA（Windows）：打开开始菜单并选择 NVIDIA 控制面板。打开左侧的管理 3D 设置选项卡。在中间的列表中， 滚动到平滑设置 - FXAA 并将其设置为应用程序控制的。<br>NVIDIA（Linux）：打开应用程序菜单，选择 NVIDIA X 服务器设置。在左侧选择 Antialiasing Settings，取消对 Enable FXAA 的勾选。<br>AMD（Windows）：打开开始菜单并选择 AMD Software。点击设置右上角的“齿轮”图标。转到图形选项卡， 滚动到底部并点击高级以展开其设置。禁用形态抗锯齿。</p>
<p>像是 vkBasalt 这种第三方开发的供应的工具可能会强迫所有的 Vulkan 应用程序开启锐化或者 FXAA。你可能也需要检查他们的设置。</p>
<p>当你变更过了显卡驱动和第三方工具中的设置后，重启 Godot 去应用这些设置。<br>如果你仍然希望在其他应用程序上强制锐化或 FXAA，建议你使用显卡驱动控制面板提供的应用程序配置系统，针对每个应用程序的进行设置。</p>
<ol start="9">
<li>此编辑器或项目看起来颜色很淡<br>在 Windows 上，这通常是由不正确的操作系统或显示器设置引起的，因为 Godot 目前不支持 HDR 输出（即使它可能在内部以 HDR 渲染）。</li>
</ol>
<p>由于<code>大多数显示器并非被设计为在 HDR 模式下显示 SDR 内容 &lt;https://tftcentral.co.uk/articles/heres-why-you-should-only-enable-hdr-mode-on-your-pc-when-you-are-viewing-hdr-content&gt;</code>__，建议在未运行使用 HDR 输出的应用程序时在 Windows 设置中禁用 HDR。在 Windows 11 上，可以通过按 Windows + Alt + B 来完成该操作（该快捷方式是 Xbox Game Bar 应用程序的一部分）。要根据当前正在运行的应用程序自动切换 HDR，你可以使用 AutoActions。</p>
<p>如果你坚持启用 HDR，可以通过确保显示器配置为使用 HGIG 色调映射（而不是 DTM），然后<code>使用 Windows HDR 校准应用程序 &lt;https://support.microsoft.com/en-us/windows/calibrate-your-hdr-display-using-the-windows-hdr-calibration-app-f30f4809-3369-43e4-9b02-9eabebd23f19&gt;</code>__ 来稍微改善结果。强烈建议在使用 HDR 时使用 Windows 11 而不是 Windows 10。不过，最终结果可能仍不如在显示器上禁用 HDR。</p>
<p>计划在未来版本中支持 HDR 导出。</p>
<ol start="10">
<li>从挂起状态恢复 PC 后，编辑器&#x2F;项目冻结或显示出现故障<br>当在 Linux 上使用 NVIDIA 的专用图形驱动程序时便会出现这个已知的问题。<br>目前还没有明确的解决方案，因为当涉及 OpenGL 或 Vulkan 时，Linux + NVIDIA 上的挂起通常会出现问题。<br>与 Forward+ 和 Mobile 渲染方法（使用 Vulkan ）相比，兼容性渲染方法（采用 OpenGL ）通常不太容易出现挂起相关问题。</li>
</ol>
<p>NVIDIA驱动程序提供了一个实验性选项可在挂起后保护视频内存用以解决这个问题。<br>据报道，该选项与较新的 NVIDIA 驱动程序版本配合使用效果更好。</p>
<p>为了避免丢失工作内容，请在使电脑进入睡眠状态之前将场景保存在编辑器中。</p>
<ol start="11">
<li>项目在编辑器中正常运行，但在导出后无法加载部分文件<br>这通常是由于忘记在导出对话框中指定非资源文件过滤器而导致的。<br>默认情况下，Godot 只会将实际的资源包含到 PCK 文件中。一些常用的文件，例如 JSON 文件，不会被视为资源。<br>例如，如果你在导出的项目中加载 test.json，则需要在非资源导出过滤器中指定 *.json。有关更多信息，请参阅 资源选项。</li>
</ol>
<p>另外，请注意，导出的项目永远不会包含名字以点开头的文件和文件夹。这是为了防止将 .git 等版本控制文件夹包含在导出的 PCK 文件中。</p>
<p>在 Windows 上，也可能是大小写敏感性的问题。如果你在脚本里引用资源时所使用的大小写与文件系统中的不符，在导出项目后就会载入失败。这是因为虚拟 PCK 文件系统是大小写敏感的，而 Windows 的文件系统是大小写不敏感的。</p>
<ol start="12">
<li>项目在从项目管理器打开后频繁崩溃或立即崩溃<br>这可能是由多个因素引起的，比如编辑器插件、GDExtension 插件或其他原因。<br>建议以恢复模式打开项目，并尝试找到并修复导致崩溃的原因。<br>有关更多信息，请参见 Project Manager page。</li>
</ol>
<h2 id="编辑器简介"><a href="#编辑器简介" class="headerlink" title="编辑器简介"></a>编辑器简介</h2><h3 id="编辑器的界面"><a href="#编辑器的界面" class="headerlink" title="编辑器的界面"></a>编辑器的界面</h3><h4 id="项目管理器"><a href="#项目管理器" class="headerlink" title="项目管理器"></a>项目管理器</h4><p>使用项目管理器不需要什么教程，自己实际体验就可以更好掌握</p>
<ul>
<li>项目的使用<ul>
<li>创建、删除、导入或运行游戏项目</li>
</ul>
</li>
<li>下载演示和模板<ul>
<li>从资产库下载开源项目模板和演示程序</li>
</ul>
</li>
<li>用标签管理项目<ul>
<li>创建、删除、编辑标签</li>
</ul>
</li>
<li>恢复模式<ul>
<li>从项目列表中选择项目，点击编辑按钮旁边的下拉箭头，然后选择“在恢复模式下编辑”。</li>
</ul>
</li>
</ul>
<h4 id="Inspector-Dock"><a href="#Inspector-Dock" class="headerlink" title="Inspector Dock"></a>Inspector Dock</h4><p>检查器扩展坞<br><img src="https://wzcwzc10.github.io/posts_img/godot/inspector_overview.webp"><br>如果不可见，可以通过导航到 编辑器 &gt; 编辑器设置 &gt; 编辑器停靠 &gt; 检查器</p>
<h4 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h4><p>你可以通过更改数十种设置来控制项目的运行，包括物理、渲染和窗口设置。<br>这些设置可以通过<strong>项目设置</strong>窗口、代码或手动编辑 project.godot 文件来修改。<br>在内部，Godot 将项目的设置存储在一个 project.godot 文件中（INI 格式的纯文本文件）</p>
<p>可以在 ProjectSettings 类中查看完整的设置列表。<br>通过代码修改项目设置：<br>在代码中使用 set_setting() 来修改设置的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProjectSettings.set_setting(&quot;application/run/max_fps&quot;, 60)</span><br><span class="line">ProjectSettings.set_setting(&quot;display/window/size/mode&quot;, DisplayServer.WINDOW_MODE_WINDOWED)</span><br></pre></td></tr></table></figure>
<p>然而，许多项目设置都只会在游戏启动时读取一次。在此之后，使用 set_setting() 更改设置就不会产生效果了。不过大多数设置在 Engine、DisplayServer 等运行时类上都有相应的属性或方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Engine.max_fps = 60</span><br><span class="line">DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_WINDOWED)</span><br></pre></td></tr></table></figure>
<p>通常，项目设置会在运行时复制到以下类中：Engine、PhysicsServer2D、PhysicsServer3D、RenderingServer、Viewport、Window。在 ProjectSettings 类的参考文档中，设置会链接到其对应的运行时属性或方法。</p>
<p>使用 get_setting() 或 get_setting_with_override() 来读取项目设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var max_fps = ProjectSettings.get_setting(&quot;application/run/max_fps&quot;)</span><br><span class="line">var window_mode = ProjectSettings.get_setting(&quot;display/window/size/mode&quot;)</span><br></pre></td></tr></table></figure>
<p>由于许多项目设置仅在启动时读取一次，项目设置中的值可能不再准确。<br>在这种情况下，最好从运行时的等效属性或方法中读取值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var max_fps = Engine.max_fps</span><br><span class="line">var window_mode = DisplayServer.window_get_mode()</span><br></pre></td></tr></table></figure>

<h4 id="脚本编辑器"><a href="#脚本编辑器" class="headerlink" title="脚本编辑器"></a>脚本编辑器</h4><p>以下为文本编辑器的部分关键特性：<br>代码编辑器完整集成 GDScript。<br>支持 GDScript 和 JSON 文件的代码高亮。<br>GDScript 和 JSON 文件的语法检查。<br>支持书签和断点。<br>自动缩进。<br>代码折叠。<br>自定义主题。<br>多光标，可以通过按下 Alt + 单击左键 来启用。<br>自动补全变量、函数、常量等。<br>选中符号后使用 Ctrl + D 进行内联重构。<br>跨项目文件进行批量查找和替换。<br><strong>未研究</strong></p>
<h4 id="编辑器默认快捷键"><a href="#编辑器默认快捷键" class="headerlink" title="编辑器默认快捷键"></a>编辑器默认快捷键</h4><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh-cn/4.x/tutorials/editor/default_key_mapping.html">https://docs.godotengine.org/zh-cn/4.x/tutorials/editor/default_key_mapping.html</a></p>
<h4 id="自定义界面"><a href="#自定义界面" class="headerlink" title="自定义界面"></a>自定义界面</h4><p>编辑器布局会保存在一个在配置的路径 编辑器数据路径 中一个叫 editor_layouts.cfg 的文件中。<br><strong>未研究</strong></p>
<h3 id="XR-编辑器"><a href="#XR-编辑器" class="headerlink" title="XR 编辑器"></a>XR 编辑器</h3><p>专为 XR 设备原生运行而设计的 Godot 编辑器版本<br>目前 Godot XR 编辑器仅适用于运行 Meta Horizon OS v69 或更高版本的以下 Meta Quest 设备：<br>Meta Quest 3<br>Meta Quest 3s<br>Meta Quest Pro<br><strong>未研究</strong></p>
<h3 id="Android-编辑器"><a href="#Android-编辑器" class="headerlink" title="Android 编辑器"></a>Android 编辑器</h3><p><a target="_blank" rel="noopener" href="https://godotengine.org/download/android/">https://godotengine.org/download/android/</a><br><strong>未研究</strong></p>
<h3 id="Web-编辑器"><a href="#Web-编辑器" class="headerlink" title="Web 编辑器"></a>Web 编辑器</h3><p><a target="_blank" rel="noopener" href="https://editor.godotengine.org/releases/latest/">https://editor.godotengine.org/releases/latest/</a><br><strong>未研究</strong></p>
<h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><h4 id="命令行教程"><a href="#命令行教程" class="headerlink" title="命令行教程"></a>命令行教程</h4><p><strong>未研究</strong></p>
<h4 id="使用外部的文本编辑器"><a href="#使用外部的文本编辑器" class="headerlink" title="使用外部的文本编辑器"></a>使用外部的文本编辑器</h4><p><strong>未研究</strong></p>
<h3 id="管理编辑器功能"><a href="#管理编辑器功能" class="headerlink" title="管理编辑器功能"></a>管理编辑器功能</h3><p>想要限制 Godot 编辑器所能使用的功能。<br>“功能配置文件”可以实现这样的需求。<br>编辑器 &gt; 管理编辑器功能。<br>默认是没有配置的。请点击创建配置文档并为其命名。然后你就会看到 Godot 编辑器中所有功能的列表了。<br>要在编辑器之间分享配置，请点击导出按钮。请将自定义配置保存为 .profile 文件。<br>要在其他编辑器中使用，请打开其管理编辑器配置窗口并点击导入，然后选择该 .profile 文件。<br>如果大量电脑都需要自定义配置，这个过程可能会比较繁琐。<br>另一种办法是启用 Godot 的自包含模式，可以将所有编辑器配置放在与编辑器二进制文件同一文件夹中。</p>
<h2 id="2D"><a href="#2D" class="headerlink" title="2D"></a>2D</h2><h3 id="2D-简介"><a href="#2D-简介" class="headerlink" title="2D 简介"></a>2D 简介</h3><p>CanvasItem 是 2D 的基础节点。<br>Node2D 是 2D 游戏对象的基础节点。<br>Control 是所有 GUI 的基础节点。<br>可以在 2D 屏幕上显示 3D 场景。</p>
<h3 id="画布层"><a href="#画布层" class="headerlink" title="画布层"></a>画布层</h3><p>画布项 CanvasItem 是所有 2D 节点的基类，无论是 Node2D 等普通 2D 节点，还是 Control 控件节点。<br>你可以把画布项组织成树。每个项目都会继承父节点的变换：父节点移动，子项也会移动。</p>
<p>CanvasItem 节点及其派生节点通过视口节点 Viewport 来显示，是这个视口的直接或间接子节点。</p>
<p>Viewport 的 Viewport.canvas_transform 属性能够对它所包含的 CanvasItem 层级结构施加一个自定义的 Transform2D 变换。<br>Camera2D 等节点的工作原理就是修改这个变换。</p>
<p>像滚动这样的效果最好是通过操纵画布的变换（transform）属性来实现。这种方法比移动根画布项和整个场景更有效。</p>
<p>通常情况下，我们并不希望游戏或应用程序中的所有东西都受到画布变换的约束。比如：</p>
<ol>
<li>视差背景：比场景其他部分移动得慢的背景。</li>
<li>UI：用户界面（UI）或平视显示系统（HUD）叠加在我们游戏世界的视图上。我们希望生命计数器、分数显示和其他元素能够保持其屏幕位置，即使我们在游戏世界的视角发生变化。</li>
<li>转场：我们应该希望用于转场的效果（淡入淡出、混合）也保持在固定的位置。</li>
</ol>
<p>CanvasLayer<br>画布层 CanvasLayer，它是一个节点，可以为所有子代和孙代添加一个单独的 2D 渲染层。Viewport 的子节点默认在图层“0”处绘制，而 CanvasLayer 将在任何数字层处绘制。数字较大的图层将绘制在数字较小的图层之上。CanvasLayer 也有自己的变换，不受其他层的影响。这使得当我们对游戏世界的观察发生变化时，UI 可以固定在屏幕空间中。</p>
<p>一个例子是创建视差背景（Parallax Background）。这可以通过层为“-1”的 CanvasLayer 完成。带有分数、生命计数器和暂停按钮的屏幕也可以创建在编号为“1”的层中。</p>
<p>CanvasLayer 独立于树顺序，它们仅依赖于它们的层数，因此可以只在需要时让它们实例化。</p>
<p>控制节点的绘制顺序并不一定要用 CanvasLayer。确保节点被正确绘制在“前面”或“后面”的标准方法是调整场景面板中节点的顺序。也许违反直觉，但在视口中，场景面板中较上面的节点会被画在较下面的节点的后面。2D 节点的 CanvasItem.z_index 属性也能够控制绘图顺序。</p>
<h3 id="视口变换与画布变换"><a href="#视口变换与画布变换" class="headerlink" title="视口变换与画布变换"></a>视口变换与画布变换</h3><p>如何为提供给 Input 的输入事件在正确的坐标系中确定位置</p>
<h4 id="画布变换"><a href="#画布变换" class="headerlink" title="画布变换"></a>画布变换</h4><p>正如前面教程 画布层 中提到的那样，每个 CanvasItem 节点（要记得 Node2D 和基于 Control 的节点都使用 CanvasItem 作为它们的公共根）将驻留在 Canvas Layer 中。每个 Canvas Layer 都有一个变换（平移、旋转、缩放等），可以作为 Transform2D 进行访问。</p>
<p>在前面的教程中也有介绍，节点默认是在 0 层上绘制，即内置的画布。如果要把节点放在不同的层中，可以使用 CanvasLayer 节点。</p>
<p>Viewport 还具有全局画布变换（也是一个 Transform2D）。这是一个能够影响所有画布层的主变换。一般而言，主要用于 Godot 的 CanvasItem 编辑器</p>
<h4 id="拉伸变换"><a href="#拉伸变换" class="headerlink" title="拉伸变换"></a>拉伸变换</h4><p>最后，Viewport 有拉伸变换，用于调整大小或拉伸屏幕。此变换在内部使用（见 多分辨率），但也可以在每个 Viewport 上手动设置。</p>
<p>输入事件会与这个变换相乘，但还缺少前面说的那些。为了方便将 InputEvent 的坐标转换到 CanvasItem 局部坐标，添加了 CanvasItem.make_input_local() 函数。</p>
<h4 id="窗口变换"><a href="#窗口变换" class="headerlink" title="窗口变换"></a>窗口变换</h4><p>根视口是一个 Window。为了能够像 多分辨率 中一样将窗口的内容进行缩放和移动，每个 Window 都包含了窗口变换。例如在 Viewport 使用固定长宽比显示时，负责窗口边缘的黑框。</p>
<h4 id="变换顺序"><a href="#变换顺序" class="headerlink" title="变换顺序"></a>变换顺序</h4><p>要将 CanvasItem 本地坐标转换为实际屏幕坐标，必须应用以下变换链：<br><img src="https://wzcwzc10.github.io/posts_img/godot/viewport_transforms3.webp"></p>
<h4 id="变换函数"><a href="#变换函数" class="headerlink" title="变换函数"></a>变换函数</h4><p>上图显示了一些可用的变换函数。所有变换都是从右向左的，这意味着将一个变换与一个坐标相乘会得到一个更靠左的坐标系，将一个变换的 affine inverse 相乘会得到一个更靠右的坐标系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Called from a CanvasItem.</span><br><span class="line">canvas_pos = get_global_transform() * local_pos</span><br><span class="line">local_pos = get_global_transform().affine_inverse() * canvas_pos</span><br></pre></td></tr></table></figure>
<p>那么最后，要将CanvasItem的本地坐标转换为屏幕坐标，只需按以下顺序相乘:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var screen_coord = get_viewport().get_screen_transform() * get_global_transform_with_canvas() * local_pos</span><br></pre></td></tr></table></figure>
<p>但请记住，通常情况最好不要使用屏幕坐标. 推荐的方法是，仅仅使用画布坐标( CanvasItem.get_global_transform() )，以保证自动分辨率调整能正常工作.</p>
<h4 id="提供自定义输入事件"><a href="#提供自定义输入事件" class="headerlink" title="提供自定义输入事件"></a>提供自定义输入事件</h4><p>通常需要将自定义输入事件提供给场景树。要正确地做到这一点，必须通过以下方式完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var local_pos = Vector2(10, 20) # Local to Control/Node2D.</span><br><span class="line">var ie = InputEventMouseButton.new()</span><br><span class="line">ie.button_index = MOUSE_BUTTON_LEFT</span><br><span class="line">ie.position = get_viewport().get_screen_transform() * get_global_transform_with_canvas() * local_pos</span><br><span class="line">Input.parse_input_event(ie)</span><br></pre></td></tr></table></figure>

<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><h4 id="2D-灯光和阴影"><a href="#2D-灯光和阴影" class="headerlink" title="2D 灯光和阴影"></a>2D 灯光和阴影</h4><p>Godot 提供了可以使用实时 2D 照明和阴影的功能，可以大大增强项目的层次感<br>完整的 2D 光照设置涉及多个节点：</p>
<ul>
<li>CanvasModulate（用于使场景变暗）<ul>
<li>CanvasModulate 用于指定一种颜色作为“环境”基色，使场景变暗。这是任何 2D 灯光都无法到达区域的最终照明颜色。如果没有 CanvasModulate 节点，由于 2D 灯光只会照亮现有的无阴影外观（看起来完全亮了），最终场景看起来会过于明亮。</li>
</ul>
</li>
<li>PointLight2D（用于全向或点光源）<ul>
<li>PointLight2D 用于点亮场景。灯光的常见工作方式是在场景的其余部分添加选定的纹理来模拟光照。</li>
<li>阴影只会出现在 PointLight2D 覆盖的区域上，方向基于 Light 的中心。</li>
</ul>
</li>
<li>DirectionalLight2D（用于日光或月光）</li>
<li>LightOccluder2D（用于投射灯光阴影）<ul>
<li>用于告诉着色器场景的哪些部分会投射阴影。这些遮挡物可以作为独立节点放置，也可以作为 TileMapLayer 节点的一部分。</li>
</ul>
</li>
<li>其他可接收光照的 2D 节点，例如 Sprite2D 和 TileMapLayer。<ul>
<li>Sprite2D 用于显示灯泡、背景和阴影投射器的纹理。</li>
</ul>
</li>
</ul>
<blockquote>
<p>背景色不接受任何光照。如果要在背景上投射灯光，则需要为背景添加可视化表示，例如 Sprite2D。<br>Sprite2D 的 Region 属性有助于快速创建重复的背景纹理，但要记得在 Sprite2D 属性中将 Texture &gt; Repeat 设置为 Enabled。</p>
</blockquote>
<p>点光源<br>点光源（也称位置光源）是 2D 照明中最常见的元素。可用于表示火把、火、射弹等发出的光。</p>
<p>PointLight2D 提供了以下属性，可在检查器中进行调整：</p>
<ul>
<li>纹理： 用作光源的纹理。纹理的大小决定光源的大小。纹理可以有一个 alpha 通道，这在使用 Light2D 的 Mix 混合模式时非常有用，但在使用 Add （默认）或 Subtract 混合模式时则不需要。</li>
<li>偏移量： 灯光纹理的偏移量。与移动灯光节点不同，改变偏移量 不会 导致阴影移动。</li>
<li>纹理缩放： 灯光大小的乘法器。数值越大，灯光越亮。较大的灯光会影响屏幕上更多的像素，因此在增大灯光尺寸前要考虑到这一点。</li>
<li>高度： 灯光在法线贴图中的虚拟高度。默认情况下，灯光与接收灯光的表面非常接近。如果使用法线贴图，这将使灯光几乎不可见，因此可以考虑增加此值。只有在使用法线贴图的表面上，调整灯光的高度才会产生明显的不同。</li>
</ul>
<p>如果没有预制纹理可用于灯光，可以使用这种 “中性 ”点光源纹理（右键单击 &gt; 图像另存为… ）：<br><img src="https://wzcwzc10.github.io/posts_img/godot/2d_lights_and_shadows_neutral_point_light.webp"><br>如果你需要不同的渐变，可以通过在灯光的 纹理 属性上分配 新建 GradientTexture2D 来程序化地创建纹理。创建资源后，展开其 Fill 部分并将填充模式设置为 Radial 。然后，你需要调整渐变本身，使其从不透明的白色开始到透明的白色，并将其起始位置移动到中心。</p>
<p>平行光<br>Godot 4.0 的新功能是在 2D 中实现定向照明。定向照明用于表现阳光或月光。光线相互平行投射，就好像太阳或月亮离受光表面无限远一样。<br>DirectionalLight2D 提供以下的属性：</p>
<ul>
<li>高度： 灯光在法线贴图中的虚拟高度（ 0.0 &#x3D; 平行于曲面，1.0 &#x3D; 垂直于曲面）。默认情况下，灯光与接收灯光的表面完全平行。如果使用法线贴图，这将使灯光几乎不可见，因此可以考虑增大此值。调整灯光的高度只会对使用法线贴图的表面产生视觉差异。 高度 不会影响阴影的外观。</li>
<li>最大距离： 物体距离摄像机中心的最大距离（单位：像素）。减小该值可以防止对位于摄像机外的物体投射阴影（同时还能提高性能）。 最大距离 不考虑 Camera2D 的缩放，这意味着在较高的缩放值下，当缩放至给定点时，阴影会更快消失。</li>
</ul>
<p>常用灯光属性<br>PointLight2D 和 DirectionalLight2D 都提供共同的属性，这些属性是 Light2D 基类的一部分：</p>
<ul>
<li>启用： 允许切换灯光的可见性。与隐藏灯光节点不同，禁用此属性不会隐藏灯光的子节点。</li>
<li>仅编辑器：如果启用，灯光仅在编辑器中可见。在运行的项目中将自动禁用。</li>
<li>颜色： 灯光的颜色。</li>
<li>能量： 灯光强度乘数。数值越大，光线越亮。</li>
<li>混合模式： 用于光线计算的混合公式。默认的 添加（Add） 适合大多数使用情况。 减（Subtract） 可用于负光，负光在物理上并不精确，但可用于特殊效果。 混合（Mix） 模式通过线性插值将灯光纹理对应的像素值与灯光下方的像素值混合。</li>
<li>范围 &gt; Z 下限： 受光线影响的最小 Z 值。</li>
<li>范围 &gt; Z 上限： 受光线影响的最大 Z 值。</li>
<li>范围 &gt; 层下限： 受光线影响的最小层数值。</li>
<li>范围 &gt; 层上限： 受光线影响的最大层数值。</li>
<li>范围 &gt; 对象遮罩： 根据其他节点的可视层选项<strong>Occluder Light Mask</strong>（遮挡掩膜），控制那些节点接收到来自这个节点的光线。通过这种方式可以让某些物体不被光线照射。</li>
</ul>
<p>设置阴影<br>启用一个 PointLight2D 或者 DirectionalLight2D 节点的 Shadow &gt; Enabled 属性之后，你将看不到任何变化。这是因为在你的场景中还没有任何节点拥有投射阴影需要使用的 遮挡器 。</p>
<p>要在场景中显示阴影，必须在场景中添加 LightOccluder2D 节点。这些节点还必须具有与精灵轮廓相匹配的遮光多边形。</p>
<p>除了多边形资源（必须设置多边形资源才能产生视觉效果）之外，LightOccluder2D 节点还有两个属性：</p>
<p>SDF碰撞：如果启用，则遮挡器将成为可在自定义着色器中使用的实时生成的 签名距离字段 （signed distance field）的一部分。当不使用从此 SDF 中读取的自定义着色器时，启用这个功能不会带来视觉上的差异，并且没有性能成本，因此默认情况下为方便起见它是启用的。</p>
<p>遮挡器光照蒙版： 这与 PointLight2D 和 DirectionalLight2D 的 ** Shadow &gt; Item Cull Mask ** 属性一起使用，以控制哪些对象为每个光源投射阴影。 这可用于防止特定对象投射阴影。</p>
<p>有两种方法可以来创建光线遮挡器：</p>
<p>自动生成光遮蔽器<br>遮挡器可以自动地 Sprite2D 节点上创建，需要选中节点，单击2D编辑器顶部的 Sprite2D 菜单，然后选择创建 LightOccluder2D 同级节点从而自动进行。</p>
<p>在出现的对话框中，轮廓将围绕你的精灵的边缘。如果轮廓与精灵的边缘非常吻合，你可以点击确定。如果轮廓距离精灵的边缘太远（或“啃”了精灵的边缘），请调整扩展（像素）和收缩（像素），然后点击更新预览。重复该操作，直到获得满意的结果。</p>
<p>手动绘制光遮蔽器<br>创建一个 LightOccluder2D 节点，然后选择该节点并单击 2D 编辑器顶部的“+”按钮。 当要求创建多边形资源时，回答 是 。 然后，你可以通过单击创建新点来开始绘制遮挡多边形。你可以通过右键单击现有点来删除它们，也可以通过单击线条然后拖动来从现有线条创建新点。</p>
<p>启用阴影的 2D 灯光能够调整以下属性：</p>
<p>Color：阴影区域的颜色。默认情况下，阴影区域是全黑的，但这可以出于艺术目的而改变。颜色的 alpha 通道控制的是阴影被指定颜色着色的程度。</p>
<p>Filter：阴影所使用的过滤模式。默认值为 None，渲染速度最快，并且非常适合像素艺术风格的游戏（因为它具有“方块”视觉效果）。如果你想要柔和的阴影，请使用 PCF5。PCF13 则更柔和，但渲染需求更高。由于渲染成本较高，PCF13 只应用于少量光源同时存在的情况下。</p>
<p>Filter Smooth：过滤平滑。控制的是当 Filter 为 PCF5 或 PCF13 时，应用于阴影的柔化程度。较高的值会导致阴影更加柔和，但可能会出现带状伪影（特别是使用 PCF5 时）。</p>
<p>Item Cull Mask：项目剔除遮罩。控制的是哪些 LightOccluder2D 节点能够投射阴影，取决于对应的 Occluder Light Mask（遮挡器灯光遮罩）属性。</p>
<p>法线和镜面贴图<br>法线贴图和镜面贴图可以大大提升 2D 光照的立体感。与 3D 渲染类似，法线贴图可以根据接收光线的表面方向来改变光线的强度，从而使照明效果不再平面化（按像素进行调整）。镜面贴图通过让一部分光线反射回观察者来进一步改善视觉效果。</p>
<p>PointLight2D 和 DirectionalLight2D 都支持法线贴图和镜面贴图。自 Godot 4.0 起，法线贴图和镜面贴图可分配给任何 2D 元素，包括继承自 Node2D 或 Control 的节点。</p>
<p>法线贴图表示每个像素“指向”的方向。引擎会利用这些信息，以物理上合理的方式将光照正确应用到 2D 表面。法线贴图通常由手绘的高度贴图创建，但也可以由其他纹理自动生成。</p>
<p>镜面贴图定义了每个像素对光线的反射程度（如果镜面贴图包含颜色，则定义反射的颜色）。亮度值越高，纹理上指定位置的反射就越亮。镜面贴图通常以漫反射纹理为基础，通过手动编辑创建。</p>
<blockquote>
<p>如果在你的精灵中没有使用法线贴图或者镜面贴图，可以使用免费的开源工具 Laigter 来生成。<br>要在 2D 节点上设置法线贴图和&#x2F;或镜面贴图，请为绘制节点纹理的属性创建一个新的 CanvasTexture 资源。例如，在一个 Sprite2D 节点上创建一个新的 CanvasTexture 资源：</p>
</blockquote>
<p>展开新创建的资源。你可以找到需要调整的几个属性：<br>Diffuse &gt; Texture：（漫反射 &gt; 纹理）基础的颜色贴图。在这个属性中，加载你将使用在精灵本身的纹理。<br>Normal Map &gt; Texture：（法线贴图 &gt; 纹理）法线贴图的纹理。在这个属性中，你可以加载从高度图生成的法线贴图纹理（见上面的提示）。<br>Specular &gt; Texture：（镜面反射 &gt; 纹理）镜面贴图纹理，可以控制漫反射纹理上每个像素的镜面反射强度。镜面贴图通常使用灰度反射，但是它也可以包含色彩来增强反射的颜色。在这个属性中，加载一个已创建的镜面贴图纹理（见上面的提示）。<br>Specular &gt; Color：（镜面反射 &gt; 颜色）镜面反射的颜色乘数。<br>Specular &gt; Shininess：（镜面反射 &gt; 光泽度）用于镜面反射的高光指数。值越低，反射的明亮度和扩散性会增加，而值越高，反射会更加局部化。较高的值适用于湿润表面。<br>Texture &gt; Filter：（纹理 &gt; 过滤器）可以设置为覆盖纹理过滤模式，无论节点属性设置如何（或渲染 &gt; 纹理 &gt; 画布纹理 &gt; 默认纹理过滤项目设置）。<br>Texture &gt; Repeat：（纹理 &gt; 重复）可以设置为覆盖纹理过滤模式，无论节点的属性如何设置（或者渲染 &gt; 纹理 &gt; 画布纹理 &gt; 默认纹理重复项目设置）。<br>启用法线贴图后，你可能会注意到灯光会显得较弱。为了解决这个问题，可以增加 PointLight2D 和 DirectionalLight2D 节点上的 Height 属性。也可以略微增加灯光的 Energy 属性，以接近启用法线贴图之前的照明强度。</p>
<p>使用添加式精灵作为 2D 灯光的快速替代品<br>如果在使用 2D 灯光时遇到性能问题，不妨将其中一些节点替换为使用叠加混合的 Sprite2D 节点。这尤其适用于短暂的动态效果，如子弹或爆炸。<br>添加式精灵的渲染速度要快得多，因为它们不需要通过单独的渲染管道。此外，这种方法还可以与 AnimatedSprite2D（或 Sprite2D + AnimationPlayer）一起使用，这样就可以创建动画二维 “灯光”。<br>不过，与 2D 灯光相比，添加式精灵有一些缺点：<br>与 “实际 ”二维光照相比，混合公式并不准确。这在光线充足的区域通常不是问题，但这会妨碍添加精灵去正确照亮那些完全黑暗的区域。<br>添加式精灵不能投射阴影，因为它们不是灯光。<br>添加式精灵会忽略其他精灵上使用的法线贴图和镜面贴图。<br>要显示一个具有加法混合的精灵，请创建一个 Sprite2D 节点并为其分配一个纹理。在检查器中，向下滚动到 CanvasItem &gt; Material 部分，展开它并点击 Material 属性旁边的下拉菜单。选择 New CanvasItemMaterial，点击新创建的材质进行编辑，然后将 Blend Mode 设置为 Add。</p>
<h4 id="2D-网格"><a href="#2D-网格" class="headerlink" title="2D 网格"></a>2D 网格</h4><p>在 3D 中，网格用于显示世界。在 2D 中它们不常见，因为图片使用得更频繁。<br>Godot 的 2D 部分是一个纯 2D 引擎，因此它不能直接显示 3D 网格（尽管它可以通过 Viewport 和 ViewportTexture 来实现）。</p>
<blockquote>
<p>如果你对在二维视口上显示三维网格感兴趣，请参见 使用 SubViewport 作为纹理 教程。</p>
</blockquote>
<p>2D 网格可以尝试使用代码中的 SurfaceTool 创建它们，并在 MeshInstance2D 节点中显示它们。<br>目前，在编辑器中生成 2D 网格的唯一方法是导入 OBJ 文件作为网格，或者从 Sprite2D 转换而来。</p>
<p>优化绘制的像素<br>该工作流程在某些情况下可用于优化 2D 绘制。绘制具有透明度的大型图像时，Godot 会将整个四边形绘制到屏幕上。大型透明区域仍将被绘制。<br>如果绘制非常大的图像时（大概屏幕大小），或者将多个有大透明区域的图像叠加在一起（例如使用 ParallaxBackground 时），这会影响性能，尤其是在移动设备上。<br>转换成网格能确保只绘制不透明部分，其余部分被忽略。</p>
<p>将 Sprite2D 转换为 2D 网格<br>你可以通过把 Sprite2D 转换为 MeshInstance2D 的方法来利用这种优化。<br>从边缘有大量透明的图片开始，把它放到一个 Sprite2D 中，从菜单选择“转换为 2D 网格”<br>默认值对于许多情况来说已经足够好了，但你可以根据需要更改扩展和简化<br>最后，按下 转换 2D 网格 按钮，你的 Sprite2D 将被替换</p>
<h4 id="2D-精灵动画"><a href="#2D-精灵动画" class="headerlink" title="2D 精灵动画"></a>2D 精灵动画</h4><p>使用 AnimatedSprite2D 类和 AnimationPlayer 创建 2D 动画角色</p>
<ul>
<li>首先，我们将使用 AnimatedSprite2D 对单个图像集合进行动画处理。 </li>
<li>然后我们将使用此类对精灵表进行动画处理。 </li>
<li>最后，我们将学习另一种使用 AnimationPlayer 和 Sprite2D 的 Animation 属性来制作精灵表动画的方法。<br><img src="https://wzcwzc10.github.io/posts_img/godot/2d_animation_tree1.webp"></li>
</ul>
<p>控制动画<br>AnimateSprite2D 与精灵表<br>AnimationPlayer 与精灵表<br>根节点也可以是 Area2D 或 RigidBody2D。动画仍然会以同样的方式制作。<br>一旦动画完成，你就可以为 CollisionShape2D 形状分配一个形状。</p>
<p>可在 Godot 中用于 2D 动画的两个类。AnimationPlayer 比 AnimatedSprite2D 稍微复杂一些，但它提供了额外的功能，因为你还可以为其他属性（如位置或比例）设置动画。 类 AnimationPlayer 也可以与 AnimatedSprite2D 一起使用。 尝试看看什么最适合你的需求。</p>
<blockquote>
<p>如果同时更新一个动画和一个其他的属性（比如说，平台跳跃游戏可能会更新精灵的 h_flip&#x2F;v_flip 属性然后同时开始一个转身动画“turning”），要记住 play() 不是即时生效的。它会在下次 AnimationPlayer 被处理时生效。也就是说可能要到下一帧才行，导致现在这一帧变成“问题”帧——应用了属性的变化，但动画还没有开始。如果这会造成麻烦的话，在调用 play() 后，你可以调用 advance(0) :ref:<code>AnimationPlayer &lt;class_AnimationPlayer&gt;</code>来立即开始播放动画。</p>
</blockquote>
<h4 id="2D-粒子系统"><a href="#2D-粒子系统" class="headerlink" title="2D 粒子系统"></a>2D 粒子系统</h4><p>粒子系统用于模拟复杂的物理效果，例如火花、火焰、魔法粒子、烟雾、薄雾等。<br>这个想法是以固定的间隔发射具有固定的寿命的 “粒子”。 在其生命周期中，每个粒子都具有相同的基本行为。 让每个粒子变得不同并提供整体更加 “有机” 外观的是与各个参数相关的 “随机性”。 实质上，创建粒子系统意味着设置基本物理参数，然后为它们添加随机性。</p>
<p>Godot 为 2D 粒子提供了两个不同的节点： GPUParticles2D 和 CPUParticles2D。<br>GPUParticles2D 更先进，使用 GPU 来处子理粒效果。<br>CPUParticles2D 是 CPU 驱动的选项，其功能与 GPUParticles2D 几乎相同，但在使用大量粒子时性能较低。在低端系统或 GPU 瓶颈情况下可能表现更好。</p>
<p>虽然 GPUParticles2D 是通过 ParticleProcessMaterial（还可以使用自定义着色器）进行配置的，不过匹配的选项是通过 CPUParticles2D 中的节点属性提供的（除了轨迹设置）。</p>
<p>可以通过在检查其中点击节点，选择 2D 视口，然后在视口顶部的工具栏中选择 GPUParticles2D &gt; 转换为CPUParticles2D ，将 GPUParticles2D 节点转换为 CPUParticles2D 节点。也可以将 GPUParticles2D 节点转换为 CPUParticles2D 节点，但如果你使用了仅 GPU 支持的功能，可能会出现一些问题。</p>
<p>今后没有计划向 CPUParticles2D 添加新功能，但将接受添加 GPUParticles2D 中已有功能的拉取请求。因此，我们建议使用 GPUParticles2D，除非你有明确的理由不这样做。</p>
<p>使用步骤：<br>首先，将 GPUParticles2D 节点添加到场景中。 创建该节点后需要 ParticleProcessMaterial 才能发挥作用。<br>要将处理材质添加到粒子节点，请转到检查器面板中的 Process Material。单击 Material 旁边的框，然后从下拉菜单中选择 新建 ParticleProcessMaterial。你的 GPUParticles2D 节点现在应该可以向下发射白点了。</p>
<p>粒子系统可以使用单个纹理或动画 翻页 （filpbook）。<br>翻页是一种纹理，其中包含可以回放或在发射期间随机选择的多个动画帧。翻页相当于粒子的精灵表。<br>粒子翻页适合再现复杂的效果，如烟雾、火焰、爆炸。可以通过使每个粒子使用不同的纹理（纹理通过 Texture 属性设置），来引入随机纹理变化。<br>可以在线寻找现成的粒子翻页图，或使用外部工具预渲染它们，例如 Blender 或 EmberGen 。<br>相比起单个纹理，使用动画翻页需要额外的配置，必须在 GPUParticles2D（或 CPUParticles2D）节点的 Material 部分中创建一个新的 CanvasItemMaterial，启用 Particle Animation ，并将 H Frames 和 V Frames 分别设置为翻页纹理中的列数和行数：完成此操作后，ParticleProcessMaterial（对于 GPUParticles2D）或 CPUParticles2D 检查器中的 动画部分 将生效。</p>
<blockquote>
<p>如果你的翻页纹理是黑色背景而不是透明背景，你还需要将混合模式设置为 Add 而不是 Mix 才能使它正确地显示。或者，你也可以修改纹理以使它在图像编辑器中有透明背景。在 GIMP 中，可以使用 Color &gt; Color to Alpha 菜单来完成此操作。</p>
</blockquote>
<p>时间参数</p>
<ol>
<li>生命期（Lifetime）<br>每个粒子存活的时间，单位为秒。当生命期结束时，将创建一个新粒子来替换它。</li>
<li>单次（One Shot）<br>启用后，GPUParticles2D 节点将一次发射其所有粒子，之后将不再发射。</li>
<li>预处理（Preprocess）<br>粒子系统从没有粒子被发射开始，然后开始发射。 当加载场景如火炬，雾等系统时可能会带来不便，因为它会在进入场景的那一刻开始发射。 预处理用于让系统在第一次实际绘制之前处理给定的秒数。</li>
<li>速度缩放（Speed Scale）<br>速度比例具有默认值 1 ，用于调整粒子系统的速度。 降低值会使粒子变慢，而增加值会使粒子更快。</li>
<li>爆炸性（Explosiveness）<br>如果有10个寿命为 1 的粒子，则意味着粒子将每0.1秒发射一次. 爆炸性参数改变了这一点，并迫使粒子一起发射. 范围是:<br>0: 定期发射粒子(默认值)。<br>1: 同时发射所有粒子。<br>中间的值也是允许的。 </li>
<li>随机性（Randomness）<br>所有物理参数都可以随机化。 随机值范围从 0 到 1。 随机化参数的公式为:<br>initial_value &#x3D; param_value + param_value * randomness</li>
<li>固定 FPS（Fixed FPS）<br>此设置可用于将粒子系统设置为以固定的帧率渲染。 例如，将值更改为 2 将使粒子以每秒2帧的速度渲染。 请注意，这不会减慢粒子系统本身的速度。<blockquote>
<p>Godot 4.3 目前不支持 2D 粒子的物理插值。作为临时解决方案，你可以在检查器底部将粒子节点的 Node &gt; Physics Interpolation &gt; Mode 设置为禁用，以关闭物理插值功能。</p>
</blockquote>
</li>
<li>Fract Delta<br>将 Fract Delta 设置为 true 会启用分数增量计算，这会使粒子显示效果更加平滑。这种平滑性的提升源于更高的计算精度。在具有高度随机性或快速移动粒子的系统中，这种差异会更加明显。它有助于保持粒子系统的视觉一致性，确保每个粒子的运动与其实际生命周期保持一致。如果不启用此选项，当粒子在帧内的某个时间点发射时，可能会出现粒子跳跃或移动超出应有范围的现象。更高的精度会带来性能上的折衷，特别是在粒子数量较多的系统中。</li>
</ol>
<p>绘图参数</p>
<ol>
<li>可见矩形（Visibility Rect）<br>可见性矩形控制粒子在屏幕上的可见性。 如果此矩形位于视口之外，则引擎将不会在屏幕上渲染粒子。<br>矩形的 W 和 H 属性分别控制其宽度和高度。X 和 Y 属性控制矩形左上角相对于粒子发射器的位置。<br>可以使用 2d 视图上方的工具栏让 Godot 自动生成可见性矩形。 为此，请选择 GPUParticles2D 节点并单击 粒子 &gt; 生成可见性矩形。 Godot 将模拟 Particles2D 节点发射粒子几秒钟，并设置矩形以适合粒子所占据的表面。<br>可以使用 Generation Time (sec) 选项控制发射持续时间。 最大值为25秒。 如果你需要更多时间让粒子移动，你可以暂时更改Particles2D节点上的 preprocess 时间。</li>
<li>局部坐标（Local Coords）<br>默认情况下，此选项处于启用状态，这意味着粒子发射的空间是相对于节点来算的。 如果移动节点，则所有粒子会随之移动:<br>如果禁用，粒子将发射到全局空间，这意味着如果移动节点，则已发射的粒子不会受到影响:</li>
<li>绘制顺序（Draw Order）<br>这可以控制绘制单个粒子的顺序。Index 表示粒子根据它们的发射顺序被绘制(默认)。Lifetime 表示它们按照剩余寿命的顺序被绘制。</li>
<li>粒子处理材质设置</li>
</ol>
<h4 id="ParticleProcessMaterial-2D-用法"><a href="#ParticleProcessMaterial-2D-用法" class="headerlink" title="ParticleProcessMaterial 2D 用法"></a>ParticleProcessMaterial 2D 用法</h4><p>处理材质属性<br>在这个材质中的属性控制粒子在其生命周期中的行为和变化。<br>它们中的许多拥 Min 、 Max 和 Curve 值，允许对其行为进行微调。<br>值之间的关系是：当一个粒子被生成时，属性会被设置为 Min 和 Max 之间的一个随机值。<br>如果 Min 和 Max 是相同的，那么每个粒子的值将始终是相同的。<br>如果也设置了 Curve ，属性的值将会乘以粒子生命周期当前点上曲线的值。<br>使用曲线来改变粒子生命周期中的属性。这种方式可以表达非常复杂的行为。</p>
<p>随机性 (Randomness) 的生命周期<br>Lifetime Randomness 属性控制应用于每个粒子生命周期的随机性程度。<br>值为 0 表示完全没有随机性，由 Lifetime 属性设置的所有粒子的存活时间相同。<br>值为 1 表示粒子的生命周期在 [0.0, Lifetime] 范围内完全随机。</p>
<p>粒子标志</p>
<ul>
<li>生成</li>
</ul>
<ol>
<li>角度（Angle）<br>确定粒子的初始角度(以度为单位)。 该参数通常在随机化后会有用。</li>
<li>速度（Velocity）<br>方向<br>这是粒子发射的基础方向。 默认值是 Vector3(1,0,0) ，它使粒子向右发射。 然而，在默认的重力设置下，粒子会直线下降。<br>为了让这个属性作用更明显，你需要一个大于 0 的初始速度(initial velocity)。 这里，我们把初始速度设为 40。 你会注意到粒子向右发射，然后受重力作用下降。</li>
<li>发散（Spread）<br>此参数是以度为单位的角度，它会被随机加减到基础 Direction 上。180 的铺开角度将向所有方向发射(+&#x2F;- 180)。</li>
<li>扁平度（Flatness）<br>这个属性只对3D粒子有用。</li>
<li>初速度（Initial Velocity）<br>初始速度是粒子发射的速度（单位为像素&#x2F;秒）。以后可以通过重力或其他加速度来修改速度（后述）。</li>
</ol>
<ul>
<li>动画速度</li>
</ul>
<ol>
<li>角速度（Angular Velocity）<br>角速度是粒子围绕其中心转动的速度(以度&#x2F;秒为单位)。</li>
<li>环绕速度（Orbit Velocity）<br>环绕速度速度用于使粒子绕它们的中心转动。</li>
</ol>
<ul>
<li>加速度</li>
</ul>
<ol>
<li>重力（Gravity）<br>应用于每个粒子上的重力。</li>
<li>线性加速度（Linear Acceleration）<br>应用于每个粒子的线性加速度。</li>
<li>径向加速度（Radial Acceleration）<br>如果此加速度为正，则粒子会向远离发射中心加速。 如果是负的，他们会被加速吸进去。</li>
<li>切向加速度（Tangential Acceleration）<br>该加速度会使用从粒子到中心点的切向量，结合径向加速度可以做出很酷炫的效果。</li>
<li>阻尼（Damping）<br>阻尼选项会对颗粒施加摩擦力，迫使它们停止。 它特别适用于火花或爆炸，火花或爆炸通常以高线速度开始，然后在他们隐去时停下来。</li>
</ol>
<ul>
<li>显示</li>
</ul>
<ol>
<li>缩放（Scale）<br>确定粒子的初始大小。</li>
</ol>
<ul>
<li>颜色曲线</li>
</ul>
<ol>
<li>Color (颜色)<br>用于改变发射出来的粒子颜色。</li>
<li>Hue Variation（色相变化）<br>Variation 值设置的是应用于每个粒子的初始色调变化。Variation Rand 值控制色调变化的随机性比率。</li>
</ol>
<ul>
<li>动画<br>仅当 GPUParticles2D 或 CPUParticles2D 节点上使用的 CanvasItemMaterial 已进行 相应配置 时，粒子翻页动画才有效。<br>如要将粒子翻页设置为线性播放，请将 Speed Min 和 Speed Max 值设置为 1：</li>
</ul>
<p>默认情况下，循环功能是禁用的。如果粒子在其生命周期结束之前播放完毕，则粒子将继续使用翻页的最后一帧（根据翻页纹理的设计方式，这一帧可能是完全透明的）。如果启用循环，粒子的动画将循环回到第一帧并重复播放。</p>
<p>根据精灵表包含的图像数量以及粒子的存活时间情况，你的动画可能看起来会并不流畅。粒子的存活时间、动画速度和精灵表中图像数量之间的关系是这样的：当动画速度为 1.0 时，动画将在粒子生命周期结束时，播放到序列中的最后一个图像。</p>
<p>如果你希望将粒子翻页用作每个粒子的随机粒子纹理源，请将速度值保持为 0 ，并将 Offset Max 设置为 1</p>
<p>请注意，GPUParticles2D 节点的 Fixed FPS 也会影响动画播放。为了动画播放流畅，建议将其设置为 0，以便在每个渲染帧上模拟粒子。如果这个设置不适合你的用例，请将 Fixed FPS 设置为等于翻页动画使用的有效帧速率（请参阅上面的公式）。</p>
<ul>
<li>发射形状<br>ParticleProcessMaterials 允许你设置发射蒙版，它决定发射粒子的区域和方向。 这些可以从项目中的纹理生成。</li>
</ul>
<p>在设置了 ParticleProcessMaterial，并且选择了 GPUParticles2D 节点。 工具栏中就会出现“粒子”菜单<br>打开它并选择“加载发射遮罩”，然后选择你想要用作遮挡的纹理，会出现一个具有多个设置的对话框。</p>
<ul>
<li>发射遮罩<br>纹理可以生成三种类型的发射遮挡:</li>
</ul>
<ol>
<li>实体像素（Solid Pixels）：粒子将从纹理的任意区域产生，透明区域除外。</li>
<li>边界像素（Border Pixels）：粒子将从纹理的外边缘产生。</li>
<li>有向边界像素（Directed Border Pixels）：与边界像素类似，但为遮罩添加了额外信息，使粒子能够从边界发射出去。请注意，需要设置初速度（Initial Velocity）才能使用该功能。</li>
</ol>
<ul>
<li>发射色彩<br>Capture from Pixel 会使粒子在其产生点处继承遮挡材质的颜色。<br>在单击“确定”后，将生成遮罩并将其设置为 ParticleProcessMaterial，位于 Spawn 下，然后是 Position<br>本节中的所有值均由“加载发射遮罩”菜单自动生成，因此通常应将它们保留。<br>不应将图像直接添加到点纹理（Point Texture）或颜色纹理（Color Texture）中。应始终使用“加载发射遮罩”菜单。</li>
</ul>
<h4 id="2D-抗锯齿"><a href="#2D-抗锯齿" class="headerlink" title="2D 抗锯齿"></a>2D 抗锯齿</h4><p>由于分辨率有限，以 2D 渲染的场景可能会出现锯齿现象。<br>使用诸如 Line2D、 Polygon2D 或 TextureProgressBar 等节点时最为明显。<br>2D 中的自定义绘图 对于不支持抗锯齿的方法也可能会出现锯齿现象。<br>为了解决这个问题，Godot 支持多种在 2D 渲染中启用抗锯齿的方法。</p>
<ol>
<li>Line2D 和自定义绘图中的反锯齿属性（推荐）<br>Line2D 具有 Antialiased（抗锯齿）属性，可以在检查器中启用。<br>此外，2D 中的自定义绘图中的一些方法支持提供可选的 antialiased 参数，可以在调用函数时设置为 true。</li>
</ol>
<p>这些方法不需要启用 MSAA，这使得它们的 基准 性能成本很低。<br>换句话说，如果你在某个阶段没有绘制任何抗锯齿几何图形，则不会产生永久性的额外性能消耗。</p>
<p>这些抗锯齿方法的缺点是需要生成额外的几何图形。<br>如果要生成每帧都需要更新的复杂 2D 几何图形，这可能会成为程序的性能瓶颈。<br>此外，Polygon2D、TextureProgressBar 和几种自定义绘图方法都不具备抗锯齿属性。<br>对于这些节点，可以使用 2D 多采样抗锯齿来代替。</p>
<ol start="2">
<li>多重采样抗锯齿（MSAA）<br>该功能仅适用于集群 Forward+ 和 Forward 移动后端，不适用于兼容性渲染器。</li>
</ol>
<p>在 2D 中启用 MSAA 之前，必须先了解 MSAA 的操作对象。2D 中的 MSAA 遵循与 3D 中类似的限制。虽然它不会带来任何模糊，但其应用范围是有限的。2D MSAA 的主要应用包括：</p>
<p>几何边缘，如直线和多边形绘图。</p>
<p>精灵边缘 仅限于与纹理边缘接触的像素 。这适用于线性过滤和最近邻插值过滤。使用图像透明度创建的精灵边缘不受 MSAA 影响。</p>
<p>MSAA 的缺点是它只对边缘起作用。这是因为 MSAA 增加了覆盖采样的数量，但没有增加颜色采样的数量。但是，由于颜色采样的数量没有增加，因此片段着色器仍然只为每个像素运行一次。因此，MSAA 不会影响以下类型的锯齿：</p>
<p>最近邻过滤纹理中的锯齿（像素艺术）。</p>
<p>自定义 2D 着色器造成的锯齿。</p>
<p>使用 Light2D 时的镜面反射锯齿。</p>
<p>文字渲染中的锯齿。</p>
<p>可以通过更改项目设置中 渲染 &gt; 抗锯齿 &gt; 质量 &gt; MSAA 2D Rendering &gt; Anti Aliasing &gt; Quality &gt; MSAA 2D 的值来启用 MSAA。<br>请注意，要更改的是 MSAA 2D 的值，不是 MSAA 3D 的值，这两个是不同的设置项。</p>
<p>左侧为无抗锯齿，右侧为不同级别的多重采样抗锯齿MSAA比较。左上角包含一个Line2D节点，右上角包含2个TextureProgressBar进度条节点。底部包含8个精灵，他们中的4个与边缘接触（绿色背景），另外4个不与边缘接触（Godot标志）：</p>
<h4 id="2D-中的自定义绘图"><a href="#2D-中的自定义绘图" class="headerlink" title="2D 中的自定义绘图"></a>2D 中的自定义绘图</h4><p>Godot 有用于绘制精灵、多边形、粒子、文本以及其它各种游戏开发所需东西的节点。<br>你还可以通过自定义命令在屏幕上绘制任何 2D 节点（例如，基于 Control 或 Node2D ）。</p>
<p>2D 节点中的自定义绘制非常有用。下面是一些用例：</p>
<ul>
<li>绘制现有节点类型无法完成的形状或逻辑，例如带有尾迹或特殊动态多边形的图像。</li>
<li>绘制大量简单的对象，例如 2D 游戏中的一个栅格或一个面板。自定义绘制避免了使用大量节点的开销，能降低内存占用，并提高性能。</li>
<li>制作自定义的 UI 控件，以满足很多可用的控件之外的特别需求。</li>
</ul>
<p>添加一个脚本到任何 CanvasItem 的派生节点，如 Control 或 Node2D。然后重载 _draw() 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line">func _draw():</span><br><span class="line">	pass  # Your draw commands here.</span><br></pre></td></tr></table></figure>
<p>绘制命令在 CanvasItem 的类参考中有所描述。绘制命令的数量很多，我们将在下面的示例中看到一些。</p>
<p>_draw 函数只调用一次，然后绘制命令被缓存并记住，因此不需要进一步调用。<br>如果因为状态或其他方面的变化而需要重新绘制，在当前节点中调用 CanvasItem.queue_redraw ，触发新的 _draw() 调用。<br>这是一个稍微复杂一点的例子，我们有一个可以被随时修改的纹理变量，并且使用一个 setter，它在纹理被修改时强制一次该纹理的重绘：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">@export var texture : Texture2D:</span><br><span class="line">	set(value):</span><br><span class="line">		texture = value</span><br><span class="line">		queue_redraw()</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	draw_texture(texture, Vector2())</span><br></pre></td></tr></table></figure>

<p>为了直观地看到这一功能，你可以通过将默认的 icon.svg 文件从 文件系统 标签拖放到 检查器 标签上的 纹理 属性，将编辑器中的纹理设置为 Godot 图标。当先前脚本运行时更改 纹理 属性值，纹理也将自动更改。</p>
<p>在某些情况下，需要绘制每一帧。 为此，可以像这样从 _process 方法中调用 queue_redraw 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	pass  # Your draw commands here.</span><br><span class="line"></span><br><span class="line">func _process(_delta):</span><br><span class="line">	queue_redraw()</span><br></pre></td></tr></table></figure>

<p>坐标和线宽对齐<br>绘图 API 使用的是 CanvasItem 的坐标系，不一定是像素坐标。这意味着 _draw() 使用的是应用 CanvasItem 的变换后创建的坐标空间。此外，你还可以使用 draw_set_transform 或 draw_set_transform_matrix 在其上方应用自定义变换。</p>
<p>当使用 draw_line 时，你应该考虑线的宽度。当使用奇数宽度时，为了使线保持居中，起点和终点的位置应该偏移 0.5 ，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	draw_line(Vector2(1.5, 1.0), Vector2(1.5, 4.0), Color.GREEN, 1.0)</span><br><span class="line">	draw_line(Vector2(4.0, 1.0), Vector2(4.0, 4.0), Color.GREEN, 2.0)</span><br><span class="line">	draw_line(Vector2(7.5, 1.0), Vector2(7.5, 4.0), Color.GREEN, 3.0)</span><br></pre></td></tr></table></figure>
<p>与使用 filled &#x3D; false 的 draw_rect 方法相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	draw_rect(Rect2(1.0, 1.0, 3.0, 3.0), Color.GREEN)</span><br><span class="line">	draw_rect(Rect2(5.5, 1.5, 2.0, 2.0), Color.GREEN, false, 1.0)</span><br><span class="line">	draw_rect(Rect2(9.0, 1.0, 5.0, 5.0), Color.GREEN)</span><br><span class="line">	draw_rect(Rect2(16.0, 2.0, 3.0, 3.0), Color.GREEN, false, 2.0)</span><br></pre></td></tr></table></figure>

<p>抗锯齿绘图<br>Godot 在 draw_line 方法中提供参数来启用抗锯齿功能，但并非所有自定义绘图方法都提供这个 抗锯齿（antialiased） 参数。<br>对于不提供 antialiased 参数的自定义绘图方法，你可以启用 2D MSAA，这会影响整个视口的渲染。这个功能（2D MSAA）提供了高质量的抗锯齿，但性能成本更高，而且只适用于特定元素。详情见 2D 抗锯齿。<br>最小宽度线段 (width&#x3D;-1) 的对比，分别启用 antialiased&#x3D;false 、 antialiased&#x3D;true 以及 antialiased&#x3D;false 搭配 2D MSAA 2x、4x 和 8x 抗锯齿。</p>
<p>工具<br>运行于编辑器中时，也可能需要绘制自己的节点。这可以用于预览或可视化某些特性或行为。<br>为此，你可以在 GDScript 和 C# 上使用工具注解。有关更多信息，请参阅下面的示例和 在编辑器中运行代码。<br>示例 1：绘制自定义形状<br>我们将使用 Godot 引擎的自定义绘制功能来绘制 Godot 本身没有提供函数的图形。将仅使用绘图函数重新创建 Godot 标志。<br>你需要编写一个函数来执行此操作并自行绘制。</p>
<blockquote>
<p>以下说明使用了一组固定坐标，该坐标对于高分辨率屏幕（大于 1080p）可能太小。如果是这种情况，并且绘图太小，请考虑在 菜单 &gt; 项目 &gt; 项目设置 &gt; 显示&#x2F;窗口&#x2F;拉伸&#x2F;缩放Display &gt; Window &gt; Stretch &gt; Scale 中增加窗口缩放比例，以将项目调整到更高的分辨率（2 或 4 倍缩放通常效果良好）。</p>
</blockquote>
<p>绘制自定义多边形形状<br>虽然存在用于绘制自定义多边形的专用节点 (Polygon2D)，但本例中将仅使用更底层的绘制函数，以便将它们组合在同样的节点上，并能够在之后创建更复杂的形状。<br>我们将首先定义一组点（或 X 和 Y 坐标），它们将构成形状的基础：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">var coords_head : Array = [</span><br><span class="line">	[ 22.952, 83.271 ],  [ 28.385, 98.623 ],</span><br><span class="line">	[ 53.168, 107.647 ], [ 72.998, 107.647 ],</span><br><span class="line">	[ 99.546, 98.623 ],  [ 105.048, 83.271 ],</span><br><span class="line">	[ 105.029, 55.237 ], [ 110.740, 47.082 ],</span><br><span class="line">	[ 102.364, 36.104 ], [ 94.050, 40.940 ],</span><br><span class="line">	[ 85.189, 34.445 ],  [ 85.963, 24.194 ],</span><br><span class="line">	[ 73.507, 19.930 ],  [ 68.883, 28.936 ],</span><br><span class="line">	[ 59.118, 28.936 ],  [ 54.494, 19.930 ],</span><br><span class="line">	[ 42.039, 24.194 ],  [ 42.814, 34.445 ],</span><br><span class="line">	[ 33.951, 40.940 ],  [ 25.637, 36.104 ],</span><br><span class="line">	[ 17.262, 47.082 ],  [ 22.973, 55.237 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这是一种简洁的格式，但并不是 Godot 用于绘制多边形所理解的格式。在其他情况下，我们可能需要从文件中加载这些坐标或在应用程序运行时计算它们的位置，因此可能需要进行一些转换。<br>为了将这些坐标转换为正确的格式，我们将创建一个新的方法 float_array_to_Vector2Array()。然后我们将重写 _ready() 函数，Godot 将仅在执行开始时调用该函数一次，以将这些坐标加载到变量中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var head : PackedVector2Array</span><br><span class="line"></span><br><span class="line">func float_array_to_Vector2Array(coords : Array) -&gt; PackedVector2Array:</span><br><span class="line">	# Convert the array of floats into a PackedVector2Array.</span><br><span class="line">	var array : PackedVector2Array = []</span><br><span class="line">	for coord in coords:</span><br><span class="line">		array.append(Vector2(coord[0], coord[1]))</span><br><span class="line">	return array</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	head = float_array_to_Vector2Array(coords_head);</span><br></pre></td></tr></table></figure>
<p>为了最终绘制第一个形状，我们将使用 draw_polygon 方法，并传递点（ Vector2 坐标数组）及其颜色，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	# We are going to paint with this color.</span><br><span class="line">	var godot_blue : Color = Color(&quot;478cbf&quot;)</span><br><span class="line">	# We pass the PackedVector2Array to draw the shape.</span><br><span class="line">	draw_polygon(head, [ godot_blue ])</span><br></pre></td></tr></table></figure>
<p>注意图标的下部看起来像是分段的，这是因为用于定义该部分的点数量较少。为了模拟平滑曲线，可以向数组中添加更多点，或者使用数学函数来插值曲线以从代码中创建平滑形状（参见 示例 2）。<br>多边形为了形成封闭的形状，总是会将 最后一个定义的点连接到第一个点 。</p>
<p>绘制连接线<br>绘制一系列不封闭成多边形的连接线与之前的方法非常相似。我们将使用一系列连接的线条来绘制 Godot 图标的嘴巴。<br>首先，我们将定义构成嘴巴形状的坐标列表，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var coords_mouth = [</span><br><span class="line">	[ 22.817, 81.100 ], [ 38.522, 82.740 ],</span><br><span class="line">	[ 39.001, 90.887 ], [ 54.465, 92.204 ],</span><br><span class="line">	[ 55.641, 84.260 ], [ 72.418, 84.177 ],</span><br><span class="line">	[ 73.629, 92.158 ], [ 88.895, 90.923 ],</span><br><span class="line">	[ 89.556, 82.673 ], [ 105.005, 81.100 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>我们将把这些坐标加载到一个变量中，并定义另一个变量来设置可配置的线条粗细：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var mouth : PackedVector2Array</span><br><span class="line">var _mouth_width : float = 4.4</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	head = float_array_to_Vector2Array(coords_head);</span><br><span class="line">	mouth = float_array_to_Vector2Array(coords_mouth);</span><br></pre></td></tr></table></figure>
<p>最终我们使用方法 draw_polyline 来真正绘制这条线，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	# We will use white to draw the line.</span><br><span class="line">	var white : Color = Color.WHITE</span><br><span class="line">	var godot_blue : Color = Color(&quot;478cbf&quot;)</span><br><span class="line"></span><br><span class="line">	draw_polygon(head, [ godot_blue ])</span><br><span class="line"></span><br><span class="line">	# We draw the while line on top of the previous shape.</span><br><span class="line">	draw_polyline(mouth, white, _mouth_width)</span><br></pre></td></tr></table></figure>
<p>与 draw_polygon() 不同，折线（polyline）的所有点只能有一个唯一的颜色（第二个参数）。此方法有 2 个附加参数：线的宽度（默认情况下尽可能小），和启用或禁用抗锯齿（默认情况下禁用）。</p>
<p>_draw 调用的顺序很重要，就像树状层次结构上的节点位置一样，将从上到下绘制不同的形状，这会使得新绘制的形状在重叠时隐藏掉较早绘制的形状。在本例中，我们希望将嘴放在头上，因此我们将其放在后面。</p>
<p>请注意我们如何以不同的方式定义颜色，无论是使用十六进制代码还是预定义的颜色名称。请检查类 Color 的其他常量和定义颜色的方法。</p>
<p>绘制圆<br>为了创建眼睛，我们将添加 4 个额外的调用来绘制不同大小、颜色和位置的眼睛形状。<br>为了绘制圆形，请使用 draw_circle 方法根据其圆的中心定位它。第一个参数是以 Vector2 形式写下的中心坐标，第二个参数是其半径，第三个参数是其颜色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	var white : Color = Color.WHITE</span><br><span class="line">	var godot_blue : Color = Color(&quot;478cbf&quot;)</span><br><span class="line">	var grey : Color = Color(&quot;414042&quot;)</span><br><span class="line"></span><br><span class="line">	draw_polygon(head, [ godot_blue ])</span><br><span class="line">	draw_polyline(mouth, white, _mouth_width)</span><br><span class="line"></span><br><span class="line">	# Four circles for the 2 eyes: 2 white, 2 grey.</span><br><span class="line">	draw_circle(Vector2(42.479, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(85.524, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(43.423, 65.92), 6.246, grey)</span><br><span class="line">	draw_circle(Vector2(84.626, 66.008), 6.246, grey)</span><br></pre></td></tr></table></figure>
<p>对于部分未填充的圆弧（某些任意角度之间的圆形部分），可以使用方法 draw_arc。</p>
<p>绘制线<br>为了绘制最终的形状（鼻子），我们将使用一条线来近似模拟它。<br>通过提供其开始和结束坐标作为参数，draw_line 可用于绘制单个线段，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	var white : Color = Color.WHITE</span><br><span class="line">	var godot_blue : Color = Color(&quot;478cbf&quot;)</span><br><span class="line">	var grey : Color = Color(&quot;414042&quot;)</span><br><span class="line"></span><br><span class="line">	draw_polygon(head, [ godot_blue ])</span><br><span class="line">	draw_polyline(mouth, white, _mouth_width)</span><br><span class="line">	draw_circle(Vector2(42.479, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(85.524, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(43.423, 65.92), 6.246, grey)</span><br><span class="line">	draw_circle(Vector2(84.626, 66.008), 6.246, grey)</span><br><span class="line"></span><br><span class="line">	# Draw a short but thick white vertical line for the nose.</span><br><span class="line">	draw_line(Vector2(64.273, 60.564), Vector2(64.273, 74.349), white, 5.8)</span><br></pre></td></tr></table></figure>
<p>请注意，如果要同时绘制多条未连接的线，可以通过使用 draw_multiline 方法在一次调用中绘制所有线，来获得额外的性能提升。</p>
<p>绘制文本<br>虽然向程序中添加文本的最常见方法是使用 Label 节点，但是低阶的 _draw 函数提供了在自定义 Node 绘制时添加文本的功能。我们就用这个方法在机器人的脑袋下面加上它的名字“GODOT”。<br>具体做法是调用 draw_string，类似于这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var default_font : Font = ThemeDB.fallback_font;</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	var white : Color = Color.WHITE</span><br><span class="line">	var godot_blue : Color = Color(&quot;478cbf&quot;)</span><br><span class="line">	var grey : Color = Color(&quot;414042&quot;)</span><br><span class="line"></span><br><span class="line">	draw_polygon(head, [ godot_blue ])</span><br><span class="line">	draw_polyline(mouth, white, _mouth_width)</span><br><span class="line">	draw_circle(Vector2(42.479, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(85.524, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(43.423, 65.92), 6.246, grey)</span><br><span class="line">	draw_circle(Vector2(84.626, 66.008), 6.246, grey)</span><br><span class="line">	draw_line(Vector2(64.273, 60.564), Vector2(64.273, 74.349), white, 5.8)</span><br><span class="line"></span><br><span class="line">	# Draw GODOT text below the logo with the default font, size 22.</span><br><span class="line">	draw_string(default_font, Vector2(20, 130), &quot;GODOT&quot;,</span><br><span class="line">				HORIZONTAL_ALIGNMENT_CENTER, 90, 22)</span><br></pre></td></tr></table></figure>

<p>其他参数以及其他和文本字符相关的方法都可以在 CanvasItem 的类参考中找到。</p>
<p>编辑时显示绘制<br>虽然目前这段代码已经可以在运行中的窗口中绘制 Logo，但却并没有在编辑器中的 2D 视图 上显示。在某些特定情况下，你希望自制的 Node2D 或者控件节点能够在编辑器中显示，跟其他绝大多数节点一样，这以便于定位和缩放。<br>为了能够在编辑器中直接显示 Logo，而不必运行程序，你可以使用 @tool 注解，来要求自制的绘制节点在编辑时显示，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@tool</span><br><span class="line">extends Node2D</span><br></pre></td></tr></table></figure>
<p>每当你添加或移除 @tool 注解时，你需要保存场景，重新构建项目（仅限 C#），并且选择菜单选项 场景 &gt; 重载已保存场景 来手动重载当前场景，才能刷新 2D 视图中的节点。</p>
<p>动画<br>如果希望自制图形在运行时改变形状，便需要修改执行时调用的方法或者参数，或者应用一个变换。<br>举个例子，如果想让我们刚刚设计的自制形状旋转，那么可以先 _ready 和<code>_process</code> 方法中添加如下变量和代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">@export var rotation_speed : float = 1  # In radians per second.</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	rotation = 0</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">func _process(delta: float):</span><br><span class="line">	rotation -= rotation_speed * delta</span><br></pre></td></tr></table></figure>
<p>上述代码的问题在于，我们所创建的点是差不多是从左上角，即坐标轴的 (0, 0) 处，扩展到右下角，所以看到的旋转才是以左上角为轴心的。对于节点的位置变换并不能帮到我们，因为旋转变化会先作用。</p>
<p>不过我们可以重写所有点的坐标，使其以 (0, 0) 点为中心，这就包括了坐标的负半轴，那可是个大工程。</p>
<p>一个可行的方案就是使用更底层的 draw_set_transform 方法来解决此问题，这个方法能够平移 CanvasItem 自身空间的所有点，然后再使用常规的节点变换将其移动至原位，用编辑器或代码均可，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func _ready():</span><br><span class="line">	rotation = 0</span><br><span class="line">	position = Vector2(60, 60)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	draw_set_transform(Vector2(-60, -60))</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>这就是最终结果，以 (60, 60) 点为轴心旋转</p>
<p>如果我们在 _draw() 中调用属性而动画化，必须调用 queue_redraw() 来强制刷新，否则不会在屏幕上更新内容。<br>例如，可以通过改变嘴巴线条的宽度，使机器人“张嘴”和“闭嘴”，宽度的变化遵循正弦 (sin) 曲线</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var _mouth_width : float = 4.4</span><br><span class="line">var _max_width : float = 7</span><br><span class="line">var _time : float = 0</span><br><span class="line"></span><br><span class="line">func _process(delta : float):</span><br><span class="line">	_time += delta</span><br><span class="line">	_mouth_width = abs(sin(_time) * _max_width)</span><br><span class="line">	queue_redraw()</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	...</span><br><span class="line">	draw_polyline(mouth, white, _mouth_width)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>请注意， _mouth_width 与任何其他属性一样，都是用户定义的属性。它或任何其他用作绘图参数的属性，都可以使用更标准的高级方法进行动画处理，例如 Tween 或 AnimationPlayer 节点。唯一区别是需要调用 queue_redraw() 应用更改，使内容在屏幕上显示。</p>
<p>示例 2：绘制动态线条<br>先前示例展示了如何使用自定义形状和动画绘制和修改节点。这种方法具有一些优势，如使用精确坐标和向量进行绘制，而不是位图（在屏幕上缩放时仍然清晰）。在某些情况下，也可以通过组合如 sprites 或 AnimatedSprites 等高级功能与节点来实现类似的效果，这些节点可以加载 SVG 格式资源，并使用 AnimationPlayer 节点。<br>在两点之间绘制直线<br>假设我们想要绘制一条连接两个点的直线，第一个点固定在屏幕左上角 (0, 0) ，第二个点由屏幕上的光标位置决定。<br>可以像这样绘制这两个点之间的动态的线:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">var point1 : Vector2 = Vector2(0, 0)</span><br><span class="line">var width : int = 10</span><br><span class="line">var color : Color = Color.GREEN</span><br><span class="line"></span><br><span class="line">var _point2 : Vector2</span><br><span class="line"></span><br><span class="line">func _process(_delta):</span><br><span class="line">	var mouse_position = get_viewport().get_mouse_position()</span><br><span class="line">	if mouse_position != _point2:</span><br><span class="line">		_point2 = mouse_position</span><br><span class="line">		queue_redraw()</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	draw_line(point1, _point2, color, width)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们在每一帧都使用 get_mouse_position 方法获取鼠标在默认视口中的位置。如果位置与上次绘制请求时相比发生了变化（小优化，避免在每一帧都重新绘制），而进行一次重新绘制。_draw() 方法只有一行代码：请求绘制一条绿色线条，宽度为 10 像素，左上角和获取到的坐标之间。<br>起始点的宽度、颜色和位置可以通过相应的属性进行配置。</p>
<p>绘制两点之间的弧线<br>上面的例子可以实现效果，但有时可能想用除直线以外的形状或函数连接这两个点。<br>让我们尝试在两个点之间创建一个弧线（圆周的一部分）。<br>通过将线段的起始点、段数、宽度、颜色和抗锯齿属性导出为变量，从而可在编辑器检查器面板中方便修改这些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">@export var point1 : Vector2 = Vector2(0, 0)</span><br><span class="line">@export_range(1, 1000) var segments : int = 100</span><br><span class="line">@export var width : int = 10</span><br><span class="line">@export var color : Color = Color.GREEN</span><br><span class="line">@export var antialiasing : bool = false</span><br><span class="line"></span><br><span class="line">var _point2 : Vector2</span><br></pre></td></tr></table></figure>
<p>为了绘制弧线，可以使用 draw_arc 方法。事实上，穿过两个点的弧线有很多种，在这个例子中，我们将选择一个半圆，它的圆心位于初始两个点之间的中点。<br>确实，计算此弧线要比计算直线复杂得多:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	# Average points to get center.</span><br><span class="line">	var center : Vector2 = Vector2((_point2.x + point1.x) / 2,</span><br><span class="line">								   (_point2.y + point1.y) / 2)</span><br><span class="line">	# Calculate the rest of the arc parameters.</span><br><span class="line">	var radius : float = point1.distance_to(_point2) / 2</span><br><span class="line">	var start_angle : float = (_point2 - point1).angle()</span><br><span class="line">	var end_angle : float = (point1 - _point2).angle()</span><br><span class="line">	if end_angle &lt; 0:  # end_angle is likely negative, normalize it.</span><br><span class="line">		end_angle += TAU</span><br><span class="line"></span><br><span class="line">	# Finally, draw the arc.</span><br><span class="line">	draw_arc(center, radius, start_angle, end_angle, segments, color,</span><br><span class="line">			 width, antialiasing)</span><br></pre></td></tr></table></figure>
<p>半圆的圆心将是两个点之间的中点。半径将是两个点之间距离的一半。起始角度和结束角度将分别为点 1 到点 2 的向量角度以及点 2 到点 1 的向量角度。需要注意的是，我们需要将 end_angle 归一化为正值，因为如果 end_angle 小于 start_angle ，则弧线将逆时针绘制，在这里，并不想要该效果 (弧线会上下颠倒)。</p>
<p>结果应该像这样，弧线向下延伸并穿过这些点：<br>可在检查器中调整参数以获得不同的结果：改变颜色、宽度、抗锯齿，以及增加段数以提高曲线的平滑度，但这样会牺牲部分性能。</p>
<h4 id="2D-视差"><a href="#2D-视差" class="headerlink" title="2D 视差"></a>2D 视差</h4><p>视差是一种视觉效果，通过让图像纹理相对于相机以不同速度移动来模拟纵深。Godot 提供了 Parallax2D 节点来实现这种效果。这方面的坑还是不少的，因此本页面会对部分属性进行深入描述，并会介绍纠正一些常见错误的方法。<br>本页面介绍如何使用 Parallax2D 节点。建议使用它来替代 ParallaxLayer 和 ParallaxBackground 节点。</p>
<p>视差节点支持添加将对象渲染为子节点的节点，因此你可以使用一个或多个节点来组成每个图层。首先，将每个你想要独立滚动的节点（或多个节点）放置为它们各自视差节点的子节点。确保使用的纹理的左上角位于 (0, 0) 交叉点，如下图所示。请参阅 定位 部分了解这一节点为何重要。</p>
<p>滚动缩放<br>视差效果的核心是 scroll_scale 属性，该属性为滚动速度系数，能够让图层的移动速度和相机的移动速度产生差别，不同的轴可以分别进行调整。设为 1 时视差节点与相机同速。滚动时，如果你想要让图像看起来比较远，请使用小于 1 的值，设为 0 就会完全停止。如果你想要让图像看起来离相机很近，请使用大于 1 的值，这样图像滚动得就会更快。</p>
<p>上面这个场景由五个图层构成，对应的 scroll_scale 可以设置为：<br>(0.7, 1) - 森林<br>(0.5, 1) - 山丘<br>(0.3, 1) - 低处的云<br>(0.2, 1) - 高处的云<br>(0.1, 1) - 天空</p>
<p>无限重复<br>Parallax2D 还可以顺便让纹理产生无限重复的假象。相机移动时，repeat_size 可以让节点的位置根据这个值向前或向后吸附。这个效果的原理是让所有子级画布项重复一次并使用这个值进行偏移。而相机在原本的图像和重复的图像之间滚动，悄悄跳回原本的位置就会造成图像循环的效果。</p>
<p>大小问题<br>为了方便实现无限重复效果，图像本身最好就需要能够无缝重复，并且需要图像的大小在设置 repeat_size 之前至少要和视口大小一致。如果无法获取合适的资产素材，也有一些方法可以事先处理一下图像的大小。<br>下例是一个在视口中显得太小的纹理:<br>我们可以看到视口的尺寸是 500x300 而纹理的尺寸是 288x208。如果我们把 repeat_size 设置为图像的尺寸，无限重复效果在滚动时就会出问题，因为原始纹理没有覆盖整个视口。如果我们把 repeat_size 设置为视口的尺寸，那么就会有一个很大的间隙。那该怎么办呢？<br>把视口调小<br>最简单的答案是将视口设置为与纹理大小相同或更小。在 项目设置 &gt; 显示 &gt; 窗口 中，更改 视口宽度 和 视口高度 设置，使其与背景匹配。<br>缩放 Parallax2D<br>如果你想要实现的不是完美像素风，或者不介意存在略微的模糊，那么你可以选择将纹理放大到适合屏幕的尺寸。请设置 Parallax2D 的 scale，所有子级纹理都会对应发生缩放。</p>
<p>缩放子节点<br>和放大 Parallax2D 类似的是将 Sprite2D 节点放大到能够覆盖住屏幕。请注意，Parallax2D.repeat_size 和 Sprite2D.region_rect 等设置并不会考虑缩放，因此这些值也需要根据缩放进行调整。</p>
<p>重复纹理<br>你也可以通过提前准备子节点来确保从一开始就走上正确的道路。如果你有一个希望重复的 Sprite2D，但它的尺寸太小，就可以按照以下步骤来重复它：<br>将 texture_repeat 设置为 CanvasItem.TEXTURE_REPEAT_ENABLED<br>将 region_enabled 设置为 true<br>将 region_rect 设置为纹理大小的倍数，让纹理足够覆盖住视口。<br>下图中可以看到，把图像重复一次就足够覆盖住屏幕了。</p>
<p>位置问题<br>用户经常错误地把所有纹理都设成在 (0,0) 居中<br>这会给无限重复效果带来问题，应当尽量避免。“无限重复画布”从 (0,0) 开始，向右下扩展至 repeat_size 的大小值。<br>如果纹理是以 (0,0) 交叉点为中心的，那么无限重复画布只会被部分覆盖，因此也只会部分地重复。</p>
<p>把 repeat_times 调大有用吗？<br>从技术上来说，增加 repeat_times 在某些情况下将是可行的，但这是一种暴力的解决方案，而不是它被设计用于解决的问题（我们稍后会讨论这个问题）。更好的解决方法是理解重复效果的工作原理，并在开始时就适当地设置视差纹理。</p>
<p>首先，检查是否有任何纹理溢出到画布的负轴向。确保在视差节点中使用的纹理都位于从 (0,0) 开始的“无限重复画布”内。这样，如果正确设置了 Parallax2D.repeat_size，效果应该看起来像这样，图像的单次循环与视口大小相同或更大：<br>想象一下图像是如何在屏幕上滚动的，它首先显示红色矩形内的内容（由 repeat_size 确定），当到达黄色矩形内时，它会将图像向前拉动，从而给人一种永远滚动的感觉。<br>如果你将图像放置在“无限重复画布”之外的位置，当摄像机到达黄色矩形区域时，图像的一半会被裁切掉，然后才会向前跳转，就像下图所示：</p>
<p>滚动偏移<br>如果你的视差纹理已经正常工作，但你希望它从不同的点开始，Parallax2D 附带一个 scroll_offset 属性，用于偏移无限重复画布的开始位置。例如，如果你的图像是 288x208，将 scroll_offset 设置为 (-144,0) 或 (144,0) 可使其从图像的中间位置开始。</p>
<p>重复次数<br>理想情况下，按照本指南操作，你的视差纹理足够大，即使在缩小时也能覆盖屏幕。到目前为止，我们在 288x208 视口内拥有一个完美贴合的 288x208 纹理。但是，当我们通过将 Camera2D.zoom 设置为 (0.5, 0.5) 进行缩小时，会出现问题：</p>
<p>尽管在默认缩放级别下，视口的所有内容都已正确设置，但缩小后会使它小于该视口，从而破坏无限重复效果。这时 repeat_times 就可以提供帮助。将值设置为 3（前后各一个额外的重复），现在它就足够大，可以容纳无限重复的效果了。</p>
<p>如果这些纹理需要垂直地重复，我们应该为 repeat_size 指定一个 y 值。repeat_times 也会自动在上方和下方添加重复。这只是一个水平视差，因此它会在图像上方和下方留下一个空白块。我们如何解决这个问题？我们需要发挥创造力！在这个例子中，我们将天空拉高，将草精灵拉低。纹理现在支持正常缩放级别以及缩小到一半大小。</p>
<p>分屏<br>大多数用 Godot 制作分屏游戏的教程一开始都是要写一个简单的脚本，把第一个 SubViewport 的 Viewport.world_2d 赋值给第二个 SubViewport，从而实现屏幕的共享。此时就会产生如何在这两个屏幕之间共享视差效果的问题。</p>
<p>视差效果模拟透视的方法是让不同的纹理根据其与相机的关系移动不同的距离。存在多个相机时，很显然就会出现问题，因为同一个纹理不可能同时出现在两个不同的地方！</p>
<p>解决方法也是有的，把视差节点往第二个（或者第三第四个） SubViewport 里复制一份就好了。在双人游戏里是这个样子的：</p>
<p>当然，现在两个背景都会在两个 SubViewport 中显示。我们希望的是每个视差背景只在其对应的视口中显示。你可以通过以下方式实现这一点：</p>
<p>将所有视差节点的 visibility_layer 保留为其默认值 1 。</p>
<p>将第一个 SubViewport 的 canvas_cull_mask 设置为仅 1 号图层和 2 号图层。</p>
<p>对第二个 SubViewport 执行相同的操作，但使用图层 1 和 图层 3。</p>
<p>为第一个 SubViewport 中的视差节点提供一个共同的父节点，并将其 visibility_layer 设置为 2。</p>
<p>对第二个 SubViewport 的视差节点执行相同的操作，但使用 3 号图层。</p>
<p>这是如何工作的？如果一个画布项的 visibility_layer 与 SubViewport 的 canvas_cull_mask 不匹配，它将隐藏所有子节点，即使它们匹配也是如此。我们利用这一点，让 SubViewport 停止那些父节点没有匹配的 visibility_layer 的视差节点的渲染。</p>
<p>在编辑器中预览<br>4.3 版本之前推荐的是把每个层都放到各自的 ParallaxBackground 下面，然后启用 follow_viewport_enabled 属性，再对各个层进行缩放。这个方法要用对还挺难的，用 CanvasLayer 代替 ParallaxBackground 也能达到想要的效果。</p>
<p>另外推荐 KoBeWi 的“Parallax2D Preview”插件。这个插件提供了很多预览模式，挺好用的！</p>
<h3 id="物理与移动"><a href="#物理与移动" class="headerlink" title="物理与移动"></a>物理与移动</h3><p>2D 运动概述<br>每个初学者都问过“我该如何移动我的游戏角色呢？”根据你正在制作的游戏的风格，可能有特殊的需求，但一般来说，大多数 2D 游戏的运动都基于一组不太多的操作之上。</p>
<p>在这些示例中，我们将使用 CharacterBody2D，但这些原则也适用于其他节点类型（如 Area2D、RigidBody2D）。</p>
<p>场景布置<br>以下每个示例都使用相同的场景布置。从带有 Sprite2D 和 CollisionShape2D 这两个子节点的 CharacterBody2D 开始。你可以将 Godot 图标（“icon.png”）用于 Sprite2D 的纹理，也可以使用你拥有的任何其他 2D 图像。</p>
<p>打开项目 -&gt; 项目设置并选择“输入映射”选项卡。添加以下输入操作（相关详细信息请参阅 InputEvent）：</p>
<p>八向移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extends CharacterBody2D</span><br><span class="line"></span><br><span class="line">@export var speed = 400</span><br><span class="line"></span><br><span class="line">func get_input():</span><br><span class="line">	var input_direction = Input.get_vector(&quot;left&quot;, &quot;right&quot;, &quot;up&quot;, &quot;down&quot;)</span><br><span class="line">	velocity = input_direction * speed</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	get_input()</span><br><span class="line">	move_and_slide()</span><br></pre></td></tr></table></figure>
<p>在函数 get_input() 中，我们使用 Input 的 get_vector() 来检查四个按键事件，并返回一个方向向量的累加值。<br>然后，我们可以将长度为 1 的方向矢量乘以所需的速度来设定速度。</p>
<p>旋转+移动<br>“Asteroids式运动”类似于经典街机游戏Asteroids的工作方式。<br>按左&#x2F;右旋转角色，而按上&#x2F;下使得角色在面向的方向上向前或向后。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extends CharacterBody2D</span><br><span class="line"></span><br><span class="line">@export var speed = 400</span><br><span class="line">@export var rotation_speed = 1.5</span><br><span class="line"></span><br><span class="line">var rotation_direction = 0</span><br><span class="line"></span><br><span class="line">func get_input():</span><br><span class="line">	rotation_direction = Input.get_axis(&quot;left&quot;, &quot;right&quot;)</span><br><span class="line">	velocity = transform.x * Input.get_axis(&quot;down&quot;, &quot;up&quot;) * speed</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	get_input()</span><br><span class="line">	rotation += rotation_direction * rotation_speed * delta</span><br><span class="line">	move_and_slide()</span><br></pre></td></tr></table></figure>
<p>这里我们添加了两个变量来跟踪我们的旋转方向和速度。旋转直接应用于主体的 rotation 属性。<br>要设置速度，我们使用物体的 transform.x ，这是一个指向物体 “前进” 方向的矢量，然后乘以速度。</p>
<p>旋转+移动（鼠标）<br>这种运动方式是前一种运动方式的变体。这次，方向由鼠标位置而不是键盘设置。角色将始终“看向”鼠标指针。前进&#x2F;后退输入保持不变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extends CharacterBody2D</span><br><span class="line"></span><br><span class="line">@export var speed = 400</span><br><span class="line"></span><br><span class="line">func get_input():</span><br><span class="line">	look_at(get_global_mouse_position())</span><br><span class="line">	velocity = transform.x * Input.get_axis(&quot;down&quot;, &quot;up&quot;) * speed</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	get_input()</span><br><span class="line">	move_and_slide()</span><br></pre></td></tr></table></figure>
<p>这里我们用到 Node2D 中的 look_at() 方法，使玩家朝向鼠标的位置。如果没有此功能，可以通过如下设置角度以获得相同的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rotation = get_global_mouse_position().angle_to_point(position)</span><br></pre></td></tr></table></figure>

<p>点击并移动<br>最后一个示例仅使用鼠标来控制角色。 单击屏幕将使游戏角色移动到目标位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extends CharacterBody2D</span><br><span class="line"></span><br><span class="line">@export var speed = 400</span><br><span class="line"></span><br><span class="line">var target = position</span><br><span class="line"></span><br><span class="line">func _input(event):</span><br><span class="line">	# Use is_action_pressed to only accept single taps as input instead of mouse drags.</span><br><span class="line">	if event.is_action_pressed(&amp;&quot;click&quot;):</span><br><span class="line">		target = get_global_mouse_position()</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	velocity = position.direction_to(target) * speed</span><br><span class="line">	# look_at(target)</span><br><span class="line">	if position.distance_to(target) &gt; 10:</span><br><span class="line">		move_and_slide()</span><br></pre></td></tr></table></figure>
<p>注意我们在移动之前做的 distance_to() 检查。 如果没有这个检查，物体在到达目标位置时会 “抖动”，因为它稍微移过该位置时就会试图向后移动，只是每次移动步长都会有点远从而导致来回重复移动。</p>
<p>如果你喜欢，取消注释的 rotation 代码可以使物体转向其运动方向。</p>
<p>小技巧<br>该技术也可以用到“跟随”的游戏角色中。target 目标位置可以是任何你想移动到的对象的位置。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="使用-TileSet"><a href="#使用-TileSet" class="headerlink" title="使用 TileSet"></a>使用 TileSet</h4><p>图块地图（Tilemap）是由图块（Tile）组成的栅格，用于创建游戏的布局。使用 TileMapLayer 节点设计关卡有很多好处。首先，它让你在绘制布局时可以直接把图块“画”到栅格上，这比逐个放置 Sprite2D 节点要快很多。其次，由于图块地图针对大量图块的绘制进行了优化，它能支持更大的关卡。最后，你还可以为图块添加更强大的功能，诸如碰撞、遮挡、导航等形状。</p>
<p>要使用 TileMapLayer 节点，你需要先创建一个 TileSet（图块集）。TileSet 是图块的集合，这些图块可以放置在 TileMapLayer 节点中。创建 TileSet 后，你就可以使用 TileMap 编辑器来放置图块了。</p>
<p>要跟随这个指南进行操作，你需要一张包含若干图块的图片，每个图块的大小都应该相同（较大的对象可以拆成若干个图块）。这种图片叫做图块表（Tilesheet）。图块不一定必须是正方形的：可以是矩形图块、六边形图块、等轴图块（伪 3D 透视）。</p>
<p>新建 TileSet<br>使用图块表<br>这个演示使用的是从 Kenney 的“抽象平台跳跃”包中选取的图块。我们会使用该集合中的这个图块表：<br>新建一个 TileMapLayer 节点，选中它，然后在检查器中新建 TileSet 资源：<br>创建 TileSet 资源后，在检查器中点击该值可以将其展开。默认图块形状是 Square（正方形），但是你也可以根据图块图像中的形状去选择 Isometric（等轴）、Half-Offset Square（半偏移正方形）、Hexagon（六边形）。如果使用了 Square 以外的图块形状，你可能还需要调整 Tile Layout（图块布局）和 Tile Offset Axis（图块偏移轴）等属性。最后，如果你想要让图块被图块坐标裁剪，还可以启用 Rendering &gt; UV Clipping（渲染 &gt; UV 裁剪）属性。这样就能够保证图块无法绘制到它们在图块表上分配的区域之外。</p>
<p>在检查器中将图块大小设置为 64×64，与示例图块表相匹配：<br>如果依赖于自动图块创建（就像我们即将要做的那样），你必须在创建 图集 之前 设置图块大小。图集将确定哪些从图块表中而来的图块可以添加到 TileMap 节点（因为并不是图像的每一个部分都是有效的图块）。</p>
<p>打开编辑器底部的 TileSet 面板，然后将图块表图像拖放到该面板中。这里会询问你是否要自动创建图块。请回答是：</p>
<p>根据图块表图像内容自动创建图块</p>
<p>这将根据你之前在 TileSet 资源中指定的图块尺寸自动创建图块。这将大大加快初始图块设置的速度。</p>
<p>使用基于图像内容的自动图块生成功能时，图块表中 完全 透明的部分将不会生成图块。</p>
<p>如果不希望图集中出现图块表中的图块，请选择图块组预览顶部的橡皮擦工具，然后单击希望删除的图块：<br>你也可以右键单击图块，选择 删除 ，作为橡皮擦工具的替代。</p>
<blockquote>
<p>与 2D 和 TileMap 编辑器一样，你可以使用鼠标中键或右键平移整个 TileSet 面板，并使用鼠标滚轮或左上角的按钮进行缩放。</p>
</blockquote>
<p>如果你想在一个 TileSet 中使用好几张 tilesheet 来选择图块，新建几个图块集，并为每个图块集配置纹理再继续。你也可以用这种方法把单张图片作为一个图块来使用。（但是用 tilesheet 会方便得多）。</p>
<p>你可以调整中间的列中图集的属性：</p>
<p>可以在图集上调整以下属性：</p>
<p>ID： 标识符（在该 TileSet中每个图块集的标识符是唯一的），用于排序。</p>
<p>名称： 图集的人类可读名称。在此处使用描述性的名称来方便管理（例如“地形”，“装饰”等）。</p>
<p>边距： 图像边缘上的边距不应选择为图块（以像素为单位）。当你下载的图块表图像的边缘有边距（例如，用于表明归属），则增加这个值可能会很有用。</p>
<p>间距： 以像素为单位的地图集上的每个图块之间的间距。如果你使用的图块表图像包含辅助线（例如每个图块之间的轮廓），则增加间距可能会很有用。</p>
<p><strong>纹理区域大小：</strong> 以像素为单位的图集上的每个图块的大小。在大多数情况下，这应该与 TileMapLayer 属性中定义的图块大小相匹配（尽管并不是必需的）。</p>
<p>使用纹理内边距： 如果选用，则在每个图块周围添加一个1像素的透明的边缘，以防止启用过滤时纹理渗出（bleeding）。建议默认将其启用，除非你由于纹理内边距而遇到渲染问题。</p>
<p>请注意，更改纹理边距，间距和区域大小都有可能会导致图块丢失（其中一些将位于图集图片的坐标之外）。如要自动从图块表中再生图块，请使用图块集编辑器顶部的三个垂直点菜单按钮，然后选择 在不透明纹理区域创建图块 ：</p>
<p>使用场景合集<br>自 Godot 4.0 以来，你可以将实际的 场景 放置为图块。这允许你将任何节点集合用作图块。比如说，你可以使用场景图块来放置游戏元素，例如玩家可以与之互动的商店。还可以使用场景图块来放置 AudioStreamPlayer2D （用于环境声音）、粒子效果等。</p>
<blockquote>
<p>与图集相比，场景图块具有更大的性能开销，因为每个场景都是为每个放置的图块单独实例化的。<br>建议仅在必要时使用场景图块。要在没有任何高级操作的图块中绘制精灵，请使用图集代替。</p>
</blockquote>
<p>对于本例，我们将创建一个包含 CPUParticles2D 根节点的场景。将此场景保存到场景文件（与包含 TileMapLayer 的场景分离），然后切换到包含 TileMapLayer 节点的场景。打开 TileSet 编辑器，在左列中创建一个新的 场景集合 ：</p>
<p>创建场景合集之后，你就可以根据自己的需要在中间栏内为场景合集输入描述名称。选中这个场景合集，然后创建一个新的场景槽：</p>
<p>在右栏中选中这个场景槽，然后使用快速加载（或加载）来加载包含粒子的场景文件：</p>
<p>现在你的 TileSet 中就有了一个场景图块。切换到 TileMap 编辑器之后，你就可以在场景合集中选择则个场景图块，然后和其他图块一样进行绘制。</p>
<p>将若干图集合并为单个图集<br>在单个 TileSet 资源中使用多个图集有时可能很有用，但在某些情况下可能会变得繁琐（特别是如果你每个图块使用一个图像）。Godot 允许你将多个图集合并成一个单独的图集，以便更轻松地组织。</p>
<p>如果要这样做，你必须在TileSet资源处创建了不止一个atlas。在atlas列表下找到“三个垂直排列的点”的菜单按钮，然后选择<strong>打开图集合并工具</strong>:<br>这将打开一个对话框，在该对话框中，你可以通过按住 Shift 或 Ctrl 键并同时点击多个元素来选择多个图集：<br>选择 合并 将以选择的图集合并成一个图集图片（在 TileSet 的单个图集）。没有合并的图集将会在 TileSet 被移除，但是 原来的 tilesheet 图片会被保留在文件系统里 。如果你想在TileSet 资源保留没有合并的图集，选择 合并（保留原来的图集） 。</p>
<blockquote>
<p>TileSet 具有一个 图块代理 系统。图块代理是一张映射表，它允许通知使用了给定 TileSet 的 TileMap，以便将一组给定的图块标识符替换为另一组图块标识符。<br>合并不同图集时会自动设置图块代理，但也可以通过 管理图块代理 对话框手动设置，你可以使用上面提到的“三个竖点”菜单访问该对话框。<br>当你更改了图集 ID 或想用另一个图集的图块替换一个图集的所有图块时，手动创建图块代理可能会很有用。请注意，编辑 TileMap 时，你可以用相应的映射值替换所有网格。</p>
</blockquote>
<p>向 TileSet 添加碰撞、导航和遮挡<br>现在我们已经成功创建了一个基本的 TileSet。我们现在可以开始使用 TileMapLayer 节点，但它目前缺乏任何形式的碰撞检测。这意味着玩家和其他物体可以直接穿过地板或墙壁。</p>
<p>如果使用 2D 导航，还需要为图块定义导航多边形，以生成导航网格，可供代理用于寻路。</p>
<p>最后，如果你使用 2D 灯光和阴影 或 GPUParticles2D，你可能还希望 TileSet 能够投射阴影并与粒子碰撞。这就需要为 TileSet 上的 “实体” 图块定义遮挡多边形。</p>
<p>要为每个图块定义碰撞、导航和遮罩形状，首先需要为 TileSet 资源创建物理层、导航层或遮挡层。为此，请选择 TileMapLayer 节点，单击检查器中的 TileSet 属性值进行编辑，然后展开 物理层 并选择 添加元素：</p>
<p>如果你还需要导航辅助，可以创建导航层：<br>如果你需要支持光照多边形遮挡器，可以创建遮挡层：</p>
<p>本教程的后续步骤专门用于创建碰撞多边形，但导航和遮挡的步骤非常相似。它们各自的多边形编辑器行为方式相同，因此为简洁起见不再重复这些步骤。唯一需要注意的是，图块的遮挡多边形属性是图集检查器中 渲染 分节的一部分。请确保展开该部分，以便编辑多边形。</p>
<p>创建物理层后，你可以访问 TileSet 图集检查器中的 物理层 部分：</p>
<p>你可以在聚焦 TileSet 编辑器时按 F 快速创建矩形碰撞形状。如果键盘快捷键不起作用，请尝试单击多边形编辑器周围的空白区域使其聚焦：</p>
<p>在这个图块碰撞编辑器中，你可以使用所有二维多边形编辑工具：</p>
<ul>
<li>使用多边形上方的工具栏可在创建新多边形、编辑现有多边形和删除多边形上的点之间切换。“三个竖点”菜单按钮提供了其他选项，例如旋转和翻转多边形。</li>
<li>通过单击并拖动两点之间的直线来创建新点。</li>
<li>右键单击一个点（或使用上述移除工具并左键单击）将其移除。</li>
<li>通过中键或右键在编辑器中平移。(右键平移只能用于附近没有点的区域）</li>
</ul>
<p>你可以使用默认的矩形形状，通过移除其中一个点来快速创建三角形碰撞形状：<br>你还可以通过添加更多点，将矩形用作更复杂形状的基础：</p>
<p>如果你有一个大的图块集，为每个图块单独指定碰撞可能会花费很多时间。尤其是在 TileMaps 中往往有许多具有常见碰撞模式（如实心块或 45 度斜坡）的图块。要快速将类似的碰撞形状应用到多个图块，请使用一次为多个图块指定属性的功能。</p>
<p>为 TileSet 的图块分配自定义元数据<br>你可以使用自定义数据层来为各个图块分配自定义数据。可以用来存储游戏过程中所需的特定信息，例如玩家接触该图块时应该受到的伤害，以及是否能够使用物理将图块摧毁。</p>
<p>数据是在 TileSet 中与图块进行关联的：放置的所有图块使用的都是相同的自定义数据。如果你需要创建拥有不同自定义数据的变体图块，可以通过创建备选图块并为该备选图块更改自定义数据来实现。<br>改变自定义数据的顺序不会损坏现有的元数据：TileSet 编辑器会在自定义数据属性的顺序发生改变后自动进行更新。</p>
<p>通过上面显示的自定义数据层示例，我们分配一个图块 ，将 damage_per_second 元数据设置为 25 ，将 destructible 元数据设置为 false ：<br>自定义数据也可以进行图块属性的绘制：</p>
<p>创建地形集（自动图块）<br>备注</p>
<p>这个功能和 Godot 3.x 中的自动图块使用了不同的实现方式。地形系统能够完全替代自动图块，功能也更强大。与自动图块不同，地形系统支持不同地形之间的过渡，这样就可以为同一个图定义多个地形。</p>
<p>与以前不同的是，自动图块是一种特定类型的图块，而地形只是分配给图集图块的一组属性。使用专门的 TileMap 绘制模式时就会用到这些属性，该模式能够对带有地形数据的图块进行智能选择。这意味着地形图块既可以作为地形绘制，也可以像其他图块一样作为单个图块绘制。</p>
<p>“完善”的图块集中通常会包含很多变体图块，适用于平台、地板等位置的角落和边缘。这种图块虽然可以手动放置，但是很快就会感觉非常麻烦。在程序式生成的关卡中如果要处理这种情况也很困难，需要编写大量的代码。</p>
<p>Godot 提供的地形系统就能够自动进行图块的连接。这样就可以自动使用“正确”的图块变体。</p>
<p>地形按照地形集分组。地形集有固定的模式，包括 Match Corners and Sides、Match Corners、Match sides（匹配角落和边缘、匹配角落、匹配边缘）。模式决定了地形集中的地形如何相互匹配。</p>
<p>备注</p>
<p>上述模式在 Godot 3.x 中对应的自动图块位掩码模式为 2×2、3×3、3×3 Minimal。也和 Tiled 编辑器中使用的模式类似。</p>
<p>选中 TileMapLayer 节点，转到检查器的 TileSet 资源中创建一个新的地形集：</p>
<p>创建地形集后，你必须在地形集中再创建若干地形：</p>
<p>在 TileSet 编辑器中，切换到“选择”模式并单击图块。在中间一栏展开地形部分，为图块分配地形集 ID 和地形 ID。-1 表示“没有地形集”和“没有地形”，因此你必须先将地形集设置为大于等于 0 的值，然后才能将地形设置为大于 0 的值。</p>
<p>备注<br>地形集 ID 和地形 ID 互相独立。从 0 开始，不从 1 开始。</p>
<p>完成此操作后，你现在可以配置地形邻接值（Terrain Peering Bits）部分，该部分在中间一列中可见。邻接值决定了根据相邻图块的情况放置哪个图块。-1 是一个特殊值，表示空白空间。</p>
<p>例如，如果一个地砖的所有位都设置为 0 或更大，那么只有在 所有 8个相邻图块都使用具有相同地形 ID 的图块时，它才会出现。如果图块的位设置为“0”或更大，但左上、上和右上的位设置为“-1”，则只有在其顶部（包括对角线）有空位时才会出现。</p>
<p>一次为多个图块指定属性<br>有两种方法可以同时为多个图块分配属性。根据你的使用情况，一种方法可能比另一种方法更快：</p>
<p>使用多个图块选择<br>如果希望一次在多个图块上配置多种属性，请选择 TileSet 编辑器顶部的 选择 模式：</p>
<p>完成此操作后，你可以按住 Shift 键，然后单击图块，在右侧栏中选择多个图块。你还可以按住鼠标左键然后拖动鼠标来执行矩形选择。最后，你可以按住 Shift 然后单击选定的图块，取消选择已选中的图块（不会影响选择的其他部分）。</p>
<p>然后，你可以使用 TileSet 编辑器中间一列的检查器分配属性。只有在此更改的属性才会应用到所有选定的图块。与编辑器的检查器一样，在你编辑之前，所选图块上的不同属性将保持不同。</p>
<p>对于数值和颜色属性，编辑完成后还能在图集中的所有图块上看到属性值的预览：</p>
<p>使用图块属性绘制<br>如果要一次将单个属性应用于多个图块，则可以使用<em>属性绘制</em>模式来实现此目的。</p>
<p>在中间一列配置要绘制的属性，然后点击右列中的图块（或按住鼠标左键）以将属性“绘制”到图块上。</p>
<p>对于手动设置耗时的属性（例如碰撞形状），图块属性绘制特别有用：</p>
<p>创建备选图块<br>有时，你想使用单一的图块图像（在图集中只能找到一次），但要以不同的方式进行配置。例如，你可能想使用相同的图块图像，但对它进行旋转、翻转或调制成不同的颜色。这就可以使用 备选图块 来实现。</p>
<p>小技巧</p>
<p>从 Godot 4.2 开始，你将不再必须通过创建替代图块来旋转或翻转图块。你可以使用 TileMap 编辑器工具栏中的旋转&#x2F;翻转按钮，在任何图块放置进 TileMap 编辑器中时旋转它。</p>
<p>要创建备选图块，请右键单击 TileSet 编辑器显示的图集中的基本图块，然后选择 创建备选图块：</p>
<p>如果当前处于“选择”模式，则可编辑已选中的备选图块。如果当前不在“选择”模式下，你仍然可以创建备选图块，但需要切换到“选择”模式并选择备选图块进行编辑。</p>
<p>如果看不到备选图块，请平移到图集图像的右侧，因为在 TileSet 编辑器中，备选图块总是出现在给定图集基础图块的右侧：</p>
<p>选择备选图块后，你可以使用中间一列更改任何属性，就像在基础图块上一样。但暴露的属性列表与基础图块不同：</p>
<p>备用 ID： 此可选图块的唯一数字标识符。更改它会破坏现有的瓦片地图，所以要小心！此 ID 还控制在编辑器中显示的可选图块列表中的排序。</p>
<p>渲染 &gt; 水平翻转： 如果 启用 ，则图块水平翻转。</p>
<p>渲染 &gt; 垂直翻转： 如果 启用 ，则图块垂直翻转。</p>
<p>渲染 &gt; 转置： 如果 启用 ，则图块将 逆时针 旋转 90 度，然后再垂直翻转。实际上，这意味着要将图块顺时针旋转 90 度而不翻转它，你应该启用 水平翻转 和 转置 。要将图块顺时针旋转 180 度，请启用 水平翻转 和 垂直翻转 。要将图块顺时针旋转 270 度，请启用 垂直翻转 和 转置 。</p>
<p>渲染 &gt; 纹理原点：绘制图块时使用的原点。可以用来将图块进行相对于基础图块的视觉偏移。</p>
<p>渲染 &gt; 调制：渲染图块时的颜色乘数。</p>
<p>渲染 &gt; 材质： 当前图块使用的材质。可以使用此选项为单个图块应用不同的混合模式或自定义着色器。</p>
<p>Z 索引： 当前图块的排序。数值大的图块会渲染在同一层中的其他图块之上。</p>
<p>Y 排序原点（Y Sort Origin）：基于其 Y 坐标（以像素为单位）进行图块排序时要使用的垂直偏移量。这使得可以将图层视为在不同高度上用于俯视角的游戏。调整此值可以帮助缓解某些图块排序的问题。仅当 CanvasItem &gt; Ordering 下的 TileMapLayer 图层的 Y Sort Enabled 为 启用 时才有效。</p>
<p>你可以通过点击在备选图块旁的大 “+” 图标来创建额外的 备选图块变体。这相当于选择基本图块并右键点击它以再次选择创建备选图块。</p>
<p>备注</p>
<p>当创建一个备选图块时，其基本图块的任何属性将不会被继承下来。如果你希望备选图块与基本图块的属性相同，那么你需要在备选图块中重新设置这些属性。</p>
<h4 id="使用-TileMap"><a href="#使用-TileMap" class="headerlink" title="使用 TileMap"></a>使用 TileMap</h4><p>图块地图是用于创建游戏布局的图块网格。使用 TileMapLayer 节点设计关卡有很多好处。首先, 它们可以通过将图块 “绘制” 到网格上来绘制布局，这比逐个放置单个 Sprite2D 节点要快得多；其次，它们允许更大的关卡，因为它们针对绘制大量图块进行了优化。最后，你可以为图块添加碰撞，遮挡和导航形状，从而为 TileMap 添加其他功能。</p>
<p>在 TileMapLayer 中指定 TileSet<br>如果你已经进行了上一页 使用 TileSet 所述的步骤，你现在应该有一个内嵌进 TileMapLayer 节点的 TileSet 资源。这样的做法适合制作原型，但在实际项目当中，你一般会有多个关卡复用同一个图块集。</p>
<p>要在多个 TileMapLayer 节点中复用同一个 TileSet ，建议将 TileSet 保存到外部资源。为此，请点击 TileSet 资源旁边的下拉菜单 ，然后选择 保存 ：</p>
<p>多 TileMapLayer 及相关设置<br>使用图块地图时，适当情况下通常建议使用多个TileMapLayer节点。使用多图层可以具有优势，例如，通过区分前景图块和背景图块来实现更好的组织。你可以每个图层放置一个图块在给定位置，如果你有不止一层就能实现多个图块的叠加。</p>
<p>每个TileMapLayer节点都有几个可以调整的属性：</p>
<p>Enabled：如果为 true，当前图层在编辑器中和运行项目时可见。</p>
<p>TileSet TileMapLayer 节点所使用的图块集。</p>
<p>渲染<br>Y Sort Origin： 每个图块在Y 轴排序时使用的垂直偏移量（以像素为单位）。仅在CanvasItem设置下 Y Sort Enabled 为 true 时有效。</p>
<p>X Draw Order Reversed Reverses the order tiles are drawn on the X axis. Requires that Y Sort Enabled under CanvasItem settings is true.</p>
<p>Rendering Quadrant Size 象限是为了优化目的而绘制在单个 CanvasItem 上的一组图块。此设置定义了地图坐标系中正方形边的长度。该象限大小不适用于 Y 排序的 TileMapLayer，因为在这种情况下图块是按 Y 位置分组的。</p>
<p>物理<br>Collision Enabled 启用或禁用碰撞。</p>
<p>Use Kinematic Bodies 当为 true 时，TileMapLayer 的碰撞形状将实例化为运动学刚体。</p>
<p>Collision Visibility Mode TileMapLayer的碰撞形状是否可见。如果设置为默认，则取决于显示碰撞的调试设置。</p>
<p>导航<br>Navigation Enabled（导航启用）是否启用导航区域。</p>
<p>Navigation Visible TileMapLayer 的导航网格是否可见。如果设置为默认，则取决于显示导航的调试设置。</p>
<p>小技巧<br>TileMap 内置导航存在许多实际限制，导致寻路性能和路径跟随质量较差。<br>在设计完 TileMap 后，考虑将其烘焙成一个更优化的导航网格（并禁用TileMap的NavigationLayer），使用 NavigationRegion2D 或 NavigationServer2D。查看 使用导航网格 以获取更多信息。</p>
<p>2D 导航网格不能像视觉元素或物理形状那样进行“分层”或彼此堆叠。尝试在同一导航地图上堆叠导航网格会导致合并和逻辑错误，破坏寻路功能。</p>
<p>重排序图层<br>你可以通过在场景选项卡中拖放节点来重新排序图层。你也可以使用 TileMap 编辑器右上角的按钮来切换正在操作的 TileMapLayer 节点。<br>创建，重命名或对图层进行排序时不会影响现有图块。但是请小心，在 移除 图层时也会同时移除该图层上所有的图块。</p>
<p>打开 TileMap 编辑器<br>选择 TileMapLayer 节点，将会打开编辑器底部的 TileMap 面板:<br>选择用于绘制的图块<br>首先，如果你在上面创建了其他图层，确保你已经选择了要绘制的目标图层：</p>
<p>在 2D 编辑器中，相同 TileMapLayer 节点下，非编辑中的图层将在 TileMap 编辑器里显示为灰色。你可以点击图层选择菜单旁边的图标（工具提示为高亮所选 TileMap 图层）来禁用此行为。</p>
<p>如果没有创建其他图层，可以跳过上述步骤，因为进入 TileMap 编辑器时会自动选择第一个图层。</p>
<p>在 2D 编辑器中放置图块之前，必须在编辑器底部的 TileMap 面板中选择一个或多个图块。为此，请单击 TileMap 面板中的图块，也可以按住鼠标选择多个图块：</p>
<p>与 2D 编辑器和 TileSet 编辑器中一样，你可以使用鼠标中键或右键在 TileMap 面板上平移，使用鼠标滚轮或左上角的按钮进行缩放。</p>
<p>你还可以按住 Shift 来追加到当前选择。在选择多个图块时，每次执行绘制操作都会放置多个图块。这可以用于在单次点击中绘制由多个图块组成的结构（例如大型平台或树木）。<br>最终的选择不必是连续的：如果在所选图块之间有空格，则将在2D编辑器中绘制的图案中留空。</p>
<p>如果在 TileSet 中创建了备选图块，则可以在基准图块的右侧选择它们进行绘制：</p>
<p>最后，如果在 TileSet 中创建了一个 场景集合（scenes collection） ，则可以在 TileMap 中放置场景图块：</p>
<p>绘制模式和工具<br>使用 TileMap 编辑器顶部的工具栏，你可以在几种绘画模式和工具之间进行选择。这些模式会影响在 2D 编辑器中点击时的操作，而 不 影响 TileMap 面板本身。</p>
<p>从左到右，可以选择的绘制模式和工具是：</p>
<p>选择<br>在2D编辑器中，可以通过单击单个图块或按住鼠标左键框选多个图块来选择。请注意，无法选择空白区域：如果创建了一个矩形选择，只会选择非空图块。</p>
<p>要追加到当前选择，按 Shift 键，然后选择一个图块。要从当前选择中删除，请按 Ctrl 键，然后选择一个图块。</p>
<p>然后可以在任何其他绘画模式下使用该选择来快速创建已放置模式的副本。</p>
<p>可以通过按 Del ，从 TileMap 中删除选定的图块。</p>
<p>在绘制模式下，可以通过按住 Ctrl 键然后进行选择来暂时切换到此模式。</p>
<p>你可以复制并粘贴已经放置的图块：选择图块，按 Ctrl+C 键，然后按 Ctrl+V 键，也可以通过左键单击将所选内容粘贴到图中。还可以按 Ctrl+V 键再次进行复制，右键单击或按 Escape 键可取消粘贴。</p>
<p>绘制<br>标准绘制模式允许你通过单击或按住鼠标左键来放置图块。</p>
<p>如果右键 单击，则当前选定的图块将从图块地图中删除。换句话说，它将被替换为空白区域。</p>
<p>如果你在 TileMap 中或使用选择工具选择了多个图块，则在按住鼠标左键的同时单击或拖动鼠标时，这些图块都将会被放置。</p>
<p>在绘制模式下，可以在按住鼠标左键之前按住 Shift，然后将鼠标拖动到线的终点来绘制一条线。这与使用下面描述的线条工具相同。</p>
<p>你还可以在按下鼠标左键之前，按住 Ctrl 和 Shift 键，然后拖动鼠标到矩形的终点，以此来绘制一个矩形。这与下面描述的矩形工具有异曲同工之妙。</p>
<p>最后，可以在 2D 编辑器中按住 Ctrl 键，然后点击一个图块，来选取现有的图块（或者按住不松并拖动鼠标）。这将把当前涂装的图块切换到你刚刚点击的图块。这与下面描述的 Picker 工具有相同的作用。</p>
<p>线段<br>在选择线条涂鸦模式之后，你可以绘制线条，线条始终为1个图块厚（与线条的方向无关）。</p>
<p>如果在“Line Paint”模式下单击鼠标右键，则将在直线中进行擦除。</p>
<p>如果在 TileMap 中或使用“选择”工具选择了多个图块，你可以将它们以重复图案的形式放置在一条直线上。</p>
<p>你可以在绘画或橡皮擦模式下按住 Shift 键然后绘制来临时切换此模式。</p>
<p>矩形<br>选择“矩形绘制”模式后，可以绘制轴对齐的矩形。</p>
<p>如果在“矩形绘制”模式下单击鼠标右键，将在轴对齐的矩形中进行擦除。</p>
<p>如果在 TileMap 中或使用“选择”工具选择了多个图块，则可以将它们放置在矩形内的重复图案中。</p>
<p>在“绘制”或“橡皮擦”模式下，你可以通过按住 Ctrl 和 Shift 然后绘图来临时切换此模式。</p>
<p>油漆桶填充<br>选择“油漆桶填充”模式后，可以通过切换工具栏右侧的连续复选框来选择是否仅将绘画限制在连续区域。</p>
<p>如果启用连续（默认启用），则只会替换与当前选择相匹配的图块。这种连续检查是水平和垂直执行的，但不是对角执行的。</p>
<p>如果禁用连续，则整个 TileMap 中具有相同 ID 的所有图块都将被当前选定的图块。如果在未选中连续的情况下选择一个空图块，则包含图块有效区域的矩形中的所有图块都将被替换。</p>
<p>如果在油漆桶填充模式下单击鼠标右键，则会将匹配的图块替换为空图块。</p>
<p>如果在TileMap中或使用“选择”工具选择了多个图块，则可以将它们放置在填充区域内的重复图案中。</p>
<p>拾取器<br>在选择“拾取器”模式后，你可以通过按住 Ctrl 并点击一个图块来选择 2D 编辑器中的现有图块。这将把当前绘制的图块切换到你刚刚点击的图块。你还可以通过按住左鼠标按钮并形成矩形选择来一次选择多个图块。只能选择非空图块。</p>
<p>在“绘制”模式下，你可以通过按住 Ctrl 然后单击或拖动鼠标来临时切换此模式。</p>
<p>橡皮<br>此模式可与任何其他绘制模式（“绘制”“直线”“矩形”“油漆桶填充”）组合使用。启用橡皮擦模式时，左键单击时，图块将被空图块替换，而不是绘制新线。</p>
<p>你可以在任何其他模式下通过右键而不是左键来临时切换此模式。</p>
<p>使用散布随机绘图<br>绘制时，可以选择启用 随机化（randomization） 。启用后，绘制时将在当前选定的所有图块之间选择一个随机图块。“绘制（Paint）”、“直线（Line）”、“矩形（Rectangle）”、“油漆桶填充（Bucket Fill)”工具都支持此操作。为了有效地进行绘制随机化，必须在 TileMap 编辑器中选择多个图块或使用散布（两种方法可以组合使用）。</p>
<p>如果将散布设置为大于 0 的值，则绘制时可能不会放置图块。这可以用于向大区域添加偶尔的、不重复的细节（例如在大型俯视角 TileMap 上添加草或碎屑）。</p>
<p>橡皮擦模式不考虑随机化和散射。选择范围内的所有图块始终被删除。</p>
<p>使用模式保存和加载预制的图块放置<br>当你可以在选择模式下复制和粘贴图块时，你可能希望保存图块的预制图案，以便一次放置在一起。这可以在每个 TileMap 的基础上通过选择 TileMap 编辑器的图案选项卡来完成。</p>
<p>要创建新模式，请切换到“选择”模式，执行选择并按 Ctrl+C。单击“图案”选项卡中的空白区域（空白区域周围应出现一个蓝色焦点矩形），然后按 Ctrl+V：</p>
<p>要使用现有图案，请在图案选项卡中单击其图像，切换到任何绘画模式，然后在 2D 编辑器中的某个位置左键单击：</p>
<p>与多图块选择一样，如果与“绘制（Paint）”“直线（Line）”“矩形（Rectangle）”“油漆桶填充（Bucket Fill)”绘画模式一起使用，图案将重复。</p>
<p>备注</p>
<p>尽管图案是在 TileMap 编辑器中编辑的，但它存储在 TileSet 资源中。这样允许在加载保存到外部文件的 TileSet 资源后，在不同的 TileMapLayer 节点中复用图案。</p>
<p>自动处理地形的图块连接<br>要使用地形，TileMapLayer 节点必须至少包含一个地形集和该地形集中的一个地形。如果尚未为 TileSet 创建地形集，请参考 创建地形集（自动图块） 。</p>
<p>地形连接有 3 种绘图模式可选：</p>
<p>连接 ，图块与相同 TileMapLayer 上的周围图块相连。</p>
<p>路径，图块会与相同笔画绘制出的图块相连（直到松开鼠标按键）。</p>
<p>图块特定的覆盖以解决冲突或处理地形系统未涵盖的情况。</p>
<p>“连接”模式更容易使用，但“路径”更灵活，因为它允许艺术家在绘制过程中进行更多控制。例如，“路径”可以让道路直接相邻而不相互连接，而“连接”则会强制两条道路相连。</p>
<p>最后，在某些情况下，你可以从地形中选择特定的图块来解决冲突：</p>
<p>任何至少有一个位（bit）设置为对应地形 ID 的值的图块将出现在可供选择的图块列表中。</p>
<p>处理缺失图块<br>如果删除 TileMap 所引用 TileSet 中的图块，TileMap 将显示一个占位符，表示放置的图块 ID 无效：</p>
<p>这些占位符在运行的项目中不可见，但图块数据仍会持久保存在磁盘中。这样你就可以安全地关闭和重新打开此类场景。重新添加具有匹配 ID 的图块后，图块将以新图块的外观出现。</p>
<p>备注</p>
<p>在选择 TileMapLayer 节点并打开 TileMap 编辑器之前，可能无法看到缺失的图块占位符。</p>
<h2 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h2><h3 id="3D-简介"><a href="#3D-简介" class="headerlink" title="3D 简介"></a>3D 简介</h3><p>坐标系<br>Godot 在 3D 中使用的都是公制，1 个单位等于 1 米。<br>物理和其他区域都为此而调整过。因此，试图使用不同的比例通常是一个坏主意（除非你知道你在做什么）。<br>使用 3D 资产时，最好始终使用正确的比例（在 3D 建模软件中将单位设置为公制）。Godot 允许在导入后缩放，尽管在大多数时都没问题，但在极少数情况下，会在渲染或物理等敏感区域带来浮点精度问题（从而导致故障或伪影）。所以，确保你的艺术家始终在正确的比例下进行创作！</p>
<p>X 是两边<br>Y 是上&#x2F;下<br>Z 是前&#x2F;后<br><img src="https://wzcwzc10.github.io/posts_img/godot/introduction_to_3d_coordinate_systems.webp" alt="坐标系"></p>
<p>一些有用的键盘绑定:<br>要吸附放置或旋转，在移动、缩放或旋转时按 Ctrl 键。<br>要将视图居中到所选对象上，请按 F。</p>
<p>在 3D 环境中导航<br>默认的3D场景导航控制类似于 Blender（旨在使免费软件开发流程中具有某种一致性），但在编辑器设置中也包含了自定义鼠标按钮和行为的选项，就仿佛使用其他工具那样。比如想修改成 Maya 或者 Modo 的控制逻辑，你可以打开 编辑器设置&gt;各编辑器&gt;3D 。然后在 导航 下，找到 导航方案 。</p>
<h3 id="使用-3D-变换"><a href="#使用-3D-变换" class="headerlink" title="使用 3D 变换"></a>使用 3D 变换</h3><h3 id="程序式几何体"><a href="#程序式几何体" class="headerlink" title="程序式几何体"></a>程序式几何体</h3><h3 id="3D-文本"><a href="#3D-文本" class="headerlink" title="3D 文本"></a>3D 文本</h3><h3 id="渲染-1"><a href="#渲染-1" class="headerlink" title="渲染"></a>渲染</h3><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h3 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h3><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="动画功能介绍"><a href="#动画功能介绍" class="headerlink" title="动画功能介绍"></a>动画功能介绍</h3><p>AnimationPlayer 节点允许你创建从简单到复杂的任何动画,动画的数据容器。<br>一个AnimationPlayer节点可以保存多个动画，这些动画可以自动相互过渡。<br>动画面板由四部分组成：</p>
<ol>
<li>动画控件(即添加，加载，保存和删除动画)</li>
<li>轨道列表</li>
<li>带有关键帧的时间轴</li>
<li>时间轴和轨道控件</li>
</ol>
<p>管理动画库<br>出于可复用性，动画被注册在动画库资源的列表中。如果你将动画添加到 AnimationPlayer 而不指定任何特定设置，则该动画将默认注册到 AnimationPlayer 具有的 [Global] 动画库中。<br>如果有多个动画库并且你尝试添加动画，则会出现一个包含选项的对话框。</p>
<p>轨道设置<br>每条属性轨道的末尾都有一个设置面板，可以用来设置更新模式、轨道插值和循环模式。<br>轨道的更新模式告诉 Godot 何时更新属性值。这可以是：<br>连续：每帧都更新属性<br>离散：仅在位于关键帧时更新属性<br>捕获：如果第一个关键帧的时间大于 0.0，就会记录该属性的当前值，并将其与第一个动画帧混合。例如，利用“捕获”模式，你可以将处于任意位置的节点移动到特定的位置。</p>
<p>在普通动画中，你通常使用“连续”。其他类型可用于编排复杂动画。<br>轨迹插值告诉 Godot 如何计算关键帧之间的帧值，支持的插值模式有：<br>临近：设置为最接近的关键帧的值<br>线性：使用线性函数计算两个关键帧之间的值<br>三次方：使用三次函数计算两个关键帧之间的值<br>线性角（仅出现在旋转属性中）：具有最短路径旋转的线性模式<br>三次角（仅出现在旋转属性中）：具有最短路径旋转的立方模式</p>
<p>利用三次插值，动画在关键帧处的速度较慢，而在关键帧之间的速度较快，从而使动作更加自然。立体插值常用于角色动画。线性插值以固定的速度进行动画变化，从而产生更加机械的效果。<br>Godot支持两种循环模式，如果将其设置为循环时，则会影响动画效果：<br>钳位循环插值: 选择此选项后，动画将在此轨道的最后一个关键帧之后停止. 再次到达第一个关键帧时，动画将重置为其值.<br>包循环插值: 当选择此项时,Godot会在最后一个关键帧之后计算动画，以再次达到第一个关键帧的值.</p>
<p>其他属性的关键帧<br>Godot的动画系统不仅限于位置、旋转和缩放。你可以对任何属性进行动画化。<br>如果你在动画面板可见时选择你的精灵，Godot 会在 检查器 中为精灵的每个属性显示一个小的关键帧按钮，点击这个按钮，Godot就会自动为当前动画添加一个轨道和关键帧。</p>
<p>编辑关键帧<br>你可以在动画时间轴上点击关键帧，以在<em>属性面板</em>中显示和编辑其值。<br>此外，你还可以通过点击并拖动关键帧的缓和曲线，在这里编辑关键帧的缓和值。这将告诉 Godot 在动画属性到达该关键帧时如何进行插值。<br>你可以通过这种方式调整动画，直到运动“看起来正确”。</p>
<p>使用 RESET 轨道<br>你可以设置一个特殊的 RESET（重置）动画来包含“默认姿势”。这样就可以保证在保存场景并重新在编辑器中打开时，会恢复默认姿势。<br>对于已存在的轨道，你可以添加一个名为“RESET”（大小写敏感）的动画，然后为每一个你希望重置的属性添加轨道。应该只在时间为 0 处存在一个关键帧，其值为每条轨道所期望的默认值。<br>如果 AnimationPlayer 的 Reset On Save（保存时重置）属性为 true，场景在保存时会应用重置动画的效果（相当于寻道到 0.0 时间点的效果）。只有保存的文件会受到影响——编辑器中的属性轨道还是会保持原样。<br>如果你想要在编辑器中重置轨道，请选中 AnimationPlayer 节点，打开 动画 底部面板，然后选择动画编辑器 动画 下拉菜单中的 应用重置 。<br>在检查器中使用属性旁边的关键帧图标时，编辑器会要求你自动创建 RESET 轨道。<br>RESET 轨道也用作混合的参考值。另请参阅为了更好地混合 。</p>
<p>洋葱皮<br>Godot 的动画编辑器允许你在创建动画时使用洋葱蒙皮。要启用此功能，请单击动画编辑器右上角的洋葱图标。此时，在动画对象先前位置将有透明红色副本显示出来。<br>与洋葱皮按钮相邻的三个圆点按钮可以打开一个下拉菜单，你可以用它来调整洋葱皮的工作方式，包括在未来的帧中使用洋葱皮的能力。</p>
<p>动画标记<br>动画标记可用于播放动画的特定部分，而不是整个动画。这是一个用例示例，有一个动画文件，其中一个角色执行两个不同的动作，并且项目需要整个动画，以及两个单独的动作。标记可以放置在时间轴上，而不是制作两个额外的动画，并且现在可以单独播放这两个动作。<br>要向动画添加标记，请右键单击时间轴上方的空间，然后选择 插入标记…。</p>
<p>所有标记都需要动画中的唯一名称。您还可以设置标记的颜色以改进组织。</p>
<p>要在两个标记之间播放动画部分，请使用 play_section_with_markers（） 和 play_section_with_markers_backwards（） 方法。如果未指定开始标记，则动画的开始是 使用，如果未指定结束标记，则使用动画的结束。</p>
<p>如果结束标记位于动画结束之后，则 AnimationPlayer 将限制部分的结束，使其不会超过动画的结束。</p>
<p>要预览两个标记之间的动画，请使用 Shift + Click 选择标记。选择两个时，它们之间的空格应以红色突出显示。</p>
<p>现在，所有播放动画按钮都将像所选区域是整个动画一样。 从开始播放动画（Play Animation from Start） 将第一个标记视为动画的开始，即 从结束向后播放动画（Play Animation Backwards from End） 将第二个标记视为结束，依此类推。</p>
<h3 id="动画轨道类型"><a href="#动画轨道类型" class="headerlink" title="动画轨道类型"></a>动画轨道类型</h3><h3 id="剪纸动画"><a href="#剪纸动画" class="headerlink" title="剪纸动画"></a>剪纸动画</h3><h3 id="2D-骨架"><a href="#2D-骨架" class="headerlink" title="2D 骨架"></a>2D 骨架</h3><h3 id="使用-AnimationTree"><a href="#使用-AnimationTree" class="headerlink" title="使用 AnimationTree"></a>使用 AnimationTree</h3><h3 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h3><h3 id="创建电影"><a href="#创建电影" class="headerlink" title="创建电影"></a>创建电影</h3><h2 id="资产管线"><a href="#资产管线" class="headerlink" title="资产管线"></a>资产管线</h2><h3 id="导入流程"><a href="#导入流程" class="headerlink" title="导入流程"></a>导入流程</h3><h3 id="导入图像"><a href="#导入图像" class="headerlink" title="导入图像"></a>导入图像</h3><h3 id="导入音频采样"><a href="#导入音频采样" class="headerlink" title="导入音频采样"></a>导入音频采样</h3><h3 id="导入翻译"><a href="#导入翻译" class="headerlink" title="导入翻译"></a>导入翻译</h3><h3 id="导入-3D-场景"><a href="#导入-3D-场景" class="headerlink" title="导入 3D 场景"></a>导入 3D 场景</h3><h3 id="3D-骨架重定向"><a href="#3D-骨架重定向" class="headerlink" title="3D 骨架重定向"></a>3D 骨架重定向</h3><h3 id="导出-3D-场景"><a href="#导出-3D-场景" class="headerlink" title="导出 3D 场景"></a>导出 3D 场景</h3><h3 id="Blender-ESCN-导出器"><a href="#Blender-ESCN-导出器" class="headerlink" title="Blender ESCN 导出器"></a>Blender ESCN 导出器</h3><h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><h3 id="音频总线"><a href="#音频总线" class="headerlink" title="音频总线"></a>音频总线</h3><p>Godot的音频引擎允许创建任意数量的音频总线, 并且可以向每个总线添加任意数量的效果处理器.<br>运行游戏的设备的硬件会限制总线的数量, 以及在性能开始下降之前可以使用的效果.</p>
<p>分贝标度<br>分贝(dB)标度是一个相对标度. 它等于声功率比的常用对数的20倍(20 × log10(P&#x2F;P&#x2F;0)).<br>每增&#x2F;减6分贝, 声幅就会加倍&#x2F;减半.12dB代表系数4,18dB代表系数8,20dB代表系数10,40dB代表系数100, 以此类推.<br>由于比例是对数的, 因此无法表示真零(无音频).<br>0 dB 是数字音频系统中可能的最大振幅. 这个限制不是人为的限制, 而是声音硬件的限制. 因振幅太高而无法完全反映在0dB以下的音频, 会产生一种被称为 削波 的失真.<br>为了避免削波，你应该调整混音，使master 总线（后面会有更多的介绍）永远不超过 0 dB。<br>低于0dB限制的每6dB, 声能就会 减半 . 这意味着-6dB的音量是0dB的一半. -12dB是-6dB的一半, 依此类推.<br>使用分贝时, -60dB和-80dB范围内的声音被认为是听不见的. 也就是说你的工作范围一般在-60dB和0dB之间.</p>
<p>音频总线(audio bus)音频通道 (audio channel)<br>音频总线可以在Godot 编辑器的底部面板中找到:<br>音频从扬声器播放出来之前通过的地方.<br>它可以 修改 和 重路由 音频数据.<br>音频总线有一个 VU表(播放声音时亮起的条形), 表示通过的信号的幅度.</p>
<p>最左边的总线是 主总线 .<br>此总线将混音输出到你的扬声器, 因此, 正如之前 分贝标度 部分所述, 请确保主总线中的混音水平永远低于 0 dB.<br>其余的音频总线可以灵活地进行路由.<br>在修改声音后, 它们会将其发送到左边的另一条总线上. 非主总线的目标总线可以被单独设置.<br>而右侧总线的音频会被路由至左侧总线, 这避免了无限循环.</p>
<h3 id="音频特效"><a href="#音频特效" class="headerlink" title="音频特效"></a>音频特效</h3><h3 id="音频流"><a href="#音频流" class="headerlink" title="音频流"></a>音频流</h3><h3 id="将游戏玩法与音频和音乐同步"><a href="#将游戏玩法与音频和音乐同步" class="headerlink" title="将游戏玩法与音频和音乐同步"></a>将游戏玩法与音频和音乐同步</h3><h3 id="使用麦克风录音"><a href="#使用麦克风录音" class="headerlink" title="使用麦克风录音"></a>使用麦克风录音</h3><h3 id="文本转语音"><a href="#文本转语音" class="headerlink" title="文本转语音"></a>文本转语音</h3><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><h3 id="导出项目"><a href="#导出项目" class="headerlink" title="导出项目"></a>导出项目</h3><h3 id="导出包、补丁、Mod"><a href="#导出包、补丁、Mod" class="headerlink" title="导出包、补丁、Mod"></a>导出包、补丁、Mod</h3><h3 id="功能标签"><a href="#功能标签" class="headerlink" title="功能标签"></a>功能标签</h3><h3 id="为-macOS-导出"><a href="#为-macOS-导出" class="headerlink" title="为 macOS 导出"></a>为 macOS 导出</h3><h3 id="在-macOS-上运行-Godot-应用"><a href="#在-macOS-上运行-Godot-应用" class="headerlink" title="在 macOS 上运行 Godot 应用"></a>在 macOS 上运行 Godot 应用</h3><h3 id="为-Windows-导出"><a href="#为-Windows-导出" class="headerlink" title="为 Windows 导出"></a>为 Windows 导出</h3><h3 id="Manually-changing-application-icon-for-Windows"><a href="#Manually-changing-application-icon-for-Windows" class="headerlink" title="Manually changing application icon for Windows"></a>Manually changing application icon for Windows</h3><h3 id="为-iOS-导出"><a href="#为-iOS-导出" class="headerlink" title="为 iOS 导出"></a>为 iOS 导出</h3><h3 id="为-Android-导出"><a href="#为-Android-导出" class="headerlink" title="为 Android 导出"></a>为 Android 导出</h3><h3 id="Android-的-Gradle-构建"><a href="#Android-的-Gradle-构建" class="headerlink" title="Android 的 Gradle 构建"></a>Android 的 Gradle 构建</h3><h3 id="为-Web-导出"><a href="#为-Web-导出" class="headerlink" title="为 Web 导出"></a>为 Web 导出</h3><h3 id="为专用服务器导出"><a href="#为专用服务器导出" class="headerlink" title="为专用服务器导出"></a>为专用服务器导出</h3><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><h2 id="文件与数据-I-O"><a href="#文件与数据-I-O" class="headerlink" title="文件与数据 I&#x2F;O"></a>文件与数据 I&#x2F;O</h2><h3 id="后台加载"><a href="#后台加载" class="headerlink" title="后台加载"></a>后台加载</h3><h3 id="Godot-项目中的文件路径"><a href="#Godot-项目中的文件路径" class="headerlink" title="Godot 项目中的文件路径"></a>Godot 项目中的文件路径</h3><h3 id="保存游戏"><a href="#保存游戏" class="headerlink" title="保存游戏"></a>保存游戏</h3><h3 id="运行时文件加载和保存"><a href="#运行时文件加载和保存" class="headerlink" title="运行时文件加载和保存"></a>运行时文件加载和保存</h3><h3 id="二进制序列化-API"><a href="#二进制序列化-API" class="headerlink" title="二进制序列化 API"></a>二进制序列化 API</h3><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><h3 id="游戏的国际化"><a href="#游戏的国际化" class="headerlink" title="游戏的国际化"></a>游戏的国际化</h3><h3 id="Localization-using-spreadsheets"><a href="#Localization-using-spreadsheets" class="headerlink" title="Localization using spreadsheets"></a>Localization using spreadsheets</h3><h3 id="区域设置代码"><a href="#区域设置代码" class="headerlink" title="区域设置代码"></a>区域设置代码</h3><h3 id="伪本地化"><a href="#伪本地化" class="headerlink" title="伪本地化"></a>伪本地化</h3><h2 id="输入处理"><a href="#输入处理" class="headerlink" title="输入处理"></a>输入处理</h2><h3 id="使用-InputEvent"><a href="#使用-InputEvent" class="headerlink" title="使用 InputEvent"></a>使用 InputEvent</h3><h3 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h3><h3 id="鼠标和输入坐标"><a href="#鼠标和输入坐标" class="headerlink" title="鼠标和输入坐标"></a>鼠标和输入坐标</h3><h3 id="自定义鼠标光标"><a href="#自定义鼠标光标" class="headerlink" title="自定义鼠标光标"></a>自定义鼠标光标</h3><h3 id="控制器、手柄和摇杆"><a href="#控制器、手柄和摇杆" class="headerlink" title="控制器、手柄和摇杆"></a>控制器、手柄和摇杆</h3><h3 id="处理退出请求"><a href="#处理退出请求" class="headerlink" title="处理退出请求"></a>处理退出请求</h3><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="向量数学"><a href="#向量数学" class="headerlink" title="向量数学"></a>向量数学</h3><h3 id="高等向量数学"><a href="#高等向量数学" class="headerlink" title="高等向量数学"></a>高等向量数学</h3><h3 id="矩阵与变换"><a href="#矩阵与变换" class="headerlink" title="矩阵与变换"></a>矩阵与变换</h3><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><h3 id="贝塞尔、曲线和路径"><a href="#贝塞尔、曲线和路径" class="headerlink" title="贝塞尔、曲线和路径"></a>贝塞尔、曲线和路径</h3><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><h3 id="2D-导航概述"><a href="#2D-导航概述" class="headerlink" title="2D 导航概述"></a>2D 导航概述</h3><h3 id="3D-导航概述"><a href="#3D-导航概述" class="headerlink" title="3D 导航概述"></a>3D 导航概述</h3><h3 id="使用-NavigationServer"><a href="#使用-NavigationServer" class="headerlink" title="使用 NavigationServer"></a>使用 NavigationServer</h3><h3 id="使用导航地图"><a href="#使用导航地图" class="headerlink" title="使用导航地图"></a>使用导航地图</h3><h3 id="使用导航区块"><a href="#使用导航区块" class="headerlink" title="使用导航区块"></a>使用导航区块</h3><h3 id="使用导航网格"><a href="#使用导航网格" class="headerlink" title="使用导航网格"></a>使用导航网格</h3><h3 id="使用-NavigationPath"><a href="#使用-NavigationPath" class="headerlink" title="使用 NavigationPath"></a>使用 NavigationPath</h3><h3 id="使用-NavigationPathQueryObject"><a href="#使用-NavigationPathQueryObject" class="headerlink" title="使用 NavigationPathQueryObject"></a>使用 NavigationPathQueryObject</h3><h3 id="使用-NavigationAgent"><a href="#使用-NavigationAgent" class="headerlink" title="使用 NavigationAgent"></a>使用 NavigationAgent</h3><h3 id="使用-NavigationObstacle"><a href="#使用-NavigationObstacle" class="headerlink" title="使用 NavigationObstacle"></a>使用 NavigationObstacle</h3><h3 id="使用-NavigationLink"><a href="#使用-NavigationLink" class="headerlink" title="使用 NavigationLink"></a>使用 NavigationLink</h3><h3 id="使用-NavigationLayer"><a href="#使用-NavigationLayer" class="headerlink" title="使用 NavigationLayer"></a>使用 NavigationLayer</h3><h3 id="导航调试工具"><a href="#导航调试工具" class="headerlink" title="导航调试工具"></a>导航调试工具</h3><h3 id="连接导航网格"><a href="#连接导航网格" class="headerlink" title="连接导航网格"></a>连接导航网格</h3><h3 id="支持不同角色类型"><a href="#支持不同角色类型" class="headerlink" title="支持不同角色类型"></a>支持不同角色类型</h3><h3 id="支持不同角色运动"><a href="#支持不同角色运动" class="headerlink" title="支持不同角色运动"></a>支持不同角色运动</h3><h3 id="支持不同角色区域权限"><a href="#支持不同角色区域权限" class="headerlink" title="支持不同角色区域权限"></a>支持不同角色区域权限</h3><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="高级多人游戏"><a href="#高级多人游戏" class="headerlink" title="高级多人游戏"></a>高级多人游戏</h3><ol>
<li><p>高层API vs 底层 API<br>Godot 始终支持通过 UDP、 TCP 和一些更高级别的协议（如 SSL 和 HTTP ）进行标准的低级网络连接。<br>使用 Godot 的高级网络 API，牺牲了对低级网络的一些细度控制，有更强的易用性。</p>
</li>
<li><p>中层抽象<br>Godot 使用了一个中间层级的 MultiplayerPeer 对象。不应直接创建这种对象，它被设计为由多个 C++ 实现所提供。</p>
</li>
</ol>
<p>这个对象扩展自 PacketPeer 类，继承了所有用于序列化、发送和接收数据的方法。<br>此外，该对象还添加了设置对等体、传输模式等方法。它还包括让你知道对等体何时连接或断开的信号。</p>
<p>这个类接口可以抽象出大多数类型的网络层、拓扑结构和库。<br>默认情况下，Godot 会提供一个基于 ENet 的实现（ENetMultiplayerPeer）、一个基于 WebRTC 的实现（WebRTCMultiplayerPeer）以及一个基于WebSocket的实现（WebSocketPeer），而该类接口可以用来实现移动 API（用于特设的 WiFi、蓝牙等）或自定义设备&#x2F;控制台中特定的网络 API。</p>
<p>但大多数常见情况下，不鼓励直接使用这个对象，因为 Godot 提供了更高级别的网络使用方法。<br>只有当游戏对较低级别的API有特殊需求的情况下，才使用该对象。</p>
<ol start="3">
<li>服务器托管的注意事项<br>托管服务器时，LAN 上的客户端可以使用内网 IP 地址进行连接，该地址的格式通常是 192.168.<em>.</em>。 非 LAN&#x2F;Internet 客户端无法访问此内部 IP 地址。</li>
</ol>
<p>在 Windows 中， 你可以在命令提示符中输入 ipconfig 命令， 在 macOS 中，你可以在终端中输入 ifconfig 命令，在 Linux 中，你可以在终端中输入 ip addr 命令，来找到你的内网 IP 地址。</p>
<p>如果你在自己的机器上托管了服务器，并且想让非内网客户端连接，那么你可能需要将服务器端口 转发 到你的路由器，由于大多数家用网络都使用 NAT 技术，因此转发服务器端口是让你的服务器能通过互联网访问的必经步骤。Godot 的高级多人 API 只使用 UDP 协议，所以你的端口转发也必须是 UDP 协议的端口，不能只转发 TCP 协议的端口。</p>
<p>在转发了 UDP 端口之后，你需要确保你的服务器使用这个端口。可以前往这个网站 <a target="_blank" rel="noopener" href="https://icanhazip.com/">https://icanhazip.com/</a>去查询你的公网 IP 地址，然后把这个公网 IP 地址发送给想联机到你服务器的互联网客户端即可。</p>
<p>Godot 的高级多人联机 API 使用的是一个修改过的 ENet，包含全 IPv6 支持。</p>
<p>网络初始化</p>
<h3 id="进行-HTTP-请求"><a href="#进行-HTTP-请求" class="headerlink" title="进行 HTTP 请求"></a>进行 HTTP 请求</h3><h3 id="HTTP-客户端类"><a href="#HTTP-客户端类" class="headerlink" title="HTTP 客户端类"></a>HTTP 客户端类</h3><h3 id="TLS-SSL-证书"><a href="#TLS-SSL-证书" class="headerlink" title="TLS&#x2F;SSL 证书"></a>TLS&#x2F;SSL 证书</h3><h3 id="Using-WebSockets"><a href="#Using-WebSockets" class="headerlink" title="Using WebSockets"></a>Using WebSockets</h3><h3 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><h3 id="3D-1"><a href="#3D-1" class="headerlink" title="3D"></a>3D</h3><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h2 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h2><h3 id="物理介绍"><a href="#物理介绍" class="headerlink" title="物理介绍"></a>物理介绍</h3><h3 id="Using-Jolt-Physics"><a href="#Using-Jolt-Physics" class="headerlink" title="Using Jolt Physics"></a>Using Jolt Physics</h3><h3 id="使用-RigidBody"><a href="#使用-RigidBody" class="headerlink" title="使用 RigidBody"></a>使用 RigidBody</h3><h3 id="使用-Area2D"><a href="#使用-Area2D" class="headerlink" title="使用 Area2D"></a>使用 Area2D</h3><h3 id="使用-CharacterBody2D-3D"><a href="#使用-CharacterBody2D-3D" class="headerlink" title="使用 CharacterBody2D&#x2F;3D"></a>使用 CharacterBody2D&#x2F;3D</h3><h3 id="发射射线"><a href="#发射射线" class="headerlink" title="发射射线"></a>发射射线</h3><h3 id="布娃娃系统"><a href="#布娃娃系统" class="headerlink" title="布娃娃系统"></a>布娃娃系统</h3><h3 id="运动学角色（2D）"><a href="#运动学角色（2D）" class="headerlink" title="运动学角色（2D）"></a>运动学角色（2D）</h3><h3 id="Using-SoftBody3D"><a href="#Using-SoftBody3D" class="headerlink" title="Using SoftBody3D"></a>Using SoftBody3D</h3><h3 id="碰撞形状（2D）"><a href="#碰撞形状（2D）" class="headerlink" title="碰撞形状（2D）"></a>碰撞形状（2D）</h3><h3 id="碰撞形状（3D）"><a href="#碰撞形状（3D）" class="headerlink" title="碰撞形状（3D）"></a>碰撞形状（3D）</h3><h3 id="大世界坐标"><a href="#大世界坐标" class="headerlink" title="大世界坐标"></a>大世界坐标</h3><h3 id="物理插值"><a href="#物理插值" class="headerlink" title="物理插值"></a>物理插值</h3><h3 id="物理问题的故障排除"><a href="#物理问题的故障排除" class="headerlink" title="物理问题的故障排除"></a>物理问题的故障排除</h3><h2 id="平台相关"><a href="#平台相关" class="headerlink" title="平台相关"></a>平台相关</h2><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h3 id="iOS-插件"><a href="#iOS-插件" class="headerlink" title="iOS 插件"></a>iOS 插件</h3><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h3 id="Godot-的游戏主机支持"><a href="#Godot-的游戏主机支持" class="headerlink" title="Godot 的游戏主机支持"></a>Godot 的游戏主机支持</h3><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="编辑器插件"><a href="#编辑器插件" class="headerlink" title="编辑器插件"></a>编辑器插件</h3><h3 id="在编辑器中运行代码"><a href="#在编辑器中运行代码" class="headerlink" title="在编辑器中运行代码"></a>在编辑器中运行代码</h3><h2 id="渲染-2"><a href="#渲染-2" class="headerlink" title="渲染"></a>渲染</h2><h3 id="使用视口"><a href="#使用视口" class="headerlink" title="使用视口"></a>使用视口</h3><h3 id="多分辨率"><a href="#多分辨率" class="headerlink" title="多分辨率"></a>多分辨率</h3><h3 id="修复抖动、卡顿和输入延迟"><a href="#修复抖动、卡顿和输入延迟" class="headerlink" title="修复抖动、卡顿和输入延迟"></a>修复抖动、卡顿和输入延迟</h3><h3 id="合成器"><a href="#合成器" class="headerlink" title="合成器"></a>合成器</h3><h3 id="渲染器"><a href="#渲染器" class="headerlink" title="渲染器"></a>渲染器</h3><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><h3 id="GDScript"><a href="#GDScript" class="headerlink" title="GDScript"></a>GDScript</h3><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><h3 id="着色器简介"><a href="#着色器简介" class="headerlink" title="着色器简介"></a>着色器简介</h3><h3 id="着色参考"><a href="#着色参考" class="headerlink" title="着色参考"></a>着色参考</h3><h3 id="你的第一个着色器"><a href="#你的第一个着色器" class="headerlink" title="你的第一个着色器"></a>你的第一个着色器</h3><h3 id="使用-VisualShader"><a href="#使用-VisualShader" class="headerlink" title="使用 VisualShader"></a>使用 VisualShader</h3><h3 id="使用计算着色器"><a href="#使用计算着色器" class="headerlink" title="使用计算着色器"></a>使用计算着色器</h3><h3 id="屏幕读取着色器"><a href="#屏幕读取着色器" class="headerlink" title="屏幕读取着色器"></a>屏幕读取着色器</h3><h3 id="将-GLSL-转换为-Godot-着色器"><a href="#将-GLSL-转换为-Godot-着色器" class="headerlink" title="将 GLSL 转换为 Godot 着色器"></a>将 GLSL 转换为 Godot 着色器</h3><h3 id="着色器风格指南"><a href="#着色器风格指南" class="headerlink" title="着色器风格指南"></a>着色器风格指南</h3><h3 id="使用-SubViewport-作为纹理"><a href="#使用-SubViewport-作为纹理" class="headerlink" title="使用 SubViewport 作为纹理"></a>使用 SubViewport 作为纹理</h3><h3 id="自定义后期处理"><a href="#自定义后期处理" class="headerlink" title="自定义后期处理"></a>自定义后期处理</h3><h3 id="高级后期处理"><a href="#高级后期处理" class="headerlink" title="高级后期处理"></a>高级后期处理</h3><h3 id="树木的制作"><a href="#树木的制作" class="headerlink" title="树木的制作"></a>树木的制作</h3><h2 id="用户界面（UI）"><a href="#用户界面（UI）" class="headerlink" title="用户界面（UI）"></a>用户界面（UI）</h2><h3 id="UI-构件"><a href="#UI-构件" class="headerlink" title="UI 构件"></a>UI 构件</h3><h4 id="大小和锚点"><a href="#大小和锚点" class="headerlink" title="大小和锚点"></a>大小和锚点</h4><p>不同分辨率摆放控件不容易，需要考虑不同的宽高比、分辨率和用户缩放比例。<br>怎么弄？<br>通过编辑控件的<strong>锚点偏移量</strong>来实现，其行为类似于边距。<br>要访问这些设置，需要先选择<strong>自定义</strong>锚点预设。</p>
<p>每个控件都有四个边距：左、右、底、顶，分别与控件的边缘相对应。<br>都表示相对于父控件的左上角或视口（在没有父控件的情况下）的像素距离。</p>
<p>要使控件变宽，可以增大右边距和&#x2F;或减小左边距。这使你可以设置控件的精确位置和形状。</p>
<p>锚点属性调整偏移量相对于的位置 。每个偏移都有一个单独的锚点，可以从父项的开始到结束进行调整。因此，垂直（顶部、底部）锚点从 0.0（父级的顶部）调整为 1.0（父级的底部）， 其中 0.5 为中心，并且控制偏移量将相对于该点放置。水平（左、右）锚点类似地从父项的左到右调整。</p>
<p>请注意，当你希望控件的边缘位于锚点的上方或左侧时，必须将边距值更改为负数。</p>
<p>使控件居中<br>要将控件在其父控件内居中，请将锚点都设置为 0.5， 每侧边距为其相关尺寸的一半。例如， 下面的代码显示了如何将 TextureRect 在它的父节点内居中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var rect = TextureRect.new()</span><br><span class="line">rect.texture = load(&quot;res://icon.png&quot;)</span><br><span class="line">rect.anchor_left = 0.5</span><br><span class="line">rect.anchor_right = 0.5</span><br><span class="line">rect.anchor_top = 0.5</span><br><span class="line">rect.anchor_bottom = 0.5</span><br><span class="line">var texture_size = rect.texture.get_size()</span><br><span class="line">rect.offset_left = -texture_size.x / 2</span><br><span class="line">rect.offset_right = texture_size.x / 2</span><br><span class="line">rect.offset_top = -texture_size.y / 2</span><br><span class="line">rect.offset_bottom = texture_size.y / 2</span><br><span class="line">add_child(rect)</span><br></pre></td></tr></table></figure>
<p>将每个锚定值设置为0.5, 将边缘的参考点移动到父锚点的中心. 在此基础上, 我们设置了负边距, 以便控件获得其自然大小.</p>
<p>布局预设<br>除了手动调整边距和锚点的值之外，你还可以使用视口上方工具栏中的“布局”菜单。其中有居中等诸多选项，可以用来对齐并调整节点的大小。</p>
<h3 id="GUI-外观与主题"><a href="#GUI-外观与主题" class="headerlink" title="GUI 外观与主题"></a>GUI 外观与主题</h3><p>虽然 Control 节点具有开箱即用的功能外观，但始终有独特性和特定于案例的调整空间。<br>为此，Godot 引擎包括一个用于 GUI 换肤（或主题化）的系统，它允许你自定义用户界面中每个控件的外观，包括你的自定义控件。<br>下面是这个系统的一个例子—— 一个游戏的 GUI 与引擎的默认 UI 主题完全不同：<br>除了为你的游戏实现独特的外观外，该系统还使开发人员能够为最终用户提供自定义选项，包括交互设置。 UI 主题以级联方式应用（即从父控件传播到其子控件），这意味着色盲用户的字体设置或调整，可以在从某处应用并影响整个 UI 树。当然，这个系统也可以用于游戏：基于英雄的游戏可以为选定的玩家角色改变其风格，或者你可以为基于团队的项目中的双方赋予不同的风格。</p>
<p>主题基础知识<br>皮肤系统由 Theme 资源驱动。每个 Godot 项目都有一个固有的默认主题，其中包含内置控制节点使用的设置。这就是使控件具有开箱即用的独特外观的原因。然而，主题仅用于描述配置，并且每个单独控件的工作仍然是按照显示自身所需的方式使用该配置。在实现 你自己的自定义控件时要记住这一点很重要。</p>
<p>备注<br>甚至 Godot 编辑器本身也依赖于默认主题。但它看起来与 Godot 项目不同，因为它在默认主题之上应用了自己高度定制的主题。原则上，这与在你的游戏中的工作方式完全相同，如下所述。</p>
<p>主题项目<br>存储在一个主题中的配置由主题项目组成。每个项目都有一个唯一的名称，并且必须是以下数据类型之一：</p>
<ol>
<li>color 值</li>
<li>常量，整型值，可用于控件的数字类型属性（例如 BoxContainer 的间隙设置）或布尔值标记（例如 Tree 中是否绘制关系线条）。</li>
<li>字体（font），常常被用于显示控件中的文字。字体包含了许多渲染设置，像字体的大小和颜色。之后呢，用另一个单独的控件来控制对齐属性和文字方向。</li>
<li>Font size整数值，与字体一同使用，决定文本显示的大小。</li>
<li>图标，纹理资源，通常用于显示图标。</li>
<li>样式盒<br>一个样式盒资源（StyleBox），是一个用来定义一个UI面板怎样展示的配置项集合。不只是用于面板控件（Panel），它还常常用于许多控件的背景设置和遮罩设置。<br>不同的控件将以不同的方式应用 StyleBox。尤其是 焦点样式框被绘制为其他样式框的覆盖层（例如 normal 或按下 ）以允许基本样式框保持可见。这意味着焦点样式框应设计为轮廓或半透明框，以便其背景保持可见。</li>
</ol>
<p>主题类型<br>为了更好地组织一个主题的结构，主题中的项目被划分为多个类型，并且每个项目只能属于单个类型。每个主题项目由其名称、数据类型和主题中的类型这个三元组来定义。这个三元组在主题中必须是唯一的。例如，Label 类型中不能有两个叫做 font_color 的颜色项目，但是在 LineEdit 类型中可以有另一个叫做 font_color 的项目。</p>
<p>Godot 的默认主题诞生之初就已经定义了众多的主题类型，它内建于每个使用了 UI 皮肤的控件节点中。在默认主题里上述例子都是目前再用的主题项目。你可以在每个控件的类参考手册中查看主题属性区域看看哪些项目是父类和子类都可用的。</p>
<p>子类可以使用为其父类定义的主题项，Button 及其派生类型就是很好实例。事实上，如果需要的话，每个控件都可以使用任何主题类型的单个主题项，但为了清晰可控，在引擎中尽量避免这样做。<br>牢记子类中，哪些过程是自动执行的很重要.不论什么时候内建控件在主题里面请求主题项目时，我们可以忽略主题类型仅通过它的类名知悉。之后呢，下次时我们能根据它的父级类名来使用.可以通过改变父级类，例如 Button，来影响所有派生类，而不是调整每一个类来实现。</p>
<p>还可以定义自己的主题类型，并另外自定义内置控件和您自己的控件。由于内置控件不知道自定义主题类型，因此必须使用脚本来访问这些项。所有控制节点都有多种方法，允许您从应用于它们的主题中获取主题项。这些方法接受主题类型作为参数之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var accent_color = get_theme_color(&quot;accent_color&quot;, &quot;MyType&quot;)</span><br><span class="line">label.add_theme_color_override(&quot;font_color&quot;, accent_color)</span><br></pre></td></tr></table></figure>
<p>为了提供更多的自定义可能性，类型还能够链接在一起成为变种。这是自定义主题类型的另一种使用场景。例如，主题可以包含 Header 类型，标记为基础 Label 类型的变种。那么各个 Label 控件就可以将其类型设为使用 Header 变种，主题请求主题项目的时候，这个变种都会先于其他类型使用。这样就可以在同一个 Theme 资源里为同样使用某个类的控件节点保存不同主题项目的预设值。</p>
<p>警告<br>只有默认主题或者自定义项目主题中的变种才会在“检查器”中列为可选项。在这两处之外定义的变种名称仍然可以手动输入，但是建议把所有变种都放到项目主题里面。</p>
<p>自定义控件<br>可以不用主题直接对各个控件节点进行自定义。这种方式称为本地重载。控件的类参考手册中列出的每个主题属性，无论是通过检查器面板还是脚本，都可以在该控件上直接重载。这样就可以针对 UI 中的特定部份进行精细的修改，不影响项目中包括该控件子类在内的其他内容。</p>
<p>本地重载对于提升用户界面的美观程度意义不大，如果你注重一致性的话就更是如此。然而，本地重载对于布局节点而言是不可或缺的。BoxContainer 和 GridContainer 等节点通过主题常量定义其子节点的间隙大小，MarginContainer 用主题项目来保存自定义边距。<br>控件存在本地主题项目重载时，会直接使用这个值，主题中所提供的值会被忽略。</p>
<p>自定义项目<br>所有全新项目使用的都是 Godot 提供的默认项目主题。默认主题本身是常量，无法修改，但可以通过自定义主题进行覆盖。设置自定义主题有两种方法：修改项目设置，或者修改场景树控件节点的节点属性。</p>
<p>There are two project settings that can be adjusted to affect your entire project: GUI &gt; Theme &gt; Custom allows you to set a custom project-wide theme, and GUI &gt; Theme &gt; Custom Font does the same to the default fallback font. When a theme item is requested by a control node the custom project theme, if present, is checked first. Only if it doesn’t have the item the default theme is checked.<br>可以调整两个项目设置以影响整个项目： GUI &gt; 主题 &gt; 自定义允许您设置自定义项目范围的主题， 以及 GUI &gt; 主题 &gt; 自定义字体 对默认回退字体执行相同的作。当控件请求主题项时 节点自定义项目主题（如果存在）将首先检查。只有当它没有 选中默认主题的项目。</p>
<p>在一个单独的主题资源中，你可以设置所有 Godot 控件的默认样式与外观,但是你可以做更多的细节调整.每一个控件节点同样拥有一个主题属性，通过这个属性你可以为一个控件的所有节点分支设置一个自定义的主题.那意味着那个控件与其所有的子类，和子类的子类，在回滚当前项目和默认主题之前自定义主题的资源将第一个被检查。</p>
<p>备注</p>
<p>计划设定作为一种变化的替代手段，可以让你通过设置自定义主题资源对几乎整个UI分支中的根控件节点做出相同的影响. 然而运行计划项目时可以充当预期效果展示,当单独场景直接预览或者运行时还将使用默认主题展示。为了解决这个问题你可以为每一个单独场景中的根控件设置相同的主题资源.</p>
<p>例如，你可以在项目主题中为按钮设置特定的样式，希望在弹出对话框中的按钮又有不同的外观。你可以为弹出窗口的根控件设置自定义主题资源，并在该资源中为按钮定义不同的样式。只要弹出窗口的根控件和按钮之间的节点链不中断，这些按钮就会使用最接近它们的主题资源中定义的样式。所有其他控件仍将使用整个项目的主题和默认的主题样式。</p>
<p>综上所述，对于任意控件，其主题项的查找会是这样的：</p>
<p>检查相同数据类型和名称的本地重写。</p>
<p>使用控件的类型变体、类名和父类名：</p>
<p>从自身开始检查每个控件，看看它是否设置了主题属性；</p>
<p>如果设置了，就在该主题中查找名称、数据、主题类型都相同的项目；</p>
<p>如果没有自定义主题，或者主题中没有匹配的条目，就前往父控件；</p>
<p>重复步骤 a 至 c，到场景树的根节点或者非控件节点为止。</p>
<p>如果存在项目范围的主题，就在这个主题中查找控件的类型变体、类名和父类名。</p>
<p>在默认主题中查找控件的类型变体、类名和父类名。</p>
<p>即便所有主题中都不存在对应的项目，也会返回一个针对该数据类型的默认值。</p>
<p>超越控件<br>主题是一种用来保存视觉效果配置的理想资源，也非常合理。虽然其他节点并没有像控件节点一样内置针对主题的支持，但还是可以和使用其他资源一样来使用主题。</p>
<p>举个非控件使用主题的例子：在策略游戏中，相同单位需要根据队伍的不同而使用不同颜色的精灵。可以在主题资源中定义颜色的合集，精灵（在脚本的帮助下）就可以使用这些颜色来绘制纹理。这样做的最大好处是可以为红绿蓝队制作不同的主题但使用相同的主题项目，切换队伍只需要替换资源就可以了。</p>
<h3 id="控件节点教程"><a href="#控件节点教程" class="headerlink" title="控件节点教程"></a>控件节点教程</h3><p>主题编辑器是底部面板工具，当一个 Theme 资源被选中进行编辑时，面板会自动激活。面板包含了添加、删除和调整主题类型和主题项目的必要用户界面。面板有一个预览区，用于测试你做出的变化，以及一个窗口对话框，用于对主题项目进行批量操作。</p>
<h2 id="XR"><a href="#XR" class="headerlink" title="XR"></a>XR</h2><h3 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h3><p>内置了一套模块化扩展现实（XR）系统，该系统通过抽象化不同 XR 平台的底层实现细节，以简化跨平台 XR 应用的开发流程。<br>该系统的核心是 XRServer 类，它作为整个 XR 架构的中枢接口，允许开发者通过该接口发现并连接各类 XR 运行时环境。</p>
<h3 id="高级专题"><a href="#高级专题" class="headerlink" title="高级专题"></a>高级专题</h3><h3 id="Godot-XR-工具"><a href="#Godot-XR-工具" class="headerlink" title="Godot XR 工具"></a>Godot XR 工具</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wzcwzc10.github.io">微光zc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/">https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wzcwzc10.github.io" target="_blank">微光zc的网络小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Godot/">Godot</a><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/%E6%96%87%E6%A1%A3/">文档</a></div><div class="post-share"><div class="social-share" data-image="/./img/jufufu-ht.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>来一杯燃油饮</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/08/14/Godot4.4%20%E7%B1%BB%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/" title="Godot4.4 类参考总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Godot4.4 类参考总结</div></div><div class="info-2"><div class="info-item-1">Godot4.4 类参考总结</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/14/Godot4.4%20%E7%B1%BB%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/" title="Godot4.4 类参考总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-14</div><div class="info-item-2">Godot4.4 类参考总结</div></div><div class="info-2"><div class="info-item-1">Godot4.4 类参考总结</div></div></div></a><a class="pagination-related" href="/2025/08/10/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%9C%89%E6%84%9F%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/" title="读Godot4.4文档有感（长期更新）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-10</div><div class="info-item-2">读Godot4.4文档有感（长期更新）</div></div><div class="info-2"><div class="info-item-1">读Godot4.4文档有感</div></div></div></a><a class="pagination-related" href="/2025/08/02/Godot%20IP%E5%9C%B0%E5%9D%80P2P%E8%81%94%E6%9C%BA/" title="Godot IP地址P2P联机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-02</div><div class="info-item-2">Godot IP地址P2P联机</div></div><div class="info-2"><div class="info-item-1">Godot IP地址P2P联机</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/jufufu-ht.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">微光zc</div><div class="author-info-description">一个有想法的极客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/178083315"><i class="fab fa-bilibili"></i><span>关注我！</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">世界全剧终，欢迎来到my blog！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%8C"><span class="toc-number">1.</span> <span class="toc-text">手册</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.1.</span> <span class="toc-text">最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Godot-%E4%B8%AD%E5%BA%94%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.1.</span> <span class="toc-text">在 Godot 中应用面向对象原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">场景组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E5%9C%B0%E5%BB%BA%E7%AB%8B%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">如何有效地建立关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%8A%82%E7%82%B9%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">选择节点树结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E8%84%9A%E6%9C%AC"><span class="toc-number">1.1.3.</span> <span class="toc-text">何时使用场景与脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">匿名类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">命名的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Script-%E4%B8%8E-PackedScene-%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">Script 与 PackedScene 的性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%B8%B8%E8%A7%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">自动加载与常规节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E5%89%B2%E9%9F%B3%E9%A2%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">切割音频问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E6%88%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">管理共享功能或数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%BA%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">何时应使用自动加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BB%BB%E4%BD%95%E4%BA%8B%E6%83%85%E4%BD%BF%E7%94%A8%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.5.</span> <span class="toc-text">何时以及如何避免为任何事情使用节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.6.</span> <span class="toc-text">Godot 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">获取对象引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E6%88%96%E9%80%BB%E8%BE%91"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">从对象访问数据或逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-%E9%80%9A%E7%9F%A5"><span class="toc-number">1.1.7.</span> <span class="toc-text">Godot 通知</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-process%E3%80%81-physics-process%E3%80%81-input"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">对比 _process、_physics_process、*_input</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-init%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E5%AF%BC%E5%87%BA"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">对比 _init、初始化、导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-ready%E3%80%81-enter-tree%E3%80%81NOTIFICATION-PARENTED"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">对比 _ready、_enter_tree、NOTIFICATION_PARENTED</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%81%8F%E5%A5%BD"><span class="toc-number">1.1.8.</span> <span class="toc-text">数据偏好</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E3%80%81%E5%AF%B9%E8%B1%A1%EF%83%81"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">数组、字典、对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%9A%E6%95%B4%E6%95%B0-VS-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">枚举：整数 VS 字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnimatedTexture-vs-AnimatedSprite2D-vs-AnimationPlayer-vs-AnimationTree"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%81%8F%E5%A5%BD"><span class="toc-number">1.1.9.</span> <span class="toc-text">逻辑偏好</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E8%BF%98%E6%98%AF%E5%85%88%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">先添加节点还是先修改属性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-VS-%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">加载 VS 预加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%9E%8B%E5%85%B3%E5%8D%A1%EF%BC%9A%E9%9D%99%E6%80%81-VS-%E5%8A%A8%E6%80%81"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">大型关卡：静态 VS 动态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.10.</span> <span class="toc-text">项目组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">风格指南</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5"><span class="toc-number">1.1.10.3.</span> <span class="toc-text">导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F"><span class="toc-number">1.1.10.4.</span> <span class="toc-text">大小写敏感</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.11.</span> <span class="toc-text">版本控制系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-number">1.2.</span> <span class="toc-text">故障排除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.</span> <span class="toc-text">编辑器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E7%95%8C%E9%9D%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">编辑器的界面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">项目管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inspector-Dock"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Inspector Dock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">项目设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">脚本编辑器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E9%BB%98%E8%AE%A4%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">编辑器默认快捷键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%95%8C%E9%9D%A2"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">自定义界面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XR-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">XR 编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">Android 编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">Web 编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.5.</span> <span class="toc-text">高级功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%95%99%E7%A8%8B"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">命令行教程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">使用外部的文本编辑器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%BC%96%E8%BE%91%E5%99%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.6.</span> <span class="toc-text">管理编辑器功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2D"><span class="toc-number">1.4.</span> <span class="toc-text">2D</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2D-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">2D 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E5%B8%83%E5%B1%82"><span class="toc-number">1.4.2.</span> <span class="toc-text">画布层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%94%BB%E5%B8%83%E5%8F%98%E6%8D%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">视口变换与画布变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%BB%E5%B8%83%E5%8F%98%E6%8D%A2"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">画布变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E4%BC%B8%E5%8F%98%E6%8D%A2"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">拉伸变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%8F%98%E6%8D%A2"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">窗口变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">变换顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">变换函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">提供自定义输入事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">1.4.4.</span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E7%81%AF%E5%85%89%E5%92%8C%E9%98%B4%E5%BD%B1"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">2D 灯光和阴影</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E7%BD%91%E6%A0%BC"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">2D 网格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E7%B2%BE%E7%81%B5%E5%8A%A8%E7%94%BB"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">2D 精灵动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">2D 粒子系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParticleProcessMaterial-2D-%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">ParticleProcessMaterial 2D 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="toc-number">1.4.4.6.</span> <span class="toc-text">2D 抗锯齿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%9B%BE"><span class="toc-number">1.4.4.7.</span> <span class="toc-text">2D 中的自定义绘图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E8%A7%86%E5%B7%AE"><span class="toc-number">1.4.4.8.</span> <span class="toc-text">2D 视差</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E4%B8%8E%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text">物理与移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">1.4.6.</span> <span class="toc-text">工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-TileSet"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">使用 TileSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-TileMap"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">使用 TileMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3D"><span class="toc-number">1.5.</span> <span class="toc-text">3D</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">3D 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-3D-%E5%8F%98%E6%8D%A2"><span class="toc-number">1.5.2.</span> <span class="toc-text">使用 3D 变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%BC%8F%E5%87%A0%E4%BD%95%E4%BD%93"><span class="toc-number">1.5.3.</span> <span class="toc-text">程序式几何体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-%E6%96%87%E6%9C%AC"><span class="toc-number">1.5.4.</span> <span class="toc-text">3D 文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93-1"><span class="toc-number">1.5.5.</span> <span class="toc-text">渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.6.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7-1"><span class="toc-number">1.5.7.</span> <span class="toc-text">工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">1.6.</span> <span class="toc-text">动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.1.</span> <span class="toc-text">动画功能介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E8%BD%A8%E9%81%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">动画轨道类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AA%E7%BA%B8%E5%8A%A8%E7%94%BB"><span class="toc-number">1.6.3.</span> <span class="toc-text">剪纸动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2D-%E9%AA%A8%E6%9E%B6"><span class="toc-number">1.6.4.</span> <span class="toc-text">2D 骨架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-AnimationTree"><span class="toc-number">1.6.5.</span> <span class="toc-text">使用 AnimationTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91"><span class="toc-number">1.6.6.</span> <span class="toc-text">播放视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%B5%E5%BD%B1"><span class="toc-number">1.6.7.</span> <span class="toc-text">创建电影</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%BA%BF"><span class="toc-number">1.7.</span> <span class="toc-text">资产管线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">导入流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%9B%BE%E5%83%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">导入图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E9%9F%B3%E9%A2%91%E9%87%87%E6%A0%B7"><span class="toc-number">1.7.3.</span> <span class="toc-text">导入音频采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E7%BF%BB%E8%AF%91"><span class="toc-number">1.7.4.</span> <span class="toc-text">导入翻译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-3D-%E5%9C%BA%E6%99%AF"><span class="toc-number">1.7.5.</span> <span class="toc-text">导入 3D 场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-%E9%AA%A8%E6%9E%B6%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.7.6.</span> <span class="toc-text">3D 骨架重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA-3D-%E5%9C%BA%E6%99%AF"><span class="toc-number">1.7.7.</span> <span class="toc-text">导出 3D 场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Blender-ESCN-%E5%AF%BC%E5%87%BA%E5%99%A8"><span class="toc-number">1.7.8.</span> <span class="toc-text">Blender ESCN 导出器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91"><span class="toc-number">1.8.</span> <span class="toc-text">音频</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E6%80%BB%E7%BA%BF"><span class="toc-number">1.8.1.</span> <span class="toc-text">音频总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E7%89%B9%E6%95%88"><span class="toc-number">1.8.2.</span> <span class="toc-text">音频特效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E6%B5%81"><span class="toc-number">1.8.3.</span> <span class="toc-text">音频流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E4%B8%8E%E9%9F%B3%E9%A2%91%E5%92%8C%E9%9F%B3%E4%B9%90%E5%90%8C%E6%AD%A5"><span class="toc-number">1.8.4.</span> <span class="toc-text">将游戏玩法与音频和音乐同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BA%A6%E5%85%8B%E9%A3%8E%E5%BD%95%E9%9F%B3"><span class="toc-number">1.8.5.</span> <span class="toc-text">使用麦克风录音</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E8%BD%AC%E8%AF%AD%E9%9F%B3"><span class="toc-number">1.8.6.</span> <span class="toc-text">文本转语音</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.</span> <span class="toc-text">导出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.9.1.</span> <span class="toc-text">导出项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%8C%85%E3%80%81%E8%A1%A5%E4%B8%81%E3%80%81Mod"><span class="toc-number">1.9.2.</span> <span class="toc-text">导出包、补丁、Mod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%A0%87%E7%AD%BE"><span class="toc-number">1.9.3.</span> <span class="toc-text">功能标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-macOS-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.4.</span> <span class="toc-text">为 macOS 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-macOS-%E4%B8%8A%E8%BF%90%E8%A1%8C-Godot-%E5%BA%94%E7%94%A8"><span class="toc-number">1.9.5.</span> <span class="toc-text">在 macOS 上运行 Godot 应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-Windows-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.6.</span> <span class="toc-text">为 Windows 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Manually-changing-application-icon-for-Windows"><span class="toc-number">1.9.7.</span> <span class="toc-text">Manually changing application icon for Windows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-iOS-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.8.</span> <span class="toc-text">为 iOS 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-Android-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.9.</span> <span class="toc-text">为 Android 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-%E7%9A%84-Gradle-%E6%9E%84%E5%BB%BA"><span class="toc-number">1.9.10.</span> <span class="toc-text">Android 的 Gradle 构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-Web-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.11.</span> <span class="toc-text">为 Web 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.12.</span> <span class="toc-text">为专用服务器导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2"><span class="toc-number">1.9.13.</span> <span class="toc-text">一键部署</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E6%95%B0%E6%8D%AE-I-O"><span class="toc-number">1.10.</span> <span class="toc-text">文件与数据 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.10.1.</span> <span class="toc-text">后台加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-number">1.10.2.</span> <span class="toc-text">Godot 项目中的文件路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F"><span class="toc-number">1.10.3.</span> <span class="toc-text">保存游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98"><span class="toc-number">1.10.4.</span> <span class="toc-text">运行时文件加载和保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96-API"><span class="toc-number">1.10.5.</span> <span class="toc-text">二进制序列化 API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">1.11.</span> <span class="toc-text">国际化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E7%9A%84%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">1.11.1.</span> <span class="toc-text">游戏的国际化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Localization-using-spreadsheets"><span class="toc-number">1.11.2.</span> <span class="toc-text">Localization using spreadsheets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81"><span class="toc-number">1.11.3.</span> <span class="toc-text">区域设置代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="toc-number">1.11.4.</span> <span class="toc-text">伪本地化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86"><span class="toc-number">1.12.</span> <span class="toc-text">输入处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-InputEvent"><span class="toc-number">1.12.1.</span> <span class="toc-text">使用 InputEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.12.2.</span> <span class="toc-text">输入示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E5%92%8C%E8%BE%93%E5%85%A5%E5%9D%90%E6%A0%87"><span class="toc-number">1.12.3.</span> <span class="toc-text">鼠标和输入坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BC%A0%E6%A0%87%E5%85%89%E6%A0%87"><span class="toc-number">1.12.4.</span> <span class="toc-text">自定义鼠标光标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E3%80%81%E6%89%8B%E6%9F%84%E5%92%8C%E6%91%87%E6%9D%86"><span class="toc-number">1.12.5.</span> <span class="toc-text">控制器、手柄和摇杆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%80%80%E5%87%BA%E8%AF%B7%E6%B1%82"><span class="toc-number">1.12.6.</span> <span class="toc-text">处理退出请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-number">1.13.</span> <span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E6%95%B0%E5%AD%A6"><span class="toc-number">1.13.1.</span> <span class="toc-text">向量数学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%AD%89%E5%90%91%E9%87%8F%E6%95%B0%E5%AD%A6"><span class="toc-number">1.13.2.</span> <span class="toc-text">高等向量数学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%8F%98%E6%8D%A2"><span class="toc-number">1.13.3.</span> <span class="toc-text">矩阵与变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC"><span class="toc-number">1.13.4.</span> <span class="toc-text">插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9D%E5%A1%9E%E5%B0%94%E3%80%81%E6%9B%B2%E7%BA%BF%E5%92%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">1.13.5.</span> <span class="toc-text">贝塞尔、曲线和路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90"><span class="toc-number">1.13.6.</span> <span class="toc-text">随机数生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA"><span class="toc-number">1.14.</span> <span class="toc-text">导航</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2D-%E5%AF%BC%E8%88%AA%E6%A6%82%E8%BF%B0"><span class="toc-number">1.14.1.</span> <span class="toc-text">2D 导航概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-%E5%AF%BC%E8%88%AA%E6%A6%82%E8%BF%B0"><span class="toc-number">1.14.2.</span> <span class="toc-text">3D 导航概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationServer"><span class="toc-number">1.14.3.</span> <span class="toc-text">使用 NavigationServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%88%AA%E5%9C%B0%E5%9B%BE"><span class="toc-number">1.14.4.</span> <span class="toc-text">使用导航地图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%88%AA%E5%8C%BA%E5%9D%97"><span class="toc-number">1.14.5.</span> <span class="toc-text">使用导航区块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC"><span class="toc-number">1.14.6.</span> <span class="toc-text">使用导航网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationPath"><span class="toc-number">1.14.7.</span> <span class="toc-text">使用 NavigationPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationPathQueryObject"><span class="toc-number">1.14.8.</span> <span class="toc-text">使用 NavigationPathQueryObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationAgent"><span class="toc-number">1.14.9.</span> <span class="toc-text">使用 NavigationAgent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationObstacle"><span class="toc-number">1.14.10.</span> <span class="toc-text">使用 NavigationObstacle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationLink"><span class="toc-number">1.14.11.</span> <span class="toc-text">使用 NavigationLink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationLayer"><span class="toc-number">1.14.12.</span> <span class="toc-text">使用 NavigationLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">1.14.13.</span> <span class="toc-text">导航调试工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC"><span class="toc-number">1.14.14.</span> <span class="toc-text">连接导航网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E8%A7%92%E8%89%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.14.15.</span> <span class="toc-text">支持不同角色类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E8%A7%92%E8%89%B2%E8%BF%90%E5%8A%A8"><span class="toc-number">1.14.16.</span> <span class="toc-text">支持不同角色运动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E8%A7%92%E8%89%B2%E5%8C%BA%E5%9F%9F%E6%9D%83%E9%99%90"><span class="toc-number">1.14.17.</span> <span class="toc-text">支持不同角色区域权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">1.15.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F"><span class="toc-number">1.15.1.</span> <span class="toc-text">高级多人游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C-HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-number">1.15.2.</span> <span class="toc-text">进行 HTTP 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%B1%BB"><span class="toc-number">1.15.3.</span> <span class="toc-text">HTTP 客户端类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-SSL-%E8%AF%81%E4%B9%A6"><span class="toc-number">1.15.4.</span> <span class="toc-text">TLS&#x2F;SSL 证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-WebSockets"><span class="toc-number">1.15.5.</span> <span class="toc-text">Using WebSockets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebRTC"><span class="toc-number">1.15.6.</span> <span class="toc-text">WebRTC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">1.16.</span> <span class="toc-text">性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84"><span class="toc-number">1.16.1.</span> <span class="toc-text">常规</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU"><span class="toc-number">1.16.2.</span> <span class="toc-text">CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU"><span class="toc-number">1.16.3.</span> <span class="toc-text">GPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-1"><span class="toc-number">1.16.4.</span> <span class="toc-text">3D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.16.5.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86"><span class="toc-number">1.17.</span> <span class="toc-text">物理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.17.1.</span> <span class="toc-text">物理介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Jolt-Physics"><span class="toc-number">1.17.2.</span> <span class="toc-text">Using Jolt Physics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-RigidBody"><span class="toc-number">1.17.3.</span> <span class="toc-text">使用 RigidBody</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Area2D"><span class="toc-number">1.17.4.</span> <span class="toc-text">使用 Area2D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-CharacterBody2D-3D"><span class="toc-number">1.17.5.</span> <span class="toc-text">使用 CharacterBody2D&#x2F;3D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B0%84%E5%B0%84%E7%BA%BF"><span class="toc-number">1.17.6.</span> <span class="toc-text">发射射线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%A8%83%E5%A8%83%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.17.7.</span> <span class="toc-text">布娃娃系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E5%8A%A8%E5%AD%A6%E8%A7%92%E8%89%B2%EF%BC%882D%EF%BC%89"><span class="toc-number">1.17.8.</span> <span class="toc-text">运动学角色（2D）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-SoftBody3D"><span class="toc-number">1.17.9.</span> <span class="toc-text">Using SoftBody3D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E5%BD%A2%E7%8A%B6%EF%BC%882D%EF%BC%89"><span class="toc-number">1.17.10.</span> <span class="toc-text">碰撞形状（2D）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E5%BD%A2%E7%8A%B6%EF%BC%883D%EF%BC%89"><span class="toc-number">1.17.11.</span> <span class="toc-text">碰撞形状（3D）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87"><span class="toc-number">1.17.12.</span> <span class="toc-text">大世界坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%8F%92%E5%80%BC"><span class="toc-number">1.17.13.</span> <span class="toc-text">物理插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-number">1.17.14.</span> <span class="toc-text">物理问题的故障排除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3"><span class="toc-number">1.18.</span> <span class="toc-text">平台相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android"><span class="toc-number">1.18.1.</span> <span class="toc-text">Android</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iOS-%E6%8F%92%E4%BB%B6"><span class="toc-number">1.18.2.</span> <span class="toc-text">iOS 插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web"><span class="toc-number">1.18.3.</span> <span class="toc-text">Web</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-%E7%9A%84%E6%B8%B8%E6%88%8F%E4%B8%BB%E6%9C%BA%E6%94%AF%E6%8C%81"><span class="toc-number">1.18.4.</span> <span class="toc-text">Godot 的游戏主机支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6"><span class="toc-number">1.19.</span> <span class="toc-text">插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E6%8F%92%E4%BB%B6"><span class="toc-number">1.19.1.</span> <span class="toc-text">编辑器插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">1.19.2.</span> <span class="toc-text">在编辑器中运行代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93-2"><span class="toc-number">1.20.</span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%8F%A3"><span class="toc-number">1.20.1.</span> <span class="toc-text">使用视口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%88%86%E8%BE%A8%E7%8E%87"><span class="toc-number">1.20.2.</span> <span class="toc-text">多分辨率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%8A%96%E5%8A%A8%E3%80%81%E5%8D%A1%E9%A1%BF%E5%92%8C%E8%BE%93%E5%85%A5%E5%BB%B6%E8%BF%9F"><span class="toc-number">1.20.3.</span> <span class="toc-text">修复抖动、卡顿和输入延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%99%A8"><span class="toc-number">1.20.4.</span> <span class="toc-text">合成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-number">1.20.5.</span> <span class="toc-text">渲染器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC"><span class="toc-number">1.21.</span> <span class="toc-text">编写脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GDScript"><span class="toc-number">1.21.1.</span> <span class="toc-text">GDScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.21.2.</span> <span class="toc-text">核心特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.</span> <span class="toc-text">着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">1.22.1.</span> <span class="toc-text">着色器简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%8F%82%E8%80%83"><span class="toc-number">1.22.2.</span> <span class="toc-text">着色参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.3.</span> <span class="toc-text">你的第一个着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-VisualShader"><span class="toc-number">1.22.4.</span> <span class="toc-text">使用 VisualShader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.5.</span> <span class="toc-text">使用计算着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E8%AF%BB%E5%8F%96%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.6.</span> <span class="toc-text">屏幕读取着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86-GLSL-%E8%BD%AC%E6%8D%A2%E4%B8%BA-Godot-%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.7.</span> <span class="toc-text">将 GLSL 转换为 Godot 着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97"><span class="toc-number">1.22.8.</span> <span class="toc-text">着色器风格指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-SubViewport-%E4%BD%9C%E4%B8%BA%E7%BA%B9%E7%90%86"><span class="toc-number">1.22.9.</span> <span class="toc-text">使用 SubViewport 作为纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">1.22.10.</span> <span class="toc-text">自定义后期处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">1.22.11.</span> <span class="toc-text">高级后期处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E6%9C%A8%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="toc-number">1.22.12.</span> <span class="toc-text">树木的制作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%EF%BC%88UI%EF%BC%89"><span class="toc-number">1.23.</span> <span class="toc-text">用户界面（UI）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UI-%E6%9E%84%E4%BB%B6"><span class="toc-number">1.23.1.</span> <span class="toc-text">UI 构件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%94%9A%E7%82%B9"><span class="toc-number">1.23.1.1.</span> <span class="toc-text">大小和锚点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GUI-%E5%A4%96%E8%A7%82%E4%B8%8E%E4%B8%BB%E9%A2%98"><span class="toc-number">1.23.2.</span> <span class="toc-text">GUI 外观与主题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E8%8A%82%E7%82%B9%E6%95%99%E7%A8%8B"><span class="toc-number">1.23.3.</span> <span class="toc-text">控件节点教程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XR"><span class="toc-number">1.24.</span> <span class="toc-text">XR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B"><span class="toc-number">1.24.1.</span> <span class="toc-text">基础教程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E4%B8%93%E9%A2%98"><span class="toc-number">1.24.2.</span> <span class="toc-text">高级专题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-XR-%E5%B7%A5%E5%85%B7"><span class="toc-number">1.24.3.</span> <span class="toc-text">Godot XR 工具</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/" title="读Godot4.4文档手册">读Godot4.4文档手册</a><time datetime="2025-08-19T11:00:00.000Z" title="发表于 2025-08-19 19:00:00">2025-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/14/Godot4.4%20%E7%B1%BB%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/" title="Godot4.4 类参考总结">Godot4.4 类参考总结</a><time datetime="2025-08-14T11:00:00.000Z" title="发表于 2025-08-14 19:00:00">2025-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/10/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%9C%89%E6%84%9F%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/" title="读Godot4.4文档有感（长期更新）">读Godot4.4文档有感（长期更新）</a><time datetime="2025-08-10T11:00:00.000Z" title="发表于 2025-08-10 19:00:00">2025-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/02/Godot%20IP%E5%9C%B0%E5%9D%80P2P%E8%81%94%E6%9C%BA/" title="Godot IP地址P2P联机">Godot IP地址P2P联机</a><time datetime="2025-08-02T10:00:00.000Z" title="发表于 2025-08-02 18:00:00">2025-08-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/28/Godot%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/" title="Godot进阶学习">Godot进阶学习</a><time datetime="2025-07-28T10:00:00.000Z" title="发表于 2025-07-28 18:00:00">2025-07-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/./img/page-ym.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By 微光zc</span></div><div class="footer_custom_text">世界全剧终，欢迎来到my blog！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"data-lang":"zh-CN","data-reactions-enabled":"1","data-input-position":"top"}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'wzcwzc10/wzcwzc10.github.io',
      'data-repo-id': 'R_kgDOPIIccg',
      'data-category-id': 'DIC_kwDOPIIccs4CtHqc',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><div class="aplayer no-destroy" data-id="13985424074" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script id="canvas_nest" defer="defer" color="255,255,0" opacity="0.6" zIndex="-1" count="120" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="微光zc,ヾ(≧▽≦*)o,ヾ(^▽^*),ヾ(≧∇≦*)ゝ,ヾ(^_^)o,ヾ(•ω•`)o,ヾ(￣3￣.￣3),ヾ(￣▽￣),ヾ(￣0￣)o" data-fontsize="30px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:description\"]","link[rel=\"canonical\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html><script type="text/javascript" src="/js/crash_cheat.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sakana-widget@2.7.1/lib/sakana.min.css"><div id="sakana-widget" style="position:fixed;bottom:5px;right:80px;"></div><script>function initSakanaWidget() {
  const jufufuht = SakanaWidget.getCharacter('chisato');
  jufufuht.image = `https://wzcwzc10.github.io/img/jufufu.png`;
  jufufuht.initialState = {
    ...jufufuht.initialState,
    i: 0.001,
    d: 1,
  };
  SakanaWidget.registerCharacter('jufufuht', jufufuht);
  new SakanaWidget({ character: 'jufufuht' }).mount('#sakana-widget');

  const jufufu = SakanaWidget.getCharacter('takina');
  jufufu.image = `https://wzcwzc10.github.io/img/jufufu-ht.gif`;
  SakanaWidget.registerCharacter('jufufu', jufufu);
  new SakanaWidget({ character: 'jufufu' }).mount('#sakana-widget');
}
nextCharacter(jufufuht);</script><script async onload="initSakanaWidget()" src="https://cdn.jsdelivr.net/npm/sakana-widget@2.7.1/lib/sakana.min.js"></script>