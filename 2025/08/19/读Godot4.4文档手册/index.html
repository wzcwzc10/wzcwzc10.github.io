<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>读Godot4.4文档手册 | 微光zc的网络小窝</title><meta name="author" content="微光zc"><meta name="copyright" content="微光zc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="读Godot4.4文档手册">
<meta property="og:type" content="article">
<meta property="og:title" content="读Godot4.4文档手册">
<meta property="og:url" content="https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/index.html">
<meta property="og:site_name" content="微光zc的网络小窝">
<meta property="og:description" content="读Godot4.4文档手册">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wzcwzc10.github.io/img/jufufu-ht.gif">
<meta property="article:published_time" content="2025-08-19T11:00:00.000Z">
<meta property="article:modified_time" content="2025-09-17T14:49:16.602Z">
<meta property="article:author" content="微光zc">
<meta property="article:tag" content="Godot">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="文档">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wzcwzc10.github.io/img/jufufu-ht.gif"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "读Godot4.4文档手册",
  "url": "https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/",
  "image": "https://wzcwzc10.github.io/img/jufufu-ht.gif",
  "datePublished": "2025-08-19T11:00:00.000Z",
  "dateModified": "2025-09-17T14:49:16.602Z",
  "author": [
    {
      "@type": "Person",
      "name": "微光zc",
      "url": "https://wzcwzc10.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/./img/loading.gif"><link rel="canonical" href="https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '读Godot4.4文档手册',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/ziti.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="/components/bilibili-card/bilibili-card.dark.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/./img/page-bg.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/jufufu-ht.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 微光闲话</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/./img/page-ym.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/./img/yx.png" alt="Logo"><span class="site-name">微光zc的网络小窝</span></a><a class="nav-page-title" href="/"><span class="site-name">读Godot4.4文档手册</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 微光闲话</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">读Godot4.4文档手册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-19T11:00:00.000Z" title="发表于 2025-08-19 19:00:00">2025-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-17T14:49:16.602Z" title="更新于 2025-09-17 22:49:16">2025-09-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Godot/">Godot</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">174.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>564分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>本文参考<a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh-cn/4.x/index.html">Godot4.4中文文档</a>中<br>手册的内容进行了总结改进，去除了个人感觉无用的部分</p>
<h1 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h1><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>目录：<br>在 Godot 中应用面向对象原则<br>场景组织<br>何时使用场景与脚本<br>自动加载与常规节点<br>何时以及如何避免为任何事情使用节点<br>Godot 接口<br>Godot 通知<br>数据偏好<br>逻辑偏好<br>项目组织<br>版本控制系统</p>
<h3 id="在-Godot-中应用面向对象原则"><a href="#在-Godot-中应用面向对象原则" class="headerlink" title="在 Godot 中应用面向对象原则"></a>在 Godot 中应用面向对象原则</h3><p>Godot 引擎主要提供了两种创建可复用对象的方式：脚本和场景。<br>虽没有真正在底层定义类但面向对象的编程原则仍可应用。</p>
<h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>引擎提供了内置的类，如<strong>Node</strong>。<br>使用脚本扩展类来创建派生类型。<br>脚本严格来说并不是类，而是一种资源，用来告知引擎在内置类的基础上执行的初始化操作。</p>
<p>Godot 的内部类可以将一个类的数据注册进一个名为<strong>ClassDB</strong>的数据库<br>可以在运行时访问类的信息（例：属性 方法 常量 信号）。</p>
<p>当对象在执行访问属性或调用方法等操作时，就会检查<strong>ClassDB</strong>中对象和对象基类的记录，确定对象是否支持该操作。<br>将<strong>脚本</strong>附加到对象上，可以扩展<strong>ClassDB</strong>中该对象的方法、属性和信号。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
脚本即使没有使用 extends 关键字，也会隐式继承引擎的基础 RefCounted 类。<br>
因此，你可以从代码中实例化不使用 extends 关键字的脚本。<br>
不过由于扩展的是 RefCounted，无法把它们附加到 Node 上。
</p>

<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>场景是可复用、可实例化、可继承的节点组。<br>创建场景就类似于，有一个脚本去创建一些节点，并使用 add_child() 将它们添加为子节点。</p>
<p>我们经常为场景搭配一个带有脚本的根节点，并在脚本中使用这个场景下的节点。脚本是通过使用命令式代码为场景添加行为来扩展场景的。</p>
<p>场景的内容有助于定义：</p>
<ul>
<li>脚本可使用哪些节点。</li>
<li>如何组织，初始化。</li>
<li>彼此之间有什么信号连接。</li>
</ul>
<p class="div-border" style="background-color: rgba(26, 196, 35, 0.1);border: 1px solid #1ac439ff;border-radius: 0.4rem;">
<mark class="hl-label green">问题</mark><br>
为什么这些对组织场景很重要？<br>
因为场景的实例都是对象。<br>
因此，许多适用于面向对象原则也适用于场景：单一职责、封装等。
</p>


<h3 id="场景组织"><a href="#场景组织" class="headerlink" title="场景组织"></a>场景组织</h3><h4 id="如何有效地建立关系？"><a href="#如何有效地建立关系？" class="headerlink" title="如何有效地建立关系？"></a>如何有效地建立关系？</h4><ul>
<li>应尽可能设计没有依赖的场景。（创建的场景应该将其所需的一切保留在其内部）</li>
<li>如果场景必须与外部环境交互，建议使用依赖注入。</li>
<li>依赖注入涉及使高级 API 提供低级 API 的依赖关系。</li>
<li>为什么？依赖于其外部环境的类可能会无意中触发 Bug 和意外行为。</li>
</ul>
<p>✅ 核心目标：松耦合 + 高内聚<br>“一个类不应依赖外部环境来完成其核心功能。”</p>
<p>要做到这一点，就必须暴露数据，然后依靠父级上下文对其进行初始化<br>五种方法：</p>
<ol>
<li>连接信号。<br>这样做极其安全，但只能用于“响应”，而不是启动。<br>按惯例，信号名称通常是过去式动词。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.signal_name.connect(method_on_the_object)</span><br><span class="line"></span><br><span class="line"># Child 子 → 父（通知）</span><br><span class="line">signal_name.emit() # 触发父级定义的行为</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>调用方法。<br>用于启动行为。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.method_name = &quot;do&quot;</span><br><span class="line"></span><br><span class="line"># Child 父 → 子（指令）</span><br><span class="line">call(method_name) # Call parent-defined method (which child must own).</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>初始化 Callable 属性。<br>比调用方法更安全，因为不需要拥有这个方法的所有权。用于启动行为。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.func_property = object_with_method.method_on_the_object</span><br><span class="line"></span><br><span class="line"># Child 父 → 子（注入行为）</span><br><span class="line">func_property.call() # Call parent-defined method (can come from anywhere).</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>初始化 Node 或其他 Object 的引用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.target = self</span><br><span class="line"></span><br><span class="line"># Child 父 → 子（提供数据源）</span><br><span class="line">print(target) # Use parent-defined node.</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>初始化 NodePath。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.target_path = &quot;..&quot;</span><br><span class="line"></span><br><span class="line"># Child 子 → 外部（通过路径查找）</span><br><span class="line">get_node(target_path) # Use parent-defined NodePath.</span><br></pre></td></tr></table></figure>
<p>这些选项隐藏了子节点的访问点。这反过来又使子节点与环境保持<strong>松耦合</strong> （loosely coupled）。<br>人们可以在另外一个上下文中重新使用它，而不需要对API做任何额外的改变。</p>
<p class="div-border" style="background-color: rgba(196, 26, 26, 0.1);border: 1px solid #c41a1aff;border-radius: 0.4rem;">
<mark class="hl-label red">警告</mark><br>
应倾向于将数据保存在场景内部，尽管它对外部内容有一个依赖关系，甚至是一个松散耦合的依赖，仍然意味着节点将期望其环境中的某些内容为真。<br>
项目的设计理念应避免这种情况的发生。如果不这样做，代码的继承关系将迫使开发人员使用文档, 以在微观尺度上跟踪对象关系；这就是所谓的开发地狱。<br>
通常情况下，编写依赖于外部文档才能安全使用的代码，是很容易出错的。<br>
为了避免创建和维护此类文档，可以将依赖节点（上面的子级）转换为工具脚本，该脚本实现 _get_configuration_warnings()。<br>
从中返回的一个非空字符串紧缩数组（PackedStringArray）将使场景停靠面板生成警告图标，其中包含上述字符串作为节点的工具提示。<br>
这个警告图标和没有定义 CollisionShape2D 子节点时 Area2D 节点旁出现的图标是一样的。这样，编辑器通过脚本代码自记录（self-document）场景，也就不需要在文档里记录一些与之重复的内容了。<br>
这样的GUI可以更好地通知项目用户有关节点的关键信息. 它具有外部依赖性吗？这些依赖性是否得到满足？<br>
其他程序员, 尤其是设计师和作家, 将需要消息中的明确指示, 告诉他们如何进行配置.
</p>

<h4 id="选择节点树结构"><a href="#选择节点树结构" class="headerlink" title="选择节点树结构"></a>选择节点树结构</h4><p>构造节点树的方法有无数种。<br>对于没把握的人而言，这份有用的指南可以给他们一个不错的结构样本作为开始。<br>main.gd, 脚本将作为你的游戏的主要控制器。<br>Node2D&#x2F;Node3D, 真正的游戏“世界”（2D或3D）。<br>GUI, 来管理项目所需的各种菜单和部件。<br>“Main”节点（main.gd）</p>
<ul>
<li>Node2D&#x2F;Node3D “World”（game_world.gd）</li>
<li>Control“GUI”（gui.gd）</li>
</ul>
<p>当变更关卡时，可以稍后换出“World”节点的子级。手动更换场景让用户完全控制他们的游戏世界如何过渡。<br>下一步是考虑项目需要什么样的游戏系统。如果有这么一个系统……<br>跟踪所有的内部数据<br>全局可访问的<br>独立存在的</p>
<ul>
<li>创建一个自动加载“单例”节点</li>
</ul>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
对于较小的游戏，一个更简单且更少控制的做法是使用一个“Game”单例<br>
简单地调用 SceneTree.change_scene_to_file() 方法，用于置换出主场景的内容。这种结构多少保留了“World”作为主要游戏节点。<br>
任一 GUI 也需要是一个单例；作为 "World" 的临时部分，或被手动添加到根节点作为其直接子节点。否则 GUI 节点也会在场景转换时自行删除。
</p>

<p>如果一个系统需要修改另一个系统的数据，那么就应该把它们分别定义成单独的脚本或者场景，不应该使用自动加载。</p>
<p>游戏中的每个子系统都应该在 SceneTree 中占有自己的一席之地。只有在节点确实是父节点中的元素时才应当使用父子关系。如果移除父节点的话，同时将这些子节点移除是否说得通？说不通的话，就应该在层级结构中单独列出，两者成为兄弟节点或者其他关系。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
某些情况下，我们仍然会需要让这些单独的节点进行相对定位。<br>
此时可以使用 RemoteTransform / RemoteTransform2D 节点。让目标节点有条件地从 Remote* 节点继承选定的变换元素。<br>
要分配 target 的 NodePath，请使用以下方法之一：<br>
1. 一个可靠的第三方, 可能是一个父节点, 来协调分配任务.<br>
2. 一个分组, 轻松提取对所需节点的引用(假设只有一个目标).<br>
什么时候你该这样做？当你必须精细管理，且一个节点必须在场景树上来回移动以保留自己时，就会出现两难的局面。例如……<br>
添加一个“玩家”节点到一个“房间”节点。<br>
需要改变房间了，所以必须删除当前房间节点。<br>
在房间能被删除前，你必须保留玩家并/或将其移走。<br>
- 如果不关心内存，你可以……<br>
    - 创建新的房间节点。<br>
    - 将玩家节点移动到新的房间节点。<br>
    - 删除旧房间。<br>
- 如果比较关注内存情况，那么就需要这样……<br>
    - 将玩家节点移动到节点树的其他地方。<br>
    - 删除房间节点。<br>
    - 实例化并添加新的房间节点。<br>
    - 重新添加玩家节点到新房间中。<br>
问题在于这里的角色是一种“特殊情况”；开发者必须知道需要以这种方式处理项目中的角色。<br>
因此，在团队中可靠地分享这些信息的唯一方法就是写文档。<br>
然而，在文档中记录实现细节是很危险的，会成为一种维护负担，使代码可读性下降，不必要地膨胀项目的知识内容。<br>
在拥有更多的资产的，更复杂的游戏中，将整个玩家节点保留在 SceneTree 中的其他地方会更好。这样的好处是：<br>
- 一致性更高。<br>
- 没有“特殊情况”，不必写入文档也不必进行维护。<br>
- 因为不需要考虑这些细节，所以也没有出错的机会。<br>
- 相比之下，如果需要子节点不继承父节点的变换，那么就有以下选项：<br>
声明式解决方案：在它们之间放置一个 Node。作为没有变换的节点，Node 不会将这些信息传递给其子节点。<br>
命令式解决方案：对 CanvasItem 或者 Node3D 节点使用 top_level 属性。这样就会让该节点忽略其继承的变换（transform）。
</p>

<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
如果构建的是网络游戏，请记住哪些节点和游戏系统与所有玩家相关，而哪些只与权威服务器相关。<br>
例如，用户并不需要所有人都拥有每个玩家的“PlayerController”逻辑的副本。相反，他们只需要自己的。<br>
将它们保持在从“世界”分离的独立的分支中，可以帮助简化游戏连接等的管理。
</p>

<p>场景组织的关键是用关系树而不是空间树来考虑 SceneTree。<br>节点是否依赖于其父节点的存在？<br>如果不是，那么它们可以自己在别的地方茁壮成长。<br>如果它们是依赖性的，那么理所当然它们应该是父节点的子节点（如果它们还不是父节点场景的一部分，那么很可能是父节点场景的一部分）。</p>
<p class="div-border" style="background-color: rgba(26, 196, 35, 0.1);border: 1px solid #1ac439ff;border-radius: 0.4rem;">
<mark class="hl-label green">问题</mark><br>
这是否意味着节点本身就是组件？<br>
并不是这样。Godot 的节点树形成的是聚合关系，不是组合关系。<br>
虽然依旧可以灵活地移动节点，但在默认情况下是没有进行移动的必要的。
</p>

<h3 id="何时使用场景与脚本"><a href="#何时使用场景与脚本" class="headerlink" title="何时使用场景与脚本"></a>何时使用场景与脚本</h3><h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h4><p>单独使用脚本可以完全定义场景的内容.<br>但是, 选择哪个来使用, 可能是一个两难问题. 创建脚本实例与创建引擎类相同, 而处理场景需要更改API:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const MyNode = preload(&quot;my_node.gd&quot;)</span><br><span class="line">const MyScene = preload(&quot;my_scene.tscn&quot;)</span><br><span class="line">var node = Node.new()</span><br><span class="line">var my_node = MyNode.new() # 相同的方法调用</span><br><span class="line">var my_scene = MyScene.instantiate() # 不同的方法调用</span><br><span class="line">var my_inherited_scene = MyScene.instantiate(PackedScene.GEN_EDIT_STATE_MAIN) # 创建一个继承自 MyScene 的场景</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此外, 由于引擎和脚本代码之间的速度差异, 脚本的运行速度将比场景慢一些. 节点越大和越复杂, 将它构建为场景的理由就越多.</p>
</blockquote>
<h4 id="命名的类型-注册新类型"><a href="#命名的类型-注册新类型" class="headerlink" title="命名的类型(注册新类型)"></a>命名的类型(注册新类型)</h4><p>脚本可以在编辑器中被注册为一个新类型。<br>这样，用户就可以更加便捷地使用脚本，而不是必须…</p>
<ul>
<li>了解他们想要使用的脚本的基本类型.</li>
<li>创建一个该基本类型的实例.</li>
<li>将脚本添加到节点.</li>
</ul>
<p>用于注册类型的系统有两种：</p>
<ol>
<li><p>自定义类型<br>仅限编辑器. 类型名称在运行时中不可访问.<br>不支持继承的自定义类型.<br>一个初始化工具. 使用脚本创建节点.<br>编辑器没有对该脚本的类型感知, 或其与其他引擎类型或脚本的关系.<br>允许用户定义一个图标.<br>设置使用 EditorPlugin.add_custom_type.</p>
</li>
<li><p>Script 类<br>编辑器和运行时均可访问.<br>显示全部继承关系.<br>使用脚本创建节点, 但也可以从编辑器更改或扩展类型.<br>编辑器知道脚本, 脚本类和引擎c++类之间的继承关系.<br>允许用户定义一个图标.<br>引擎开发人员必须手动添加对语言的支持(名称公开和运行时可访问性两者).<br>编辑器扫描项目文件夹, 并为所有脚本语言注册任何公开的名称. 为公开此信息, 每种脚本语言都必须实现自己的支持.</p>
</li>
</ol>
<p>这两种方法都向创建对话框添加名称, 特别是脚本类, 还允许用户在不加载脚本资源的情况下访问类别名称. 在任何地方都可以创建实例, 和访问常量或静态方法.<br>有了这些功能, 由于它赋予用户易用性, 人们可能希望它们的类型是没有场景的脚本. 那些正在开发的插件或创建供设计人员使用的内部工具, 将以这种方式使事情变得更轻松.<br>不足之处在于, 这也意味着很大程度上必须使用命令式编程.</p>
<h4 id="Script-与-PackedScene-的性能"><a href="#Script-与-PackedScene-的性能" class="headerlink" title="Script 与 PackedScene 的性能"></a>Script 与 PackedScene 的性能</h4><p>在选择场景和脚本时, 最后一个需要考虑的方面是执行速度.<br>随着对象内容的增加, 脚本创建和初始化所需的内容也会大大增加. 创建节点层次结构就说明了这一点. 每个Node的逻辑可能有几百行代码.<br>下面的代码示例创建一个新的 Node, 更改名称, 分配脚本, 将其未来的父级设置为其所有者, 以便保存到磁盘中, 最后将其添加为 “主” 节点的子级:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># main.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">func _init():</span><br><span class="line">	var child = Node.new()</span><br><span class="line">	child.name = &quot;Child&quot;</span><br><span class="line">	child.script = preload(&quot;child.gd&quot;)</span><br><span class="line">	add_child(child)</span><br><span class="line">	child.owner = self</span><br></pre></td></tr></table></figure>
<p>这样的脚本代码比引擎端的C++代码要慢很多. 每条指令都要调用脚本API, 导致后端要进行多次 “查找”, 以找到要执行的逻辑.<br>场景有助于避免这个性能问题。<code>PackedScene</code>（场景包）是场景继承的基础类型，定义了使用序列化数据创建对象的资源。<br>引擎可以在后端批量处理场景，并提供比脚本好得多的性能。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最好的方法是考虑以下几点:<br>有一个自定义名称&#x2F;图标.<br>场景比脚本更容易跟踪&#x2F;编辑, 并提供更多的安全性.<br>命名场景通过声明一个脚本类并给它一个场景作为常量来实现这一点。实际上，该脚本变成了一个命名空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># game.gd</span><br><span class="line">class_name Game # 它继承自 RefCounted，因此不会出现在节点创建对话框中。</span><br><span class="line">extends RefCounted</span><br><span class="line"></span><br><span class="line">const MyScene = preload(&quot;my_scene.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># main.gd</span><br><span class="line">extends Node</span><br><span class="line">func _ready():</span><br><span class="line">	add_child(Game.MyScene.instantiate())</span><br></pre></td></tr></table></figure>

<h3 id="自动加载与常规节点"><a href="#自动加载与常规节点" class="headerlink" title="自动加载与常规节点"></a>自动加载与常规节点</h3><p>Godot 提供了一个在项目根节点自动加载节点的功能，允许你在全局范围内访问它们，从而完成单例作用 单例（自动加载） 。<br>当你在代码中使用 SceneTree.change_scene_to_file 更改场景时，这些自动加载的节点不会被释放。<br>在本指南中, 你将学习到何时使用自动加载功能, 以及避免使用该功能的方法.</p>
<h4 id="切割音频问题"><a href="#切割音频问题" class="headerlink" title="切割音频问题"></a>切割音频问题</h4><p>其他引擎可能鼓励使用创建管理类, 单例将很多功能组织到一个全局可访问的对象中.<br>由于节点树和信号,Godot提供了许多避免全局状态的方法.</p>
<p>例如, 假设我们正在构建一个平台游戏, 并希望收集能够播放声音效果的硬币, 那么就有一个节点 AudioStreamPlayer. 如果在 AudioStreamPlayer 已经在播放声音时调用它, 新的声音就会打断第一个声音.</p>
<p>一种解决方案是写一个全局的、自动加载的音效管理器类。它会生成一个 AudioStreamPlayer 的节点池，每当一个新的音效请求出现时，它就会在这个节点池中找到可用的节点来播放。我们不妨就把该类命名为<strong>Sound</strong> ，你可以通过<code>Sound.play(&quot;coin_pickup.ogg&quot;)</code>从你项目中的任何位置使用它。这在短期内解决了问题但是却造成了更多的麻烦：</p>
<ol>
<li>全局状态 : 一个对象现在负责所有对象的数据. 如果音效有错误, 或没有一个可用的 AudioStreamPlayer , 一切都会崩溃.</li>
<li>全局访问 : 意味着任何对象都可以从任何地方调用 Sound.play(sound_path) , 便不容易找到错误的来源了.</li>
<li>全局资源分配 : 由于从一开始就存储了一个 AudioStreamPlayer 节点池, 如果数量太少会遇到bug, 而数量太多则会占用更多的内存.</li>
</ol>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
全局访问的问题在于，任何地方的代码都可能将错误的数据传递给我们例子中的 Sound 自动加载。<br>
因此，为了修复这个 bug，你需要检索的区域涵盖了整个项目。当你将代码保存在场景中时, 音频可能仅涉及一个或两个脚本.
</p>

<p>与之形成对比的是, 每个场景在其内部, 保留尽可能多的 AudioStreamPlayer 节点, 所有这些问题都会消失:</p>
<ol>
<li>每个场景管理自己的状态信息. 如果数据有问题, 则只会在该场景中引起问题.</li>
<li>每个场景只访问自己的节点. 那么如果有一个bug, 很容易找到哪个节点有问题.</li>
<li>每个场景只分配所需数量的资源.</li>
</ol>
<h4 id="管理共享功能或数据"><a href="#管理共享功能或数据" class="headerlink" title="管理共享功能或数据"></a>管理共享功能或数据</h4><p>使用自动加载的另一个原因可能是你希望在许多场景中重复使用相同的方法或数据.<br>对于函数，可以使用 GDScript 中的 class_name 关键字创建一种新的 Node 类型，为单个场景提供该功能。<br>当涉及到数据时, 你可以:</p>
<ol>
<li>创建一个新类型的 Resource 来共享数据.</li>
<li>将数据存储在每个节点可以访问的对象中, 例如使用 owner 属性来访问场景的根节点.</li>
</ol>
<h4 id="何时应使用自动加载"><a href="#何时应使用自动加载" class="headerlink" title="何时应使用自动加载"></a>何时应使用自动加载</h4><p>GDScript 支持使用 static func 创建 static （静态） 函数，与 class_name 结合使用时还可以创建辅助函数库，无需创建实例来调用这些函数。 静态函数也有一些限制：不能引用成员变量、非静态（non-static）函数或 self。<br>从 Godot 4.1 开始，GDScript 还支持使用 static var 的 static （静态）变量，意味着你现在可以在类的实例之间共享变量，而无需创建单独的自动加载节点或脚本。<br>尽管如此，对于那些涵盖范围广泛的系统来说，使用自动加载的节点仍然可以简化你的代码。如果自动加载的节点管理自己的信息并且不侵入其他对象的数据，那么这就是一个创建处理广泛任务的系统（例如，任务或对话系统）的好方法。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
自动加载不完全是一个单例。没有什么可以阻止你实例化自动加载的节点的副本。<br>
它只是一个使节点作为场景树的根的子节点自动加载的工具，而与游戏的节点结构或运行哪个场景（比如通过按 F6 键运行当前场景）无关。<br>
因此，你可以通过调用 get_node("/root/Sound") 来获取名为 Sound 的自动加载节点。
</p>

<h3 id="何时以及如何避免为任何事情使用节点"><a href="#何时以及如何避免为任何事情使用节点" class="headerlink" title="何时以及如何避免为任何事情使用节点"></a>何时以及如何避免为任何事情使用节点</h3><ol>
<li>Object：终极轻量级对象，原始的 Object 必须使用手动内存管理。<br>尽管如此，创建自己的自定义数据结构——甚至是节点结构——也并不难，并且比 Node 类更轻量。</li>
</ol>
<p>示例：参见 Tree 节点。它支持对具有任意行数和列数的内容表，进行高级定制。用来生成可视化的数据实际上是 TreeItem 对象的树。</p>
<p>优势： 将 API 简化为较小范围的对象，有助于提高其可访问性、改善迭代时间。与其使用整个 Node 库，不如创建一组简略的 Object，节点可以从这些 Object 中生成和管理相应的子节点。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
处理它们时要小心. 可以将 Object 存储到变量中, 但是这些引用可能在没有警告的情况下失效. <br>
例如, 如果对象的创建者决定删除它, 这将在下一次访问时, 触发错误状态.
</p>

<ol start="2">
<li><p>RefCounted：只比 Object 稍微复杂一点。它们会记录对自己的引用，只有当对自己没有另外的引用存在时，才会删除加载的内存。在大多数需要在自定义类中存取数据的情况下，很有用。<br>示例：见 FileAccess 对象。它的功能就像普通 Object 一样，只是不需要人为删除。<br>优势: 与 Object 相同.</p>
</li>
<li><p>Resource ：只比 RefCounted 稍微复杂一点。它们天然具有将其对象属性序列化（即保存）到 Godot 资源文件，或从 Godot 资源文件中反序列化（即加载）的能力。<br>示例 : 脚本, PackedScene (用于场景文件), 以及其他类型, 比如 AudioEffect 类. 每一个都可以保存和加载, 因此它们均是从 Resource 继承而来的.<br>优势：关于 Resource 与传统数据存储方法相比的优势已经说了 很多。然而，在使用 Resource 替代 Node 的情境下，Resource 的主要优点是与检查器的兼容性。虽然几乎和 Object&#x2F;Reference 一样轻量，它们仍然可以在检查器中显示并导出属性。这使它们在易用性上，可以媲美使用子节点的方式，而且如果有人计划在其场景中包含许多这类 Resource&#x2F;Node，它们还可以提高性能。</p>
</li>
</ol>
<h3 id="Godot-接口"><a href="#Godot-接口" class="headerlink" title="Godot 接口"></a>Godot 接口</h3><p>脚本常常需要依赖其他对象来获取功能。这个过程分为两部分：</p>
<ol>
<li>获取对可能具有这些功能的对象的引用。</li>
<li>从对象访问数据或逻辑。</li>
</ol>
<h4 id="获取对象引用"><a href="#获取对象引用" class="headerlink" title="获取对象引用"></a>获取对象引用</h4><p>对所有 Object 来说，获得引用的最基础的方法，是通过另一个已获得引用的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = node.object # Property access.</span><br><span class="line">var obj = node.get_object() # Method access.</span><br></pre></td></tr></table></figure>
<p>同样的原则也适用于 RefCounted 对象。虽然用户经常以这种方式访问 Node 和 Resource，但还有其他方法可用。<br>除了访问属性和方法，也可以通过加载来获得 Resource。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># If you need an &quot;export const var&quot; (which doesn&#x27;t exist), use a conditional</span><br><span class="line"># setter for a tool script that checks if it&#x27;s executing in the editor.</span><br><span class="line"># The `@tool` annotation must be placed at the top of the script.</span><br><span class="line">@tool</span><br><span class="line"></span><br><span class="line"># Load resource during scene load.</span><br><span class="line">var preres = preload(path)</span><br><span class="line"># Load resource when program reaches statement.</span><br><span class="line">var res = load(path)</span><br><span class="line"></span><br><span class="line"># Note that users load scenes and scripts, by convention, with PascalCase</span><br><span class="line"># names (like typenames), often into constants.</span><br><span class="line">const MyScene = preload(&quot;my_scene.tscn&quot;) # Static load</span><br><span class="line">const MyScript = preload(&quot;my_script.gd&quot;)</span><br><span class="line"></span><br><span class="line"># This type&#x27;s value varies, i.e. it is a variable, so it uses snake_case.</span><br><span class="line">@export var script_type: Script</span><br><span class="line"></span><br><span class="line"># Must configure from the editor, defaults to null.</span><br><span class="line">@export var const_script: Script:</span><br><span class="line">	set(value):</span><br><span class="line">		if Engine.is_editor_hint():</span><br><span class="line">			const_script = value</span><br><span class="line"></span><br><span class="line"># Warn users if the value hasn&#x27;t been set.</span><br><span class="line">func _get_configuration_warnings():</span><br><span class="line">	if not const_script:</span><br><span class="line">		return [&quot;Must initialize property &#x27;const_script&#x27;.&quot;]</span><br><span class="line"></span><br><span class="line">	return []</span><br></pre></td></tr></table></figure>
<p>请注意以下几点：</p>
<ol>
<li>在一种语言中，有许多加载这些资源的方法。</li>
<li>在设计对象如何访问数据时，不要忘记，还可以将资源作为引用传递。</li>
<li>请记住，加载资源时只会获取引擎维护的缓存资源实例。如果要获取一个新对象，必须 复制 一个现有引用，或者使用 new() 从头实例化一个对象。</li>
</ol>
<p>节点同样也有另一种访问方式：场景树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">extends Node</span><br><span class="line"></span><br><span class="line"># Slow.</span><br><span class="line">func dynamic_lookup_with_dynamic_nodepath():</span><br><span class="line">	print(get_node(&quot;Child&quot;))</span><br><span class="line"></span><br><span class="line"># Faster. GDScript only.</span><br><span class="line">func dynamic_lookup_with_cached_nodepath():</span><br><span class="line">	print($Child)</span><br><span class="line"></span><br><span class="line"># Fastest. Doesn&#x27;t break if node moves later.</span><br><span class="line"># Note that `@onready` annotation is GDScript-only.</span><br><span class="line"># Other languages must do...</span><br><span class="line">#     var child</span><br><span class="line">#     func _ready():</span><br><span class="line">#         child = get_node(&quot;Child&quot;)</span><br><span class="line">@onready var child = $Child</span><br><span class="line">func lookup_and_cache_for_future_access():</span><br><span class="line">	print(child)</span><br><span class="line"></span><br><span class="line"># Fastest. Doesn&#x27;t break if node is moved in the Scene tree dock.</span><br><span class="line"># Node must be selected in the inspector as it&#x27;s an exported property.</span><br><span class="line">@export var child: Node</span><br><span class="line">func lookup_and_cache_for_future_access():</span><br><span class="line">	print(child)</span><br><span class="line"></span><br><span class="line"># Delegate reference assignment to an external source.</span><br><span class="line"># Con: need to perform a validation check.</span><br><span class="line"># Pro: node makes no requirements of its external structure.</span><br><span class="line">#      &#x27;prop&#x27; can come from anywhere.</span><br><span class="line">var prop</span><br><span class="line">func call_me_after_prop_is_initialized_by_parent():</span><br><span class="line">	# Validate prop in one of three ways.</span><br><span class="line"></span><br><span class="line">	# Fail with no notification.</span><br><span class="line">	if not prop:</span><br><span class="line">		return</span><br><span class="line"></span><br><span class="line">	# Fail with an error message.</span><br><span class="line">	if not prop:</span><br><span class="line">		printerr(&quot;&#x27;prop&#x27; wasn&#x27;t initialized&quot;)</span><br><span class="line">		return</span><br><span class="line"></span><br><span class="line">	# Fail and terminate.</span><br><span class="line">	# NOTE: Scripts run from a release export template don&#x27;t run `assert`s.</span><br><span class="line">	assert(prop, &quot;&#x27;prop&#x27; wasn&#x27;t initialized&quot;)</span><br><span class="line"></span><br><span class="line"># Use an autoload.</span><br><span class="line"># Dangerous for typical nodes, but useful for true singleton nodes</span><br><span class="line"># that manage their own data and don&#x27;t interfere with other objects.</span><br><span class="line">func reference_a_global_autoloaded_variable():</span><br><span class="line">	print(globals)</span><br><span class="line">	print(globals.prop)</span><br><span class="line">	print(globals.my_getter())</span><br></pre></td></tr></table></figure>

<h4 id="从对象访问数据或逻辑"><a href="#从对象访问数据或逻辑" class="headerlink" title="从对象访问数据或逻辑"></a>从对象访问数据或逻辑</h4><p>Godot 的脚本 API 是鸭子类型（duck-typed）的。<br>这意味着，当脚本执行某项操作时，Godot 不会通过<strong>类型</strong>来验证其是否支持该操作。相反，它会检查对象是否<strong>实现</strong>了这个被调用的方法。</p>
<p>例如，CanvasItem 类具有 visible&#96; 属性。暴露给脚本 API 的所有属性实际上都是与名称绑定的 setter 和 getter 对。如果有人尝试访问 CanvasItem.visible，那么 Godot 将按顺序执行以下检查：</p>
<ul>
<li>如果对象附加了脚本，它将尝试通过脚本设置属性。这使得脚本有机会通过覆盖属性的 setter 方法来覆盖在基础对象上定义的属性。</li>
<li>如果脚本没有该属性，它会在 ClassDB 中针对 CanvasItem 类及其所有继承类型执行 HashMap 查找以查找“visible”属性。如果找到，它会调用绑定的 setter 或 getter。有关 HashMap 的更多信息，请参阅《数据偏好》文档。</li>
<li>如果没有找到, 它会进行显式检查, 以查看用户是否要访问 script 或 meta 属性.</li>
<li>如果没有, 它将在 CanvasItem 及其继承的类型中检查 _set&#x2F;_get 实现(取决于访问类型). 这些方法可以执行逻辑, 从而给人一种对象具有属性的印象. _get_property_list 方法也是如此.<ul>
<li>请注意，即使对于不合法的符号名称也会发生这种情况，例如以数字开头或包含斜杠（&#x2F;）的名称。</li>
</ul>
</li>
</ul>
<p>因此，这个鸭子类型的系统可以在脚本、对象的类，或对象继承的任何类中定位属性，但仅限于扩展 Object 的对象。</p>
<p>Godot 提供了多种选项，来对这些访问执行运行时检查：</p>
<ul>
<li>鸭子类型属性的访问。Godot 将像上文所述的那样对它进行属性检查。如果对象不支持该操作，则执行将停止。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 所有对象都有类似鸭子类型（duck-typed）的 get、set 和 call 包装方法</span><br><span class="line">get_parent().set(&quot;visible&quot;, false)</span><br><span class="line"></span><br><span class="line"># 在方法调用中使用符号（symbol）访问器而非字符串，</span><br><span class="line"># 会隐式地调用 set 方法，而 set 方法又会通过属性查找顺序，</span><br><span class="line"># 调用绑定到该属性的 setter 方法。</span><br><span class="line">get_parent().visible = false</span><br><span class="line"></span><br><span class="line"># 请注意，如果定义了 _set 和 _get 方法来描述某个属性的存在，</span><br><span class="line"># 但该属性未在任何 _get_property_list 方法中被识别，</span><br><span class="line"># 那么 set() 和 get() 方法仍然可以正常工作，</span><br><span class="line"># 但符号访问方式会提示找不到该属性。</span><br></pre></td></tr></table></figure>
<p>方法检查。在 CanvasItem.visible 的例子中，我们可以像访问任何其他方法一样，访问 set_visible 和 is_visible。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">var child = get_child(0)</span><br><span class="line"></span><br><span class="line"># Dynamic lookup.</span><br><span class="line">child.call(&quot;set_visible&quot;, false)</span><br><span class="line"></span><br><span class="line"># Symbol-based dynamic lookup.</span><br><span class="line"># GDScript aliases this into a &#x27;call&#x27; method behind the scenes.</span><br><span class="line">child.set_visible(false)</span><br><span class="line"></span><br><span class="line"># Dynamic lookup, checks for method existence first.</span><br><span class="line">if child.has_method(&quot;set_visible&quot;):</span><br><span class="line">	child.set_visible(false)</span><br><span class="line"></span><br><span class="line"># Cast check, followed by dynamic lookup.</span><br><span class="line"># Useful when you make multiple &quot;safe&quot; calls knowing that the class</span><br><span class="line"># implements them all. No need for repeated checks.</span><br><span class="line"># Tricky if one executes a cast check for a user-defined type as it</span><br><span class="line"># forces more dependencies.</span><br><span class="line">if child is CanvasItem:</span><br><span class="line">	child.set_visible(false)</span><br><span class="line">	child.show_on_top = true</span><br><span class="line"></span><br><span class="line"># If one does not wish to fail these checks without notifying users,</span><br><span class="line"># one can use an assert instead. These will trigger runtime errors</span><br><span class="line"># immediately if not true.</span><br><span class="line">assert(child.has_method(&quot;set_visible&quot;))</span><br><span class="line">assert(child.is_in_group(&quot;offer&quot;))</span><br><span class="line">assert(child is CanvasItem)</span><br><span class="line"></span><br><span class="line"># Can also use object labels to imply an interface, i.e. assume it</span><br><span class="line"># implements certain methods.</span><br><span class="line"># There are two types, both of which only exist for Nodes: Names and</span><br><span class="line"># Groups.</span><br><span class="line"></span><br><span class="line"># Assuming...</span><br><span class="line"># A &quot;Quest&quot; object exists and 1) that it can &quot;complete&quot; or &quot;fail&quot; and</span><br><span class="line"># that it will have text available before and after each state...</span><br><span class="line"></span><br><span class="line"># 1. Use a name.</span><br><span class="line">var quest = $Quest</span><br><span class="line">print(quest.text)</span><br><span class="line">quest.complete() # or quest.fail()</span><br><span class="line">print(quest.text) # implied new text content</span><br><span class="line"></span><br><span class="line"># 2. Use a group.</span><br><span class="line">for a_child in get_children():</span><br><span class="line">	if a_child.is_in_group(&quot;quest&quot;):</span><br><span class="line">		print(quest.text)</span><br><span class="line">		quest.complete() # or quest.fail()</span><br><span class="line">		print(quest.text) # implied new text content</span><br><span class="line"></span><br><span class="line"># Note that these interfaces are project-specific conventions the team</span><br><span class="line"># defines (which means documentation! But maybe worth it?).</span><br><span class="line"># Any script that conforms to the documented &quot;interface&quot; of the name or</span><br><span class="line"># group can fill in for it.</span><br></pre></td></tr></table></figure>

<p>将访问权限外包给 Callable。当需要最大程度地摆脱依赖时，这种方法可能很有用。在这种情况下，人们依赖外部上下文来设置该方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># child.gd</span><br><span class="line">extends Node</span><br><span class="line">var fn = null</span><br><span class="line"></span><br><span class="line">func my_method():</span><br><span class="line">	if fn:</span><br><span class="line">		fn.call()</span><br><span class="line"></span><br><span class="line"># parent.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">@onready var child = $Child</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	child.fn = print_me</span><br><span class="line">	child.my_method()</span><br><span class="line"></span><br><span class="line">func print_me():</span><br><span class="line">	print(name)</span><br></pre></td></tr></table></figure>

<h3 id="Godot-通知"><a href="#Godot-通知" class="headerlink" title="Godot 通知"></a>Godot 通知</h3><p>Godot 中的每个对象都实现了 _notification 方法。其目的是允许对象响应可能与之相关的各种引擎级回调。<br>例如，如果引擎告诉 CanvasItem 去“绘制”，则它将调用 _notification(NOTIFICATION_DRAW)。</p>
<p>在所有这些通知之中，有很多类似“绘制”这样经常需要在脚本中去覆盖的通知，多到 Godot 要提供专用函数的地步：<br>_ready(): NOTIFICATION_READY<br>_enter_tree(): NOTIFICATION_ENTER_TREE<br>_exit_tree(): NOTIFICATION_EXIT_TREE<br>_process(delta): NOTIFICATION_PROCESS<br>_physics_process(delta): NOTIFICATION_PHYSICS_PROCESS<br>_draw(): NOTIFICATION_DRAW</p>
<p>用户可能不会意识到 Node 之外的类型也有通知，例如：<br>Object::NOTIFICATION_POSTINITIALIZE：在对象初始化期间触发的回调。脚本无法访问。<br>Object::NOTIFICATION_PREDELETE：在引擎删除 Object 之前触发的回调，即析构函数。<br>并且 Node 中存在的许多回调没有任何专用的方法，但仍然非常有用。<br>Node::NOTIFICATION_PARENTED: 将子节点添加到另一个节点时，会触发此回调。<br>Node::NOTIFICATION_UNPARENTED: 将子节点从另一个节点下删除时，会触发此回调。<br>你可以在通用的 _notification() 方法中访问所有这些自定义通知。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
文档中被标记为“virtual”的方法（即虚方法）可以被脚本覆盖重写。<br>
一个经典的例子是 Object 中的 _init 方法。<br>
虽然它没有等效的 NOTIFICATION_* 通知，但是引擎仍然会调用该方法。大多数语言（C#除外）都将其用作构造函数。
</p>
所以说，应该在哪些情况下使用这些通知或虚函数呢？

<h4 id="对比-process、-physics-process、-input"><a href="#对比-process、-physics-process、-input" class="headerlink" title="对比 _process、_physics_process、*_input"></a>对比 _process、_physics_process、*_input</h4><p>当需要使用“依赖于帧速率的 delta 时间增量”时，请使用 _process。如果需要尽可能频繁地更新对象数据，也应该在这里处理。频繁执行的逻辑检查和数据缓存操作，大多数都在这里执行。但也需要注意执行频率，如果不需要每帧都执行，则可以选择用定时器循环来替代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Allows for recurring operations that don&#x27;t trigger script logic</span><br><span class="line"># every frame (or even every fixed frame).</span><br><span class="line">func _ready():</span><br><span class="line">	var timer = Timer.new()</span><br><span class="line">	timer.autostart = true</span><br><span class="line">	timer.wait_time = 0.5</span><br><span class="line">	add_child(timer)</span><br><span class="line">	timer.timeout.connect(func():</span><br><span class="line">		print(&quot;This block runs every 0.5 seconds&quot;)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>当需要与帧速率无关的时间增量时，请使用 _physics_process。如果代码需要随着时间的推移进行一致的更新，不管时间推进速度是快还是慢，那么就应该在这里执行代码。频繁执行的运动学和对象变换操作，应在此处执行。</p>
<p>为了获得最佳性能，应尽可能避免在这些回调期间进行输入检查。_process 和 _physics_process 每次都会触发（默认情况下这些更新回调不会 “休眠”）。相反，*_input 回调仅在引擎实际检测到输入的帧上触发。</p>
<p>在 input 回调中同样可以检查输入动作。如果要使用增量时间，则可以使用相关的增量时间获取方法来获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Called every frame, even when the engine detects no input.</span><br><span class="line">func _process(delta):</span><br><span class="line">	if Input.is_action_just_pressed(&quot;ui_select&quot;):</span><br><span class="line">		print(delta)</span><br><span class="line"></span><br><span class="line"># Called during every input event.</span><br><span class="line">func _unhandled_input(event):</span><br><span class="line">	match event.get_class():</span><br><span class="line">		&quot;InputEventKey&quot;:</span><br><span class="line">			if Input.is_action_just_pressed(&quot;ui_accept&quot;):</span><br><span class="line">				print(get_process_delta_time())</span><br></pre></td></tr></table></figure>

<h4 id="对比-init、初始化、导出"><a href="#对比-init、初始化、导出" class="headerlink" title="对比 _init、初始化、导出"></a>对比 _init、初始化、导出</h4><p>如果脚本初始化它自己的没有场景的节点子树，则该代码将会在 _init() 中执行。其他属性或独立于 SceneTree 的初始化也应在此处运行。<br>_init() 在 _enter_tree() 或 _ready() 之前触发，但在脚本创建并初始化其属性之后。实例化场景时，属性值将按照以下顺序设置：<br>初始值赋值：为属性赋初始值，未指定初始值时赋默认值。Setter 函数即便存在也不会使用。<br><code>_init()</code> 赋值：在 _init() 中通过各种赋值改变属性的取值，会触发 setter 函数。<br>导出值赋值：如果在“检查器”中修改了导出属性的值，就会再次修改该属性的值，会触发 setter 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># test is initialized to &quot;one&quot;, without triggering the setter.</span><br><span class="line">@export var test: String = &quot;one&quot;:</span><br><span class="line">	set(value):</span><br><span class="line">		test = value + &quot;!&quot;</span><br><span class="line"></span><br><span class="line">func _init():</span><br><span class="line">	# Triggers the setter, changing test&#x27;s value from &quot;one&quot; to &quot;two!&quot;.</span><br><span class="line">	test = &quot;two&quot;</span><br><span class="line"></span><br><span class="line"># If someone sets test to &quot;three&quot; from the Inspector, it would trigger</span><br><span class="line"># the setter, changing test&#x27;s value from &quot;two!&quot; to &quot;three!&quot;</span><br></pre></td></tr></table></figure>
<p>因此，选择实例化脚本还是实例化场景，对初始化和引擎调用 setter 的次数都会产生影响。</p>
<h4 id="对比-ready、-enter-tree、NOTIFICATION-PARENTED"><a href="#对比-ready、-enter-tree、NOTIFICATION-PARENTED" class="headerlink" title="对比 _ready、_enter_tree、NOTIFICATION_PARENTED"></a>对比 _ready、_enter_tree、NOTIFICATION_PARENTED</h4><p>将场景实例化并首次添加到运行的场景树时，Godot 会沿着场景树从上至下实例化节点（调用 _init() 函数），再从根节点出发从上至下构建场景树。因此 _enter_tree() 是按照树的顺序从上至下一级一级调用的。场景树构建完成后，所有叶节点就会调用 _ready。一个节点的所有子节点都调用完该方法后，就会轮到该节点自己调用。此时就是逆着树的顺序从下至上一级一级调用的，最终到达根节点。</p>
<p>当实例化脚本或独立的场景时，节点不会在创建时被添加到 SceneTree 中，所以未触发 _enter_tree 回调。而只有 _init 调用发生。当场景被添加到 SceneTree 时，才会调用 _enter_tree 和 _ready。</p>
<p>如果需要触发作为节点设置父级到另一个节点而发生的行为, 无论它是否作为在主要&#x2F;活动场景中的部分发生, 都可以使用 PARENTED 通知. 例如, 这有一个将节点方法连接到其父节点上自定义信号, 而不会失败的代码段。对可能在运行时创建并以数据为中心的节点很有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">var parent_cache</span><br><span class="line"></span><br><span class="line">func connection_check():</span><br><span class="line">	return parent_cache.has_user_signal(&quot;interacted_with&quot;)</span><br><span class="line"></span><br><span class="line">func _notification(what):</span><br><span class="line">	match what:</span><br><span class="line">		NOTIFICATION_PARENTED:</span><br><span class="line">			parent_cache = get_parent()</span><br><span class="line">			if connection_check():</span><br><span class="line">				parent_cache.interacted_with.connect(_on_parent_interacted_with)</span><br><span class="line">		NOTIFICATION_UNPARENTED:</span><br><span class="line">			if connection_check():</span><br><span class="line">				parent_cache.interacted_with.disconnect(_on_parent_interacted_with)</span><br><span class="line"></span><br><span class="line">func _on_parent_interacted_with():</span><br><span class="line">	print(&quot;I&#x27;m reacting to my parent&#x27;s interaction!&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="数据偏好"><a href="#数据偏好" class="headerlink" title="数据偏好"></a>数据偏好</h3><h4 id="数组、字典、对象"><a href="#数组、字典、对象" class="headerlink" title="数组、字典、对象"></a>数组、字典、对象</h4><p>Godot 把脚本 API 中的所有变量都存储在<code>Variant</code>(存储兼容数据结构)中。<br>例如 Array（数组）、 Dictionary（字典）、 Object（对象）。</p>
<p>Godot 使用 Vector<Variant> 实现数组。<br>将数组内容存储在一段连续的内存之中，也就是说，元素与元素之间是相邻的。</p>
<blockquote>
<p>这里的 Vector 是传统 C++ STL 库中数组对象的名称，是个“模板”类型，即它只能存储特定类型的数据（用尖括号表示）。<br>例如，PackedStringArray 其实就类似于 Vector<String>。<br>因为是在内存中连续存储，所以执行各种操作的性能如下：<br>迭代：最快，非常适合循环。</p>
</blockquote>
<ul>
<li>操作：把计数器加一即可获取下一个元素。</li>
</ul>
<p>插入、删除、移动：与位置相关，一般较慢。</p>
<ul>
<li>操作：元素的添加、删除、移动需要移动与之相邻的元素（腾出地方或者填充空缺）。</li>
<li>在末尾添加、删除很快。</li>
<li>在任意位置添加、删除较慢。</li>
<li>在开头添加、删除最慢。</li>
<li>如果需要在开头执行多次插入、删除操作，那么……<ol>
<li>反转数组。</li>
<li>通过循环在末尾执行数组更改。</li>
<li>再把数组反转回来。<br>  这样就只复制了两次数组（虽然比较慢，但还是常数时间），否则就得把平均大概一半的数组复制 N 遍（线性时间）。</li>
</ol>
</li>
</ul>
<p>取值、设值：因为是按位置存取的，所以最快。例如你可以请求第 0 个、第 2 个、第 10 个等等的元素，但不能按照元素的值来请求。</p>
<ul>
<li>操作：把起始位置做一次加法，得到所需的索引。</li>
</ul>
<p>查找：最慢。根据值获取索引，也就是位置。</p>
<ul>
<li><p>操作：必须遍历数组，一个个元素做比较，直到找到匹配的为止。</p>
<ul>
<li>性能同时也取决于是否需要查遍整个数组才能找到目标。</li>
</ul>
</li>
<li><p>如果数组能够保持一定的顺序，自定义搜索操作可以缩短到对数时间（相对而言很快）。不过外行用户不会对此感到满意。做法是每次编辑后都重新对 Array 进行排序，编写利用已排序特性的搜索算法。</p>
</li>
</ul>
<p>Godot 将 Dictionary 实现为 HashMap&lt;Variant, Variant, VariantHasher, StringLikeVariantComparator&gt; .<br>引擎存储一个键值对的小数组（初始化为 2^3 或 8 条记录）。<br>当人们尝试访问一个值时，他们会为其提供一个密钥。然后它对密钥进行哈希处理 ，即将它转换为一个数字。<br>“哈希”用于计算数组中的索引。作为一个数组，HM 在映射到值的键的“表”中进行快速查找。<br>当 HashMap 变得太满时，它会增加到 2 的下一个幂（因此，16 条记录，然后是 32 条记录，依此类推）并重建结构。</p>
<p>使用哈希是为了减少键的冲突几率。发生冲突时，哈希表必须重新计算索引号，将占据原有位置的值纳入考虑范围。<br>总之，这样做就能够以牺牲内存和一些较小的操作效率为代价，让所有记录的访问都达到常数时间。</p>
<ol>
<li><p>对每个键进行任意次哈希。<br>哈希操作是常量时间的，因此即使某个算法必须执行多次，只要哈希的计算次数与表的密度没有什么大关系，那么就能够保持较快的速度。这样……</p>
</li>
<li><p>保持不断增长的表规模.<br>HashMaps为了减少哈希冲突, 并保持访问速度, 在表中保留了未使用的内存的间隙. 这就是为什么它总是会以2幂为倍数扩展其容量.</p>
</li>
</ol>
<p>如大家所知，字典擅长的任务是数组所不擅长的。其操作细节概述如下：</p>
<ul>
<li>迭代 : 快速.<ul>
<li>操作: 遍历映射的内部散列向量. 返回每个键. 之后, 用户使用该键跳转到并返回所需的值.</li>
</ul>
</li>
<li>插入, 删除, 移动 : 最快.<ul>
<li>操作: 散列给定的键. 执行1个加法操作来查找适当的值(数组开始+偏移量). 移动其中的两个(一个插入, 一个擦除). 映射必须进行一些维护, 以保留其功能:<ol>
<li>更新记录的有序列表.</li>
<li>确定列表密度, 是否需要扩展列表容量.</li>
</ol>
</li>
<li>字典会记住用户插入键的顺序. 这使它能够执行可靠的迭代.</li>
</ul>
</li>
<li>取值, 设值 : 最快. 和 根据键 查找相同.<ul>
<li>操作: 和插入&#x2F;删除&#x2F;移动类似.</li>
</ul>
</li>
<li>查找 : 最慢. 标识值的键.<ul>
<li>操作: 必须遍历记录并比较该值, 直到找到匹配的为止.</li>
<li>请注意,Godot并未开箱即用地提供此功能(因为它们并非用于此任务).</li>
</ul>
</li>
</ul>
<p>Godot用愚蠢, 但动态的方式容纳数据容器实现对象. 提出问题时, 对象将查询数据源.<br>例如, 要回答”你是否有一个名为 position 的属性？”的问题, 它可能会询问其 script 或 ClassDB. </p>
<p>这里重要的细节是对象任务的复杂性. 每次执行这些多源查询时, 它运行 几个 迭代循环和哈希表查找. 此外, 查询是线性时间操作, 依赖于对象的继承层次结构大小. 如果 Object 查询的类(当前类)什么都没有找到, 则该请求将一直推迟到下一个基类, 一直到原始 Object 类为止. 虽然这些都是单独的快速操作, 但它必须进行如此多的检查, 于是这一事实使得它们比查找数据的两种方法都要慢.</p>
<blockquote>
<p>当开发人员提到脚本API有多慢时, 所引用的正是这一系列查询. 与编译后的, 应用程序知道在哪里可以找到任何东西的,C++代码相比, 不可避免的是, 脚本API操作将花费更长的时间. 他们必须定位任何相关数据的来源, 然后才能尝试访问它.<br>GDScript 很慢的原因是, 它执行的每个操作都要经过这个系统.<br>C#可以通过更优化的字节码, 以更快的速度处理一些内容. 但是, 如果C#脚本调用引擎类的内容, 或者脚本试图访问它的外部内容, 它会通过这个管道.<br>NativeScript C++甚至更进一步, 默认将所有内容都保持在内部. 对外部结构的调用将通过脚本API进行. 在NativeScript C++中, 注册方法以将其公开给脚本API是一项手动任务. 至此, 外部非C++类将使用API来查找它们.</p>
</blockquote>
<p>因此, 假设从引用扩展到创建数据结构, 比如一个 Array 或 Dictionary, 为什么选择一个 Object 而不是其他两个选项？<br>控件 : 对象能够创建更复杂的结构. 可以在数据上分层抽象, 以确保外部API不会响应内部数据结构的更改. 更重要的是, 对象可以有信号, 允许响应式行为. 对象带来了创建更复杂结构的能力.<br>清晰 : 当涉及到脚本和引擎类为对象定义的数据时, 对象是一个可靠的数据源. 属性可能不包含期望的值, 但是无需担心这个属性是否首先存在.<br>便利 : 如果已经有了类似的数据结构, 之后从现有类扩展, 可以使构建数据结构的任务变得容易得多. 相比之下, 数组和字典不能满足所有的用例.</p>
<p>对象还让用户有机会创建更专门化的数据结构。有了它，一个人可以设计自己的列表、二叉搜索树、堆、散列树、图、不相交集，以及其他选择。<br>“为什么不在树结构中使用节点？” 有人可能会问. 节点类包含与自定义数据结构无关的内容. 因此在构建树结构时, 构造自己的节点类型是很有帮助的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extends Object</span><br><span class="line">class_name TreeNode</span><br><span class="line"></span><br><span class="line">var _parent: TreeNode = null</span><br><span class="line">var _children := []</span><br><span class="line"></span><br><span class="line">func _notification(p_what):</span><br><span class="line">	match p_what:</span><br><span class="line">		NOTIFICATION_PREDELETE:</span><br><span class="line">			# Destructor.</span><br><span class="line">			for a_child in _children:</span><br><span class="line">				a_child.free()</span><br></pre></td></tr></table></figure>
<p>这里开始, 然后就可以创建具有特定功能的结构, 只会受到他们想象力的限制.</p>
<h4 id="枚举：整数-VS-字符串"><a href="#枚举：整数-VS-字符串" class="headerlink" title="枚举：整数 VS 字符串"></a>枚举：整数 VS 字符串</h4><p>大多数语言都提供了枚举类型，GDScript 也不例外。但与其他大多数语言不同的是，GDScript 的枚举允许开发者使用整数或字符串作为枚举值（后者只有在 GDScript 中使用 @export_enum 注解时才可以使用）。 那么问题来了：“该用哪一种枚举？”<br>简单回答一下就是：“你觉得哪个更舒服就选哪个。” 这是 GDScript 特有的特性，并非（C++、C#等）一般的 Godot 脚本所特有的特性；该语言将可用性置于性能之上。<br>在技术层面上，整数比较（常量时间）比字符串比较（线性时间）更快，若想保持其他语言中使用枚举的习惯，则应使用整数来表示枚举值。<br>当你想要 打印 枚举值时，使用整数的主要问题就出现了：尝试直接打印以 int 型保存的枚举 MY_ENUM 会打印 5 之类的东西，而不是像 MyEnum 这样的字符。若要打印以 int 型保存的枚举。必须编写一个字典来映射每个枚举所对应的字符串值。<br>如果开发者使用枚举的主要目的是打印值，并希望将它们作为相关概念组合在一起，那么将枚举作为字符串使用是有意义的。这样一来，也就不需要在打印上执行单独的数据结构了。</p>
<h4 id="AnimatedTexture-vs-AnimatedSprite2D-vs-AnimationPlayer-vs-AnimationTree"><a href="#AnimatedTexture-vs-AnimatedSprite2D-vs-AnimationPlayer-vs-AnimationTree" class="headerlink" title="AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree"></a>AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree</h4><p>在什么情况下应该使用Godot的各种动画类？对于Godot的新用户来说, 可能不是马上清楚答案.</p>
<p>AnimatedTexture 是引擎绘制一个动画循环, 而不是一个静态图像的纹理. 用户可以进行如下操作：</p>
<ol>
<li>它在纹理的每个部分移动的速率（FPS）。</li>
<li>纹理中包含的区域数(帧).</li>
</ol>
<p>Godot 的 RenderingServer 会按照规定的速度依次绘制区块。好处是不涉及引擎部分额外的逻辑。坏处是用户几乎没有控制权。</p>
<p>另外请注意，AnimatedTexture 是一种 Resource，与此处讨论的其他 Node 对象不同。可以创建 Sprite2D 节点，使用 AnimatedTexture 作为其纹理。或者（仅在其他方法无法满足要求时）可以将 AnimatedTexture 作为图块添加到 TileSet 中并将其与 TileMapLayer 集成到一起，从而获得自动动画化的背景。使用此方法时所有的渲染将在单个批处理内绘制调用。</p>
<p>AnimatedSprite2D 节点可以与 SpriteFrames 资源结合使用，使用户可以通过精灵表创建各种动画序列、在动画之间切换并控制它们的速度、区域偏移量和方向。<br>这使得它们非常适合控制基于二维的帧动画。</p>
<p>若需要触发与动画更改相关的其他效果，例如创建粒子效果、调用函数或操作与帧动画无关的其他外围元素，则需要将一个 AnimationPlayer 节点与 AnimatedSprite2D 关联。</p>
<p>如果你想设计更复杂的二维动画系统，AnimationPlayer 也是你的必备工具，例如：</p>
<ol>
<li>剪纸动画：在运行时编辑精灵的变换。</li>
<li>二维网格动画：为精灵的纹理划分一个区域，并将骨架绑定在上面。然后动画化其中的骨骼，使骨骼按照彼此之间的关系，成比例地拉伸和弯曲纹理。</li>
</ol>
<p>虽然我们需要一个 AnimationPlayer, 来为游戏设计每个独立的动画序列, 它也可以用来混合复合动画, 也就是说, 在这些动画之间实现平滑的转换. 在为对象规划的动画之间, 也可能存在一个层次结构. 在这些情况下使用 AnimationTree 效果很出色. 可以在 这里 找到关于使用 AnimationTree 的深入指南.</p>
<h3 id="逻辑偏好"><a href="#逻辑偏好" class="headerlink" title="逻辑偏好"></a>逻辑偏好</h3><h4 id="先添加节点还是先修改属性？"><a href="#先添加节点还是先修改属性？" class="headerlink" title="先添加节点还是先修改属性？"></a>先添加节点还是先修改属性？</h4><p>运行时使用脚本初始化节点时，你可能需要对节点的名称、位置等属性进行修改。常见的纠结点在于，你应该什么时候去修改？<br>最佳实践是在节点加入场景树之前修改取值。<br>部分属性的 setter 代码会更新其他对应的值，可能会比较慢！<br>大多数情况下，这样的代码不会对游戏的性能产生影响，但对于程序式生成之类的重型使用场景，就可能让游戏卡成 PPT。</p>
<p>综上，最佳的做法就是<strong>先为节点设置初始值，然后再把它添加到场景树中</strong>。<br>有值在被加入场景树之前不能被设置的例外情况，比如设置世界坐标的时候。</p>
<h4 id="加载-VS-预加载"><a href="#加载-VS-预加载" class="headerlink" title="加载 VS 预加载"></a>加载 VS 预加载</h4><p>在 GDScript 中，存在全局 preload 方法。它尽可能早地加载资源，以便提前进行“加载”操作，并避免在执行性能敏感的代码时加载资源。<br>其对应的 load 方法只有在执行 load 语句时才会加载资源。也就是说，它将立即加载资源。所以，在敏感进程中加载资源会造成速度减慢。<br>load() 函数是可以被所有脚本语言访问的 ResourceLoader.load(path) 的别名。</p>
<p>那么, 预加载和加载到底在什么时候发生, 又应该什么时候使用这两种方法呢？我们来看一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># my_buildings.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line"># 注意：常量脚本/场景的命名方式与其作为属性的变体不同。</span><br><span class="line"></span><br><span class="line"># 这个值是常量，因此在脚本对象加载时就会生成。</span><br><span class="line"># 脚本会预加载这个值。这样做的好处是，由于路径是静态的，编辑器可以提供自动补全功能。</span><br><span class="line">const BuildingScn = preload(&quot;res://building.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># 1. 脚本会预加载该值，因此它将成为 &#x27;my_buildings.gd&#x27; 脚本文件的一个依赖项。</span><br><span class="line">#    但由于这是一个属性而不是常量，预加载的 PackedScene 资源不会复制到该属性中，</span><br><span class="line">#    直到脚本通过 .new() 实例化时才会发生。</span><br><span class="line">#</span><br><span class="line"># 2. 仅通过脚本对象本身无法访问预加载的值。因此，在此处预加载实际上对任何人都没有好处。</span><br><span class="line">#</span><br><span class="line"># 3. 因为用户导出了这个值，如果此脚本存储在场景文件中的某个节点上，</span><br><span class="line">#    场景实例化代码将覆盖预加载的初始值（导致预加载的值被浪费）。</span><br><span class="line">#    对于导出的变量，通常最好提供 null、空值或其它无效的默认值。</span><br><span class="line">#</span><br><span class="line"># 4. 只有当用户通过 .new() 单独实例化该脚本时，才会加载 &quot;office.tscn&quot;，</span><br><span class="line">#    而不是使用导出的值。这种情况下才会真正生效。</span><br><span class="line">@export var a_building : PackedScene = preload(&quot;office.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># 这会导致一个错误！</span><br><span class="line"># 常量必须用常量值初始化。因为 `load` 本质上是在运行时进行查找，</span><br><span class="line"># 所以不能用它来初始化常量。</span><br><span class="line">const OfficeScn = load(&quot;res://office.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># 成功加载，并且仅在实例化脚本时才加载！</span><br><span class="line">var office_scn = load(&quot;res://office.tscn&quot;)</span><br></pre></td></tr></table></figure>
<p>预加载允许脚本在加载脚本时处理所有加载. 预加载是有用的, 但也有一些时候, 人们并不希望这样.<br>为了区分这些情况, 我们可以考虑以下几点:</p>
<ol>
<li>如果无法确定何时可以加载脚本, 则预加载资源, 尤其是场景或脚本, 可能会导致进一步加载, 这是人们所不希望的. 这可能会导致无意中, 在原始脚本的加载操作之上的可变长度加载时间. 在原始脚本的加载操作之上, 这可能导致意外的, 可变长度的加载时间.</li>
<li>如果其他东西可以代替该值(例如场景导出的初始化), 则预加载该值没有任何意义. 如果打算总是自己创建脚本, 那么这一点并不是重要因素.</li>
<li>如果只希望“导入”另一个类资源（脚本或者场景），那么最好的解决方法就是使用预加载常量（Preloaded Constant）。不过也有例外的情况：<ol>
<li>如果“导入”的类有可能发生变化，那么就应该是属性，使用 @export 或 load() 初始化（或者甚至更晚一些才初始化）。</li>
<li>如果脚本需要大量依赖关系，又不想消耗太多内存，则可以在环境变化时动态地加载或卸载各种依赖关系。如果将资源预加载为常量，则卸载这些资源的唯一方法是卸载整个脚本。如果改为加载属性，则可以将它们设置为 null 并完全删除对资源的所有引用（扩展自 RefCounted 的类型会在指向其的所有引用均已消失时自动释放内存）。</li>
</ol>
</li>
</ol>
<h4 id="大型关卡：静态-VS-动态"><a href="#大型关卡：静态-VS-动态" class="headerlink" title="大型关卡：静态 VS 动态"></a>大型关卡：静态 VS 动态</h4><p>如果正在创建一个大型关卡, 哪种情况是最合适的？<br>他们应该将关卡创建为一个静态空间吗？<br>还是他们应该分阶段加载关卡, 并根据需要改变世界的内容？</p>
<p>答案很简单，“当性能需要的时候”。与这两种选择有关的困境是一种古老的编程选择：优化内存还是速度？<br>最简单的方法是使用静态关卡, 它可以一次加载所有内容. 但是, 这取决于项目, 这可能会消耗大量内存. 浪费用户的运行内存会导致程序运行缓慢, 或者计算机在同一时间尝试做的所有其他事情都会崩溃.<br>无论如何，应该将较大的场景分解为较小的场景（以利于资产重用）。然后，开发人员可以设计一个节点，该节点实时管理资源和节点的创建&#x2F;加载和删除&#x2F;卸载。具有大型多样环境或程序生成的元素的游戏，通常会实行这些策略，以避免浪费内存。<br>另一方面, 对动态系统进行编码更复杂, 即, 使用更多的编程逻辑, 这会导致出现错误和bug的机会. 如果不小心的话, 开发的系统, 会增加应用程序的技术成本.</p>
<p>因此, 最好的选择是…</p>
<ol>
<li>在小型游戏中使用静态关卡.</li>
<li>在开发中型&#x2F;大型游戏时, 可以去创建一个可以对节点和资源的管理进行编码的库或插件.<br> 如果随着时间的流逝而改进, 以提高可用性和稳定性, 那么它可能会演变成跨项目的可靠工具.</li>
<li>为一款中&#x2F;大型游戏编写动态逻辑代码, 因为你拥有编程技能, 但却没有时间或资源去完善代码(必须要完成游戏). 以后可能会进行重构, 将代码外包到插件中.</li>
</ol>
<h3 id="项目组织"><a href="#项目组织" class="headerlink" title="项目组织"></a>项目组织</h3><h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>有两种种方法来组织项目:</p>
<ol>
<li>根据场景分别放置场景所需要的资源。（推荐）</li>
<li>创建一个专门的文件夹，并在其中放置所有资源。</li>
</ol>
<h4 id="风格指南"><a href="#风格指南" class="headerlink" title="风格指南"></a>风格指南</h4><p>为了项目之间的一致性，我们建议遵循以下规范：</p>
<ol>
<li>使用 snake_case 风格为文件夹和文件命名(除了c#脚本).<br> 这避免了在 Windows 上导出项目时可能出现的大小写敏感问题.C# 脚本是这个规则的一个例外, 因为按照惯例是用类名来对它们命名, 而类名应该是 PascalCase 风格.</li>
<li>使用 PascalCase 风格对节点进行命名, 这与内置的节点大小写风格一致.</li>
<li>通常, 将第三方资源放在顶级的 addons&#x2F; 文件夹中, 即使它们不是编辑器插件. 这样更加容易跟踪哪些文件是第三方文件.<br> 当然这个规则也有一些例外: 如果你要使用第三方游戏资源创建角色, 将这些资源和角色场景及脚本放在同一文件夹下会更好.</li>
</ol>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>因此，现在可以从项目文件夹中透明地导入资产。</p>
<p>忽略具体文件夹<br>为防止 Godot 导入特定文件夹中的文件, 请在文件夹中创建一个名为 .gdignore 的空文件(以 . 号开头). 这对于加快初始项目导入非常有用.</p>
<blockquote>
<p>要在 Windows 上创建文件名以点开头的文件，请在文件名的前后都写一个点（“.gdignore.”）。确认之后 Windows 会自动移除末尾的点。<br>你也可以使用文本编辑器来创建它，例如记事本。或在命令提示符中输入以下命令：type nul &gt; .gdignore<br>一旦文件夹被忽略，其中资源就不能再使用 load() 和 preload() 方法加载。被忽略文件夹会从文件系统栏目中隐藏，从而减少混乱。<br>请注意 .gdignore 文件的内容会被忽略，因此该文件应当为空。它不像 .gitignore 文件一样支持模式匹配。</p>
</blockquote>
<h4 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h4><p>Windows 和最近版本的 macOS 默认使用不区分大小写的文件系统，而 Linux 发行版默认使用区分大小写的文件系统。<br>由于 Godot 的 PCK 虚拟文件系统区分大小写，因此在导出项目后可能会导致问题。<br>为了避免这种情况，建议对项目中的所有文件都使用 snake_case 蛇形命名法（一般使用小写）。</p>
<h3 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h3><p>版本控制插件<br>Godot 旨在对版本控制系统（Version Control System，VCS）友好，并尽量生成可读且可合并的文件。<br>Godot 支持通过插件在编辑器本身中使用 VCS。可以在编辑器中的项目&gt; 版本控制下设置或关闭 VCS。</p>
<blockquote>
<p>截至 2023 年 7 月，尚且只有一个 Git 插件可用，但社区可能会创建其他的 VCS 插件。</p>
</blockquote>
<p>官方 Git 插件<br>可以在GitHub找到最新的版本。<br>最新的更新、文档和源代码可以在 Godot iOS 插件库找到<code>Godot iOS plugins repository</code>。</p>
<p>从 VCS 中排除的文件<br>当第一次在编辑器中打开项目时，Godot 会自动创建一些文件和文件夹。 为了避免生成的数据使版本控制仓库膨胀，你应该将它们添加到 VCS 忽略中：</p>
<ul>
<li>.godot&#x2F;：此文件夹存储各种项目缓存数据。</li>
<li>*.translation：这些文件是从 CSV 文件生成的导入后的的二进制翻译文件。</li>
</ul>
<p>你可以选择在 Godot 项目管理器创建项目时自动生成版本控制元数据。<br>当选择 Git 选项时，将在项目根目录中创建 .gitignore 和 .gitattributes 文件：<br>在现有的项目中，选择编辑器顶部的 项目 菜单，然后选择 版本控制 &gt; 生成版本控制元数据。<br>这将与在项目管理器中执行的操作一样创建相同的文件。</p>
<p>在 Windows 上使用 Git<br>大多数 Git for Windows 客户端都将 core.autocrlf 设置为 true。<br>可能会导致部分文件错误地被 Git 标记为已修改，因为这些文件的行尾被自动从 LF 转换成了 CRLF。</p>
<p>最好将此选项设置为：<br><code>git config --global core.autocrlf input</code><br>使用项目管理器或编辑器创建版本控制元数据时，会使用 .gitattributes 文件自动强制使用 LF 行尾，因此无需更改 Git 配置。</p>
<p>Git LFS<br>Git LFS（大文件存储）是一个 Git 扩展，允许管理存储库中的大文件。<br>用 Git 中的文本指针替换大文件，同时将文件内容存储在远程服务器上。<br>这对于管理大型资产（例如纹理、音频文件和 3D 模型）非常有用，而不会使 Git 存储库膨胀。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
使用 Git LFS 时，您需要确保在将任何文件提交到存储库之前已设置它。<br>
如果您已经将文件提交到存储库，则需要将它们从存储库中删除，并在设置 Git LFS 后重新添加它们。<br>
可以使用 git lfs migrate 来转换存储库中的现有文件，但这更深入，需要对 Git 有很好的了解。<br>
一种常见的方法是使用 Git LFS（和适当的 .gitattributes）设置一个新存储库，然后将文件从旧存储库复制到新存储库。<br>
这样，您可以确保所有文件从一开始就被 LFS 跟踪。
</p>
要将 Git LFS 与 Godot 一起使用，您需要安装 Git LFS 扩展并将其配置为跟踪要管理的文件类型。
您可以通过在终端中运行以下命令来执行此作：
这将在您的存储库中创建一个 .gitattributes 文件，该文件告诉 Git 对指定的文件类型使用 LFS。
可以通过修改 .gitattributes 文件来添加更多文件类型。
例如，要跟踪所有 GLB 文件，您可以通过在终端中运行以下命令来执行此作：git lfs track "*.glb"

<p>当添加或修改 LFS 跟踪的文件时，Git 会自动将它们存储在 LFS 中，而不是常规的 Git 历史记录中。<br>可以像常规 Git 文件一样推送和拉取 LFS 文件，但请记住，LFS 文件与 Git 历史记录的其余部分分开存储。<br>这意味着可能需要在将存储库克隆到的任何计算机上安装 Git LFS 才能访问 LFS 文件。<br>下面是一个示例 .gitattributes 文件，可以将其用作 Git LFS 的起点。<br>之所以选择这些文件类型，是因为它们常用，但您可以修改列表以包含项目中可能拥有的任何二进制类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># Normalize EOL for all files that Git considers text files.</span><br><span class="line">* text=auto eol=lf</span><br><span class="line"></span><br><span class="line"># Git LFS Tracking (Assets)</span><br><span class="line"></span><br><span class="line"># 3D Models</span><br><span class="line">*.fbx filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.gltf filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.glb filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.blend filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.obj filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Images</span><br><span class="line">*.png filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.svg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.jpg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.jpeg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.gif filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.tga filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.webp filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.exr filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.hdr filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.dds filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Audio</span><br><span class="line">*.mp3 filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.wav filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.ogg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Font &amp; Icon</span><br><span class="line">*.ttf filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.otf filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.ico filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Godot LFS Specific</span><br><span class="line">*.scn filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.res filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.material filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.anim filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.mesh filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.lmbake filter=lfs diff=lfs merge=lfs -text</span><br></pre></td></tr></table></figure>
<p>有关 Git LFS 的更多信息，请查看官方文档： <a target="_blank" rel="noopener" href="https://git-lfs.github.com/">https://git-lfs.github.com/</a> 和 <a target="_blank" rel="noopener" href="https://docs.github.com/en/repositories/working-with-files/managing-large-files%E3%80%82">https://docs.github.com/en/repositories/working-with-files/managing-large-files。</a></p>
<h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><ol>
<li>编辑器运行缓慢，占用所有的 CPU 和 GPU 资源<br>尤其是在 macOS 上，因为大多数 Mac 都有 Retina 显示屏。<br>由于 Retina 显示器的像素密度更高，因此所有内容都必须以更高的分辨率渲染。会增加 GPU 上的负载并降低感知性能。</li>
</ol>
<p>有几种衡量性能和电池续航的方法：</p>
<ul>
<li>在 3D 模式下，单击左上角的透视按钮并启用半分辨率。现在 3D 视口就会以半分辨率渲染，速度最多可以提高到原来的 4 倍。</li>
<li>打开编辑器设置并将低处理器模式睡眠（微秒）的值增加到 33000（30 FPS）。该值决定了渲染每帧画面之间所间隔的时间（微秒单位）。 较高的值将会使编辑器操作起来没有那么跟手，但可显著降低 CPU 和 GPU 使用率。</li>
<li>如果有某个节点导致编辑器连续重新绘制（例如粒子），请将其隐藏并在脚本中使用 _ready() 方法显示它。这样，它将隐藏在编辑器中，但仍在正在运行的项目中可见。</li>
</ul>
<ol start="2">
<li>编辑器在可变刷新率显示器（G-Sync&#x2F;FreeSync）上出现卡顿和闪烁的情况？<br>可变刷新率显示器需要不断调整其伽玛曲线，以便随着时间的推移发出一致的光量。<br>当刷新率变化很大时，这可能会导致图像的黑暗区域出现闪烁，这是因为 Godot 编辑器仅在必要时重绘。</li>
</ol>
<p>这有几种解决办法：</p>
<ul>
<li>在编辑器设置中启用界面 &gt; 编辑器 &gt; 持续更新。即使画面没有变化，编辑器也将不断渲染。请注意，这会增加功耗、加大热量和噪音排放。<br>为了缓解这种情况，你可以在编辑器设置中将低处理器模式睡眠（微秒）增加到 33000（30 FPS）。<br>该值决定了渲染每帧画面之间所间隔的时间（微秒单位）。<br>较高的值将会使编辑器操作起来没有那么跟手，但可显著降低 CPU 和 GPU 使用率。</li>
<li>在显示器或图形驱动程序中禁用可变刷新率。</li>
<li>VRR 闪烁这个问题在某些显示器上，可以通过你的显示器的 OSD 中的 VRR 控制或微调暗区选项来减少。这些选项可能会增加输入延迟或导致黑色失真。</li>
<li>如果使用 OLED 显示器，可以在编辑器设置中使用 Black (OLED) 编辑器主题预设。因为 OLED 显示器的出色的黑阶表现，这可以隐藏 VRR 闪烁。</li>
</ul>
<ol start="3">
<li>编辑器或项目花了很长时间才启动？<br>使用基于 Vulkan 的渲染器（Forward+ 或 Mobile）时，首次启动将会花费较长的时间。<br>这是因为着色器需要先编译才能进行缓存。更新 Godot、更新显卡驱动或切换显卡后，着色器也需要重新缓存。<br>如果这个问题在首次启动后依然存在，那么这是 Windows 上的一个已知错误，当你连接了特定的 USB 外设时就会出现 。<br>特别是，海盗船的 iCUE 软件似乎引起了该错误。尝试将 USB 外设的驱动程序更新为最新版本。<br>如果错误仍然存在，则需要在打开编辑器之前断开故障外围设备的连接。然后，你可以再次连接外围设备。</li>
</ol>
<p>Portmaster 等防火墙软件可能会屏蔽调试端口，导致项目启动时间变长，并且无法在编辑器中使用调试功能（例如查看 print() 的输出）。<br>变通方法是在“编辑器设置”中修改项目所使用的调试端口（网络 &gt; 调试 &gt; 远程端口）。默认值是 6007；可以尝试设成大于 1024 的值，比如 7007。</p>
<p>在 Windows 上，当首次加载项目时，如果电脑刚开机，Windows Defender 会导致项目启动时文件系统缓存验证耗时显著增加。<br>对于文件较多的项目尤为明显。考虑通过以下步骤将项目文件夹添加到排除列表中：病毒与威胁防护 &gt; 病毒与威胁防护设置 &gt; 添加或删除排除项。</p>
<ol start="4">
<li><p>点击系统控制台后 Godot 编辑器没有响应<br>在启用了系统控制台的 Windows 上运行 Godot 时，你可以通过在命令窗口中单击来意外启用选择模式。<br>Windows 的这种特定行为会暂停应用程序，以便你在系统控制台内选择文本。Godot 无法覆盖此系统特定的行为。<br>要解决此问题，请选择系统控制台窗口，然后按 Enter 退出选择模式。</p>
</li>
<li><p>手动移动 Godot 编辑器的 macOS Dock 图标之后出现多余的编辑器图标<br>如果你打开 Godot 编辑器并手动改变 dock 图标的位置，然后重启编辑器，你会在 dock 的最右边看到一个重复的 dock 图标。<br>这是由于 macOS dock 的设计限制造成的。解决这个问题的唯一已知方法是将项目管理器和编辑器合并为一个进程，这意味着项目管理器在启动编辑器时不再产生一个单独的进程。虽然使用单一进程实例会带来一些好处，但由于任务的复杂性，完成这个功能没有列入我们近期的工作计划。<br>为了避免这个问题，保持 Godot 编辑器的 dock 图标在 macOS 创建的默认位置。</p>
</li>
<li><p>在项目管理器和编辑器窗口的左上角出现“NO DC”之类的文本<br>这是由于 NVIDIA 显卡驱动程序注入了覆盖显示信息造成的。<br>要在 Windows 上禁用此覆盖，请在 NVIDIA 控制面板中将图形驱动程序设置恢复为默认值。<br>要在 Linux 上禁用此覆盖，请打开 nvidia-settings，转到 X Screen 0 &gt; OpenGL Settings，然后取消选中 Enable Graphics API Visual Indicator。</p>
</li>
<li><p>在项目管理器和编辑器窗口右下角出现一个麦克风或刷新的图标<br>这是由于 NVIDIA 图形驱动程序注入覆盖以显示 ShadowPlay 录制的即时重播信息造成的。此覆盖只能在 Windows 上看到，因为 Linux 不支持 ShadowPlay。<br>要禁用此覆盖，请按 Alt + Z（NVIDIA 覆盖的默认快捷方式）并在 NVIDIA 覆盖中禁用设置 &gt; HUD 布局 &gt; 状态指示器。<br>你也可以选择安装取代 GeForce Experience 的新的 NVIDIA 程序 <a target="_blank" rel="noopener" href="https://www.nvidia.com/en-us/software/nvidia-app/">https://www.nvidia.com/en-us/software/nvidia-app/</a>，这样就不会遇到这个问题。与 GeForce Experience 不同的是，NVIDIA 程序会在屏幕的角落而不是每个窗口的角落绘制回放指示器。</p>
</li>
<li><p>编辑器或项目显示得过于锐利或模糊<br><img src="https://wzcwzc10.github.io/posts_img/godot/02/troubleshooting_graphics_driver_sharpening.webp"><br>可能是由于你的图形驱动程序强制对所有 Vulkan 或 OpenGL 应用程序进行图像锐化。</p>
</li>
</ol>
<p>你可以在图形驱动程序的控制面板中禁用此行为：<br>NVIDIA（Windows）：打开开始菜单，选择 NVIDIA 控制面板。打开左侧的管理 3D 设置选项卡。在中间的列表中，滚动到图像锐化，并将其设置为关闭锐化。<br>AMD（Windows）：打开开始菜单，选择 AMD 软件。点击右上角的设置 “齿轮 “图标。转到图形选项卡，然后禁用 Radeon 图像锐化。<br>如果编辑器或者项目看起来过于模糊，这可能是由于 FXAA 被你的显卡驱动强制应用到所有的 Vulkan 或者 OpenGL 应用程序上。<br>NVIDIA（Windows）：打开开始菜单并选择 NVIDIA 控制面板。打开左侧的管理 3D 设置选项卡。在中间的列表中， 滚动到平滑设置 - FXAA 并将其设置为应用程序控制的。<br>NVIDIA（Linux）：打开应用程序菜单，选择 NVIDIA X 服务器设置。在左侧选择 Antialiasing Settings，取消对 Enable FXAA 的勾选。<br>AMD（Windows）：打开开始菜单并选择 AMD Software。点击设置右上角的“齿轮”图标。转到图形选项卡， 滚动到底部并点击高级以展开其设置。禁用形态抗锯齿。</p>
<p>像是 vkBasalt 这种第三方开发的供应的工具可能会强迫所有的 Vulkan 应用程序开启锐化或者 FXAA。你可能也需要检查他们的设置。<br>当你变更过了显卡驱动和第三方工具中的设置后，重启 Godot 去应用这些设置。<br>如果你仍然希望在其他应用程序上强制锐化或 FXAA，建议你使用显卡驱动控制面板提供的应用程序配置系统，针对每个应用程序的进行设置。</p>
<ol start="9">
<li>此编辑器或项目看起来颜色很淡<br>在 Windows 上，这通常是由不正确的操作系统或显示器设置引起的，因为 Godot 目前不支持 HDR 输出（即使它可能在内部以 HDR 渲染）。<br>由于大多数显示器并非被设计为在 HDR 模式下显示 SDR 内容 <a target="_blank" rel="noopener" href="https://tftcentral.co.uk/articles/heres-why-you-should-only-enable-hdr-mode-on-your-pc-when-you-are-viewing-hdr-content">https://tftcentral.co.uk/articles/heres-why-you-should-only-enable-hdr-mode-on-your-pc-when-you-are-viewing-hdr-content</a>，建议在未运行使用 HDR 输出的应用程序时在 Windows 设置中禁用 HDR。在 Windows 11 上，可以通过按 Windows + Alt + B 来完成该操作（该快捷方式是 Xbox Game Bar 应用程序的一部分）。要根据当前正在运行的应用程序自动切换 HDR，你可以使用 AutoActions。</li>
</ol>
<p>如果你坚持启用 HDR，可以通过确保显示器配置为使用 HGIG 色调映射（而不是 DTM），然后<code>使用 Windows HDR 校准应用程序 &lt;https://support.microsoft.com/en-us/windows/calibrate-your-hdr-display-using-the-windows-hdr-calibration-app-f30f4809-3369-43e4-9b02-9eabebd23f19&gt;</code>__ 来稍微改善结果。强烈建议在使用 HDR 时使用 Windows 11 而不是 Windows 10。不过，最终结果可能仍不如在显示器上禁用 HDR。<br>计划在未来版本中支持 HDR 导出。</p>
<ol start="10">
<li>从挂起状态恢复 PC 后，编辑器&#x2F;项目冻结或显示出现故障<br>当在 Linux 上使用 NVIDIA 的专用图形驱动程序时便会出现这个已知的问题。<br>目前还没有明确的解决方案，因为当涉及 OpenGL 或 Vulkan 时，Linux + NVIDIA 上的挂起通常会出现问题。<br>与 Forward+ 和 Mobile 渲染方法（使用 Vulkan ）相比，兼容性渲染方法（采用 OpenGL ）通常不太容易出现挂起相关问题。</li>
</ol>
<p>NVIDIA驱动程序提供了一个实验性选项可在挂起后保护视频内存用以解决这个问题。<br>据报道，该选项与较新的 NVIDIA 驱动程序版本配合使用效果更好。<br>为了避免丢失工作内容，请在使电脑进入睡眠状态之前将场景保存在编辑器中。</p>
<ol start="11">
<li>项目在编辑器中正常运行，但在导出后无法加载部分文件<br>这通常是由于忘记在导出对话框中指定非资源文件过滤器而导致的。<br>默认情况下，Godot 只会将实际的资源包含到 PCK 文件中。一些常用的文件，例如 JSON 文件，不会被视为资源。<br>例如，如果你在导出的项目中加载 test.json，则需要在非资源导出过滤器中指定 *.json。有关更多信息，请参阅 资源选项。<br>另外，请注意，导出的项目永远不会包含名字以点开头的文件和文件夹。这是为了防止将 .git 等版本控制文件夹包含在导出的 PCK 文件中。</li>
</ol>
<p>在 Windows 上，也可能是大小写敏感性的问题。如果你在脚本里引用资源时所使用的大小写与文件系统中的不符，在导出项目后就会载入失败。这是因为虚拟 PCK 文件系统是大小写敏感的，而 Windows 的文件系统是大小写不敏感的。</p>
<ol start="12">
<li>项目在从项目管理器打开后频繁崩溃或立即崩溃<br>这可能是由多个因素引起的，比如编辑器插件、GDExtension 插件或其他原因。<br>建议以恢复模式打开项目，并尝试找到并修复导致崩溃的原因。<br>有关更多信息，请参见 Project Manager page。</li>
</ol>
<h2 id="编辑器简介"><a href="#编辑器简介" class="headerlink" title="编辑器简介"></a>编辑器简介</h2><h3 id="编辑器的界面"><a href="#编辑器的界面" class="headerlink" title="编辑器的界面"></a>编辑器的界面</h3><h4 id="项目管理器"><a href="#项目管理器" class="headerlink" title="项目管理器"></a>项目管理器</h4><p>使用项目管理器不需要什么教程，自己实际体验就可以更好掌握</p>
<ul>
<li>项目的使用<ul>
<li>创建、删除、导入或运行游戏项目</li>
</ul>
</li>
<li>下载演示和模板<ul>
<li>从资产库下载开源项目模板和演示程序</li>
</ul>
</li>
<li>用标签管理项目<ul>
<li>创建、删除、编辑标签</li>
</ul>
</li>
<li>恢复模式<ul>
<li>从项目列表中选择项目，点击编辑按钮旁边的下拉箭头，然后选择“在恢复模式下编辑”。</li>
</ul>
</li>
</ul>
<h4 id="Inspector-Dock"><a href="#Inspector-Dock" class="headerlink" title="Inspector Dock"></a>Inspector Dock</h4><p>检查器扩展坞<br><img src="https://wzcwzc10.github.io/posts_img/godot/03/inspector_overview.webp"><br>如果不可见，可以通过导航到 编辑器 &gt; 编辑器设置 &gt; 编辑器停靠 &gt; 检查器</p>
<h4 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h4><p>你可以通过更改数十种设置来控制项目的运行，包括物理、渲染和窗口设置。<br>这些设置可以通过<strong>项目设置</strong>窗口、代码或手动编辑 project.godot 文件来修改。<br>在内部，Godot 将项目的设置存储在一个 project.godot 文件中（INI 格式的纯文本文件）</p>
<p>可以在 <code>ProjectSettings</code> 类中查看完整的设置列表。<br>通过代码修改项目设置：<br>在代码中使用 <code>set_setting()</code> 来修改设置的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProjectSettings.set_setting(&quot;application/run/max_fps&quot;, 60)</span><br><span class="line">ProjectSettings.set_setting(&quot;display/window/size/mode&quot;, DisplayServer.WINDOW_MODE_WINDOWED)</span><br></pre></td></tr></table></figure>
<p>然而，许多项目设置都只会在游戏启动时读取一次。<br>在此之后，使用 set_setting() 更改设置就不会产生效果了。<br>不过大多数设置在 Engine、DisplayServer 等运行时类上都有相应的属性或方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Engine.max_fps = 60</span><br><span class="line">DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_WINDOWED)</span><br></pre></td></tr></table></figure>
<p>通常，项目设置会在运行时复制到以下类中：<br>Engine、PhysicsServer2D、PhysicsServer3D、RenderingServer、Viewport、Window。<br>在 ProjectSettings 类的参考文档中，设置会链接到其对应的运行时属性或方法。</p>
<p>使用 get_setting() 或 get_setting_with_override() 来读取项目设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var max_fps = ProjectSettings.get_setting(&quot;application/run/max_fps&quot;)</span><br><span class="line">var window_mode = ProjectSettings.get_setting(&quot;display/window/size/mode&quot;)</span><br></pre></td></tr></table></figure>
<p>由于许多项目设置仅在启动时读取一次，项目设置中的值可能不再准确。<br>在这种情况下，最好从运行时的等效属性或方法中读取值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var max_fps = Engine.max_fps</span><br><span class="line">var window_mode = DisplayServer.window_get_mode()</span><br></pre></td></tr></table></figure>

<h4 id="脚本编辑器"><a href="#脚本编辑器" class="headerlink" title="脚本编辑器"></a>脚本编辑器</h4><p>以下为文本编辑器的部分关键特性：<br>代码编辑器完整集成 GDScript。<br>支持 GDScript 和 JSON 文件的代码高亮。<br>GDScript 和 JSON 文件的语法检查。<br>支持书签和断点。<br>自动缩进。<br>代码折叠。<br>自定义主题。<br>多光标，可以通过按下 Alt + 单击左键 来启用。<br>自动补全变量、函数、常量等。<br>选中符号后使用 Ctrl + D 进行内联重构。<br>跨项目文件进行批量查找和替换。<br><strong>未研究</strong></p>
<h4 id="编辑器默认快捷键"><a href="#编辑器默认快捷键" class="headerlink" title="编辑器默认快捷键"></a>编辑器默认快捷键</h4><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh-cn/4.x/tutorials/editor/default_key_mapping.html">https://docs.godotengine.org/zh-cn/4.x/tutorials/editor/default_key_mapping.html</a></p>
<h4 id="自定义界面"><a href="#自定义界面" class="headerlink" title="自定义界面"></a>自定义界面</h4><p>编辑器布局会保存在一个在配置的路径 编辑器数据路径 中一个叫 editor_layouts.cfg 的文件中。<br><strong>未研究</strong></p>
<h3 id="XR-编辑器"><a href="#XR-编辑器" class="headerlink" title="XR 编辑器"></a>XR 编辑器</h3><p>专为 XR 设备原生运行而设计的 Godot 编辑器版本<br>目前 Godot XR 编辑器仅适用于运行 Meta Horizon OS v69 或更高版本的以下 Meta Quest 设备：<br>Meta Quest 3<br>Meta Quest 3s<br>Meta Quest Pro<br><strong>未研究</strong></p>
<h3 id="Android-编辑器"><a href="#Android-编辑器" class="headerlink" title="Android 编辑器"></a>Android 编辑器</h3><p><a target="_blank" rel="noopener" href="https://godotengine.org/download/android/">https://godotengine.org/download/android/</a><br><strong>未研究</strong></p>
<h3 id="Web-编辑器"><a href="#Web-编辑器" class="headerlink" title="Web 编辑器"></a>Web 编辑器</h3><p><a target="_blank" rel="noopener" href="https://editor.godotengine.org/releases/latest/">https://editor.godotengine.org/releases/latest/</a><br><strong>未研究</strong></p>
<h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><h4 id="命令行教程"><a href="#命令行教程" class="headerlink" title="命令行教程"></a>命令行教程</h4><p><strong>未研究</strong></p>
<h4 id="使用外部的文本编辑器"><a href="#使用外部的文本编辑器" class="headerlink" title="使用外部的文本编辑器"></a>使用外部的文本编辑器</h4><p><strong>未研究</strong></p>
<h3 id="管理编辑器功能"><a href="#管理编辑器功能" class="headerlink" title="管理编辑器功能"></a>管理编辑器功能</h3><p>想要限制 Godot 编辑器所能使用的功能。<br>“功能配置文件”可以实现这样的需求。<br>编辑器 &gt; 管理编辑器功能。<br>默认是没有配置的。请点击创建配置文档并为其命名。然后你就会看到 Godot 编辑器中所有功能的列表了。<br>要在编辑器之间分享配置，请点击导出按钮。请将自定义配置保存为 .profile 文件。<br>要在其他编辑器中使用，请打开其管理编辑器配置窗口并点击导入，然后选择该 .profile 文件。<br>如果大量电脑都需要自定义配置，这个过程可能会比较繁琐。<br>另一种办法是启用 Godot 的自包含模式，可以将所有编辑器配置放在与编辑器二进制文件同一文件夹中。</p>
<h2 id="2D"><a href="#2D" class="headerlink" title="2D"></a>2D</h2><h3 id="2D-简介"><a href="#2D-简介" class="headerlink" title="2D 简介"></a>2D 简介</h3><p><code>CanvasItem</code> 是 2D 的基础节点。<br><code>Node2D</code> 是 2D游戏对象的基础节点。<br><code>Control</code> 是 所有 GUI 的基础节点。</p>
<blockquote>
<p>可以在 2D 屏幕上显示 3D 场景。</p>
</blockquote>
<h3 id="画布层"><a href="#画布层" class="headerlink" title="画布层"></a>画布层</h3><p>画布项<code>CanvasItem</code>是所有 2D 节点的基类。<br>可以把画布项组织成树。<br>每个项目都会继承父节点的变换：父节点移动，子项也会移动。</p>
<p><code>CanvasItem</code>节点及其派生节点通过视口节点<code>Viewport</code>来显示，是这个视口的直接或间接子节点。<br><code>Viewport</code>的<code>Viewport.canvas_transform</code>属性能够对它所包含的<code>CanvasItem</code>层级结构施加一个自定义的<code>Transform2D</code>变换。<br><code>Camera2D</code>等节点的工作原理就是修改这个变换。<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/canvasitem.png"><br>像滚动这样的效果最好是通过操纵画布的变换<code>transform</code>属性来实现。</p>
<p>通常情况下，我们并不希望游戏或应用程序中的所有东西都受到画布变换的约束。比如：</p>
<ol>
<li>视差背景：比场景其他部分移动得慢的背景。</li>
<li>UI：用户界面（UI）或平视显示系统（HUD）叠加在游戏世界的视图上。<br>希望生命计数器、分数显示和其他元素能够保持其屏幕位置，即使游戏世界的视角发生变化。</li>
<li>转场：用于转场的效果（淡入淡出、混合）也保持在固定的位置。</li>
</ol>
<p>CanvasLayer<br>画布层<code>CanvasLayer</code>节点，可以为所有后代添加一个单独的 2D 渲染层。<br><code>Viewport</code>的子节点默认在图层“0”处绘制，而 <code>CanvasLayer</code>在任何数字层处绘制。<br>数字较大的图层将绘制在数字较小的图层之上。<br><code>CanvasLayer</code>也有自己的变换，不受其他层的影响。<br>这使得当我们对游戏世界的观察发生变化时，UI 可以固定在屏幕空间中。<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/Canvaslayer.png"></p>
<mark class="hl-label yellow">例子</mark>
<p>创建视差背景（Parallax Background）。<br>通过层为“-1”的 <code>CanvasLayer</code> 完成。<br>带有分数、生命计数器和暂停按钮的屏幕也可以创建在编号为“1”的层中。<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/canvaslayers.webp"><br><code>CanvasLayer</code>独立于树顺序，仅依赖于层数，因此可以只在需要时实例化。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
控制节点的绘制顺序并不一定要用`CanvasLayer`。<br>
确保节点被正确绘制在“前面”或“后面”的标准方法是调整场景面板中节点的顺序。<br>
在视口中，场景面板中较上面的节点会被画在较下面的节点的后面。<br>
2D 节点的`CanvasItem.z_index`属性也能够控制绘图顺序。
</p>

<h3 id="视口变换与画布变换"><a href="#视口变换与画布变换" class="headerlink" title="视口变换与画布变换"></a>视口变换与画布变换</h3><p>如何为提供给 Input 的输入事件在正确的坐标系中确定位置</p>
<h4 id="画布变换"><a href="#画布变换" class="headerlink" title="画布变换"></a>画布变换</h4><p>每个<code>CanvasItem</code>节点将驻留在 Canvas Layer 中。<br>每个 Canvas Layer 都有一个变换（平移、旋转、缩放等），可以作为 Transform2D 进行访问。<br>节点默认是在 0 层上绘制，即内置的画布。<br>如果要把节点放在不同的层中，可以使用<code>CanvasLayer</code>节点。</p>
<p><code>Viewport</code>还具有全局画布变换（也是一个 Transform2D）能够影响所有画布层的主变换。<br>一般而言，主要用于 Godot 的<code>CanvasItem</code>编辑器</p>
<h4 id="拉伸变换"><a href="#拉伸变换" class="headerlink" title="拉伸变换"></a>拉伸变换</h4><p>最后，<code>Viewport</code>有拉伸变换，用于调整大小或拉伸屏幕。<br>此变换在内部使用，也可以在每个<code>Viewport</code>上手动设置。</p>
<p>输入事件会与这个变换相乘，但还缺少前面说的那些。<br>为了方便将<code>InputEvent</code>的坐标转换到<code>CanvasItem</code>局部坐标，添加了 <code>CanvasItem.make_input_local()</code>函数。</p>
<h4 id="窗口变换"><a href="#窗口变换" class="headerlink" title="窗口变换"></a>窗口变换</h4><p>根视口是一个<code>Window</code>。为了能够像多分辨率 一样将窗口的内容进行缩放和移动，每个 <code>Window</code> 都包含了窗口变换。<br>例如在 <code>Viewport</code> 使用固定长宽比显示时，负责窗口边缘的黑框。</p>
<h4 id="变换顺序"><a href="#变换顺序" class="headerlink" title="变换顺序"></a>变换顺序</h4><p>要将 CanvasItem 本地坐标转换为实际屏幕坐标，必须应用以下变换链：<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/viewport_transforms3.webp"></p>
<h4 id="变换函数"><a href="#变换函数" class="headerlink" title="变换函数"></a>变换函数</h4><p>上图显示了一些可用的变换函数。所有变换都是从右向左的，这意味着将一个变换与一个坐标相乘会得到一个更靠左的坐标系，将一个变换的 affine inverse 相乘会得到一个更靠右的坐标系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 继承自 CanvasItem</span><br><span class="line">canvas_pos = get_global_transform() * local_pos</span><br><span class="line">local_pos = get_global_transform().affine_inverse() * canvas_pos</span><br></pre></td></tr></table></figure>
<p>那么最后，要将CanvasItem的本地坐标转换为屏幕坐标，只需按以下顺序相乘:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var screen_coord = get_viewport().get_screen_transform() * get_global_transform_with_canvas() * local_pos</span><br></pre></td></tr></table></figure>
<p>但请记住，通常情况最好不要使用屏幕坐标.<br>推荐使用画布坐标<code>( CanvasItem.get_global_transform() )</code>，以保证自动分辨率调整能正常工作.</p>
<h4 id="提供自定义输入事件"><a href="#提供自定义输入事件" class="headerlink" title="提供自定义输入事件"></a>提供自定义输入事件</h4><p>通常需要将自定义输入事件提供给场景树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var local_pos = Vector2(10, 20) # 定义一个局部坐标 local_pos，表示相对于某个 Control 或 Node2D 节点的本地坐标系中的点 (10, 20)。</span><br><span class="line">var ie = InputEventMouseButton.new() # 鼠标按钮事件</span><br><span class="line">ie.button_index = MOUSE_BUTTON_LEFT # 左键点击</span><br><span class="line">ie.position = get_viewport().get_screen_transform() * get_global_transform_with_canvas() * local_pos # 屏幕坐标 = 屏幕变换 × 全局变换 × 局部坐标</span><br><span class="line">Input.parse_input_event(ie) # 构造好的鼠标事件 ie 主动提交给 Godot 的输入系统</span><br></pre></td></tr></table></figure>

<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><h4 id="2D-灯光和阴影"><a href="#2D-灯光和阴影" class="headerlink" title="2D 灯光和阴影"></a>2D 灯光和阴影</h4><p>Godot 提供了可以使用实时 2D 照明和阴影的功能<br>完整的 2D 光照设置涉及多个节点：</p>
<ul>
<li>CanvasModulate（用于使场景变暗）<ul>
<li>用于指定一种颜色作为“环境”基色，使场景变暗。这是任何 2D 灯光都无法到达区域的最终照明颜色。如果没有 CanvasModulate 节点，由于 2D 灯光只会照亮现有的无阴影外观（看起来完全亮了），最终场景看起来会过于明亮。</li>
</ul>
</li>
<li>PointLight2D（用于全向或点光源）<ul>
<li>用于点亮场景。灯光的常见工作方式是在场景的其余部分添加选定的纹理来模拟光照。</li>
<li>阴影只会出现在 PointLight2D 覆盖的区域上，方向基于 Light 的中心。</li>
</ul>
</li>
<li>DirectionalLight2D（用于日光或月光）</li>
<li>LightOccluder2D（用于投射灯光阴影）<ul>
<li>用于告诉着色器场景的哪些部分会投射阴影。这些遮挡物可以作为独立节点放置，也可以作为 TileMapLayer 节点的一部分。</li>
</ul>
</li>
<li>其他可接收光照的 2D 节点，例如 Sprite2D 和 TileMapLayer。<ul>
<li>Sprite2D 用于显示灯泡、背景和阴影投射器的纹理。<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/CanvasModulate.png"></li>
</ul>
</li>
</ul>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
背景色不接受任何光照。如果要在背景上投射灯光，则需要为背景添加可视化表示，例如 Sprite2D。<br>
Sprite2D 的 Region 属性有助于快速创建重复的背景纹理，但要记得在 Sprite2D 属性中将 Texture > Repeat 设置为 Enabled。
</p>

<p>点光源（也称位置光源）<br>可用于表示火把、火、射弹等发出的光。<br><code>PointLight2D</code> 提供了以下属性，可在检查器中进行调整：</p>
<ul>
<li>纹理： 光源的纹理。纹理大小决定光源大小。<br>  纹理可以有一个 alpha 通道，这在使用 <code>Light2D</code> 的 Mix 混合模式时非常有用，但在使用 Add （默认）或 Subtract 混合模式时则不需要。</li>
<li>偏移量： 灯光纹理的偏移量。与移动灯光节点不同，改变偏移量不会导致阴影移动。</li>
<li>纹理缩放： 灯光大小的乘法器。数值越大，灯光越亮。较大的灯光会影响屏幕上更多的像素，因此在增大灯光尺寸前要考虑到这一点。</li>
<li>高度： 灯光在法线贴图中的虚拟高度。默认情况下，灯光与接收灯光的表面非常接近。<br>  如果使用法线贴图，这将使灯光几乎不可见，因此可以考虑增加此值。只有在使用法线贴图的表面上，调整灯光的高度才会产生明显的不同。</li>
</ul>
<p>如果没有预制纹理可用于灯光，可以使用这种 “中性 ”点光源纹理：<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/2d_lights_and_shadows_neutral_point_light.webp"><br>如果需要不同的渐变，在纹理属性上分配 新建 <code>GradientTexture2D</code> 来程序化地创建纹理。<br>展开其 Fill 部分并将填充模式设置为 Radial 。<br>然后调整渐变本身，使其从不透明的白色开始到透明的白色，并将其起始位置移动到中心。</p>
<p>平行光<br>用于表现阳光或月光。<br><code>DirectionalLight2D</code> 提供以下的属性：</p>
<ul>
<li>高度： 灯光在法线贴图中的虚拟高度（ 0.0 &#x3D; 平行于曲面，1.0 &#x3D; 垂直于曲面）。<br>  默认情况下，灯光与接收灯光的表面完全平行。<br>  如果使用法线贴图，这将使灯光几乎不可见，因此可以考虑增大此值。<br>  调整灯光的高度只会对使用法线贴图的表面产生视觉差异。 高度不会影响阴影的外观。</li>
<li>最大距离： 物体距离摄像机中心的最大距离（单位：像素）。<br>  减小该值可以防止对位于摄像机外的物体投射阴影（同时还能提高性能）。<br>  最大距离 不考虑 Camera2D 的缩放，这意味着在较高的缩放值下，当缩放至给定点时，阴影会更快消失。</li>
</ul>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
无论 Height 属性的值是多少，定向阴影看起来总是无限长。这是 Godot 中用于 2D 灯光的阴影渲染方法的限制。<br>
不想获得无限长的定向阴影，应禁用 DirectionalLight2D 中的阴影，并使用自定义着色器来读取 2D 带符号距离场。<br>
该距离场从场景中的 LightOccluder2D 节点自动生成。
</p>

<p>常用灯光属性<br><code>PointLight2D</code> 和 <code>DirectionalLight2D</code> 都提供共同的属性，这些属性是 <code>Light2D</code> 基类的一部分：</p>
<ul>
<li>启用： 允许切换灯光的可见性。与隐藏灯光节点不同，禁用此属性不会隐藏灯光的子节点。</li>
<li>仅编辑器：如果启用，灯光仅在编辑器中可见。在运行的项目中将自动禁用。</li>
<li>颜色： 灯光的颜色。</li>
<li>能量： 灯光强度乘数。数值越大，光线越亮。</li>
<li>混合模式： 用于光线计算的混合公式。默认的 <code>添加（Add）</code>适合大多数使用情况。 <code>减（Subtract）</code>可用于负光，负光在物理上并不精确，但可用于特殊效果。 混合（Mix） 模式通过线性插值将灯光纹理对应的像素值与灯光下方的像素值混合。</li>
<li>范围 &gt; Z 下限： 受光线影响的最小 Z 值。</li>
<li>范围 &gt; Z 上限： 受光线影响的最大 Z 值。</li>
<li>范围 &gt; 层下限： 受光线影响的最小层数值。</li>
<li>范围 &gt; 层上限： 受光线影响的最大层数值。</li>
<li>范围 &gt; 对象遮罩： 根据其他节点的可视层选项<strong>Occluder Light Mask</strong>（遮挡掩膜），控制那些节点接收到来自这个节点的光线。通过这种方式可以让某些物体不被光线照射。</li>
</ul>
<p>设置阴影<br>启用一个 <code>PointLight2D</code> 或者 <code>DirectionalLight2D</code> 节点的 Shadow &gt; Enabled 属性之后，你将看不到任何变化。<br>这是因为在你的场景中还没有任何节点拥有投射阴影需要使用的<strong>遮挡器</strong>。</p>
<p>场景中显示阴影添加 <code>LightOccluder2D</code> 节点。具有与精灵轮廓相匹配的遮光多边形。<br>除了多边形资源（必须设置多边形资源才能产生视觉效果）之外，<code>LightOccluder2D</code> 节点还有两个属性：</p>
<ol>
<li>SDF碰撞：如果启用，则遮挡器将成为可在自定义着色器中使用的实时生成的 签名距离字段 （signed distance field）的一部分。<br> 当不使用从此 SDF 中读取的自定义着色器时，启用这个功能不会带来视觉上的差异，并且没有性能成本，因此默认情况下为方便起见它是启用的。</li>
<li>遮挡器光照蒙版： 这与 <code>PointLight2D</code> 和 <code>DirectionalLight2D</code> 的 ** Shadow &gt; Item Cull Mask ** 属性一起使用，以控制哪些对象为每个光源投射阴影。<br> 这可用于防止特定对象投射阴影。</li>
</ol>
<p>有两种方法可以来创建光线遮挡器：</p>
<ol>
<li><p>自动生成光遮蔽器<br>遮挡器可以自动地 <code>Sprite2D</code> 节点上创建，需要选中节点，单击顶部工具栏的 <code>Sprite2D</code> 菜单，然后选择创建 <code>LightOccluder2D</code> 同级节点。<br>可以调整扩展（像素）和收缩（像素），然后点击更新预览。</p>
</li>
<li><p>手动绘制光遮蔽器<br>创建一个 <code>LightOccluder2D</code> 节点，然后选择该节点单击顶部工具栏的新图标。<br>可以单击创建新点来开始绘制遮挡多边形。<br>可以右键单击点来删除，拖动线创建新点。</p>
</li>
</ol>
<p>启用阴影的 2D 灯光能够调整以下属性：</p>
<ul>
<li>Color：阴影区域的颜色。<br>默认情况下，阴影区域是全黑的，但这可以出于艺术目的而改变。颜色的 alpha 通道控制的是阴影被指定颜色着色的程度。</li>
<li>Filter：阴影所使用的过滤模式。<br>默认值为 None，渲染速度最快，并且非常适合像素艺术风格的游戏（因为它具有“方块”视觉效果）。如果你想要柔和的阴影，请使用 PCF5。PCF13 则更柔和，但渲染需求更高。由于渲染成本较高，PCF13 只应用于少量光源同时存在的情况下。</li>
<li>Filter Smooth：过滤平滑。<br>控制的是当 Filter 为 PCF5 或 PCF13 时，应用于阴影的柔化程度。<br>较高的值会导致阴影更加柔和，但可能会出现带状伪影（特别是使用 PCF5 时）。</li>
<li>Item Cull Mask：项目剔除遮罩。<br>控制的是哪些 LightOccluder2D 节点能够投射阴影，取决于对应的 Occluder Light Mask（遮挡器灯光遮罩）属性。</li>
</ul>
<p>法线和镜面贴图<br>大大提升 2D 光照的立体感。<br>与 3D 渲染类似，法线贴图可以根据接收光线的表面方向来改变光线的强度，从而使照明效果不再平面化（按像素进行调整）。<br>镜面贴图通过让一部分光线反射回观察者来进一步改善视觉效果。<br><code>PointLight2D</code> 和 <code>DirectionalLight2D</code> 都支持法线贴图和镜面贴图。<br>法线贴图和镜面贴图可分配给任何 2D 元素，包括继承自 <code>Node2D</code> 或 <code>Control</code> 的节点。</p>
<p>法线贴图表示每个像素“指向”的方向。<br>引擎会利用这些信息，以物理上合理的方式将光照正确应用到 2D 表面。<br>法线贴图通常由手绘的高度贴图创建，但也可以由其他纹理自动生成。</p>
<p>镜面贴图定义了每个像素对光线的反射程度（如果镜面贴图包含颜色，则定义反射的颜色）。<br>亮度值越高，纹理上指定位置的反射就越亮。<br>镜面贴图通常以漫反射纹理为基础，通过手动编辑创建。</p>
<blockquote>
<p>如果在你的精灵中没有使用法线贴图或者镜面贴图，可以使用免费的开源工具 Laigter 来生成。<br>要在 2D 节点上设置法线贴图和&#x2F;或镜面贴图，请为绘制节点纹理的属性创建一个新的 CanvasTexture 资源。<br>例，在 Sprite2D 节点上创建一个新的 CanvasTexture 资源：</p>
</blockquote>
<p>展开新创建的资源。你可以找到需要调整的几个属性：</p>
<ul>
<li>Diffuse &gt; Texture：（漫反射 &gt; 纹理）基础的颜色贴图。<br>  在这个属性中，加载你将使用在精灵本身的纹理。</li>
<li>Normal Map &gt; Texture：（法线贴图 &gt; 纹理）法线贴图的纹理。<br>  在这个属性中，你可以加载从高度图生成的法线贴图纹理（见上面的提示）。</li>
<li>Specular &gt; Texture：（镜面反射 &gt; 纹理）镜面贴图纹理，可以控制漫反射纹理上每个像素的镜面反射强度。<br>  镜面贴图通常使用灰度反射，但是它也可以包含色彩来增强反射的颜色。在这个属性中，加载一个已创建的镜面贴图纹理（见上面的提示）。</li>
<li>Specular &gt; Color：（镜面反射 &gt; 颜色）镜面反射的颜色乘数。</li>
<li>Specular &gt; Shininess：（镜面反射 &gt; 光泽度）用于镜面反射的高光指数。<br>  值越低，反射的明亮度和扩散性会增加，而值越高，反射会更加局部化。较高的值适用于湿润表面。</li>
<li>Texture &gt; Filter：（纹理 &gt; 过滤器）可以设置为覆盖纹理过滤模式<br>  无论节点属性设置如何（或渲染 &gt; 纹理 &gt; 画布纹理 &gt; 默认纹理过滤项目设置）。</li>
<li>Texture &gt; Repeat：（纹理 &gt; 重复）可以设置为覆盖纹理过滤模式<br>  无论节点的属性如何设置（或者渲染 &gt; 纹理 &gt; 画布纹理 &gt; 默认纹理重复项目设置）。<br>启用法线贴图后，你可能会注意到灯光会显得较弱。为了解决这个问题，可以增加 <code>PointLight2D</code> 和 <code>DirectionalLight2D</code> 节点上的 Height 属性。也可以略微增加灯光的 Energy 属性，以接近启用法线贴图之前的照明强度。</li>
</ul>
<p>使用添加式精灵作为 2D 灯光的快速替代品<br>如果在使用 2D 灯光时遇到性能问题，不妨将其中一些节点替换为使用叠加混合的 Sprite2D 节点。这尤其适用于短暂的动态效果，如子弹或爆炸。<br>添加式精灵的渲染速度要快得多，因为它们不需要通过单独的渲染管道。<br>此外，这种方法还可以与 AnimatedSprite2D（或 Sprite2D + AnimationPlayer）一起使用，这样就可以创建动画二维 “灯光”。<br>不过，与 2D 灯光相比，添加式精灵有一些缺点：</p>
<ul>
<li>与 “实际 ”二维光照相比，混合公式并不准确。<br>  这在光线充足的区域通常不是问题，但这会妨碍添加精灵去正确照亮那些完全黑暗的区域。</li>
<li>添加式精灵不能投射阴影，因为它们不是灯光。</li>
<li>添加式精灵会忽略其他精灵上使用的法线贴图和镜面贴图。<br>要显示一个具有加法混合的精灵，请创建一个 Sprite2D 节点并为其分配一个纹理。<br>在检查器中，向下滚动到 CanvasItem &gt; Material 部分，展开它并点击 Material 属性旁边的下拉菜单。<br>选择 New CanvasItemMaterial，点击新创建的材质进行编辑，然后将 Blend Mode 设置为 Add。</li>
</ul>
<h4 id="2D-网格"><a href="#2D-网格" class="headerlink" title="2D 网格"></a>2D 网格</h4><p>在 3D 中，网格用于显示世界。在2D中它们不常见，因为图片使用得更频繁。<br>Godot 的2D部分是一个纯2D引擎，因此它不能直接显示3D网格（尽管可以通过 <code>Viewport</code> 和 <code>ViewportTexture</code> 来实现）。</p>
<blockquote>
<p>如果你对在二维视口上显示三维网格感兴趣，请参见 使用 <code>SubViewport</code> 作为纹理教程。</p>
</blockquote>
<p>2D 网格可以尝试使用代码中的 <code>SurfaceTool</code> 创建它们，并在 <code>MeshInstance2D</code> 节点中显示它们。<br>目前，在编辑器中生成 2D 网格的唯一方法是导入 OBJ 文件作为网格，或者从 <code>Sprite2D</code> 转换而来。</p>
<p>优化绘制的像素<br>该工作流程在某些情况下可用于优化 2D 绘制。<br>绘制具有透明度的大型图像时，Godot 会将整个四边形绘制到屏幕上。大型透明区域仍将被绘制。<br>如果绘制非常大的图像时（大概屏幕大小），或者将多个有大透明区域的图像叠加在一起（例如使用 <code>ParallaxBackground</code> 时），这会影响性能，尤其是在移动设备上。<br>转换成网格能确保只绘制不透明部分，其余部分被忽略。</p>
<p>将 Sprite2D 转换为 2D 网格<br>你可以通过把 <code>Sprite2D</code> 转换为 <code>MeshInstance2D</code> 的方法来利用这种优化。<br>从边缘有大量透明的图片开始，把它放到一个 <code>Sprite2D</code> 中，从菜单选择“转换为 2D 网格”<br>默认值对于许多情况来说已经足够好了，但你可以根据需要更改扩展和简化<br>最后，按下 转换 2D 网格 按钮，你的 <code>Sprite2D</code> 将被替换</p>
<h4 id="2D-精灵动画"><a href="#2D-精灵动画" class="headerlink" title="2D 精灵动画"></a>2D 精灵动画</h4><p>使用 <code>AnimatedSprite2D</code> 类和 <code>AnimationPlayer</code> 创建 2D 动画角色</p>
<ul>
<li>首先，我们将使用 <code>AnimatedSprite2D</code> 对单个图像集合进行动画处理。 </li>
<li>然后我们将使用此类对精灵表进行动画处理。 </li>
<li>最后，我们将学习另一种使用 <code>AnimationPlayer</code> 和 <code>Sprite2D</code> 的 <code>Animation</code> 属性来制作精灵表动画的方法。<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/2d_animation_tree1.webp"></li>
</ul>
<p>控制动画<br><code>AnimateSprite2D</code> 与精灵表<br><code>AnimationPlayer</code> 与精灵表<br>根节点也可以是 <code>Area2D</code> 或 <code>RigidBody2D</code>。动画仍然会以同样的方式制作。<br>一旦动画完成，你就可以为 CollisionShape2D 形状分配一个形状。</p>
<p>可在 Godot 中用于 2D 动画的两个类。<code>AnimationPlayer</code> 比 <code>AnimatedSprite2D</code> 稍微复杂一些，但它提供了额外的功能，因为你还可以为其他属性（如位置或比例）设置动画。 类 <code>AnimationPlayer</code> 也可以与 <code>AnimatedSprite2D</code> 一起使用。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
如果同时更新一个动画和一个其他的属性（比如说，平台跳跃游戏可能会更新精灵的 h_flip/v_flip 属性然后同时开始一个转身动画“turning”），要记住 play() 不是即时生效的。它会在下次 AnimationPlayer 被处理时生效。也就是说可能要到下一帧才行，导致现在这一帧变成“问题”帧——应用了属性的变化，但动画还没有开始。如果这会造成麻烦的话，在调用 play() 后，你可以调用 advance(0) :ref:`AnimationPlayer <class_AnimationPlayer>`来立即开始播放动画。
</p>


<h4 id="2D-粒子系统"><a href="#2D-粒子系统" class="headerlink" title="2D 粒子系统"></a>2D 粒子系统</h4><p>粒子系统用于模拟复杂的物理效果，例如火花、火焰、魔法粒子、烟雾、薄雾等。<br>这个想法是以固定的间隔发射具有固定的寿命的 “粒子”。<br>在其生命周期中，每个粒子都具有相同的基本行为。<br>设置基本物理参数，添加随机性。</p>
<p>Godot 为 2D 粒子提供了两个不同的节点：</p>
<ol>
<li><code>GPUParticles2D</code> 更先进，使用 GPU 来处子理粒效果。 </li>
<li><code>CPUParticles2D</code> 是 CPU 驱动的选项，其功能与 <code>GPUParticles2D</code> 几乎相同，但在使用大量粒子时性能较低。在低端系统或 GPU 瓶颈情况下可能表现更好。</li>
</ol>
<p>虽然 <code>GPUParticles2D</code> 是通过 <code>ParticleProcessMaterial</code>（还可以使用自定义着色器）进行配置的<br>不过匹配的选项是通过 <code>CPUParticles2D</code> 中的节点属性提供的（除了轨迹设置）。<br> <code>GPUParticles2D</code> 节点可转换为 <code>CPUParticles2D</code> 节点。<br>也可以将 <code>GPUParticles2D</code> 节点转换为 <code>CPUParticles2D</code> 节点，但如果你使用了仅 GPU 支持的功能，可能会出现一些问题。<br>今后没有计划向 <code>CPUParticles2D</code> 添加新功能，但将接受添加 <code>GPUParticles2D</code> 中已有功能的拉取请求。<br>因此，我们建议使用 <code>GPUParticles2D</code>，除非你有明确的理由不这样做。</p>
<p>使用步骤：</p>
<ol>
<li><code>GPUParticles2D</code> 节点添加到场景中。 </li>
<li>添加材质到粒子节点，转到检查器面板中的 Process Material。</li>
<li>新建 <code>ParticleProcessMaterial</code>。</li>
<li><code>GPUParticles2D</code> 节点现在可以向下发射白点了。</li>
</ol>
<p>粒子系统可以使用单个纹理或动画<strong>翻页</strong>（filpbook）。<br>翻页是一种纹理，其中包含可以回放或在发射期间随机选择的多个动画帧。翻页相当于粒子的精灵表。<br>粒子翻页适合再现复杂的效果，如烟雾、火焰、爆炸。<br>可以通过使每个粒子使用不同的纹理（纹理通过 Texture 属性设置），来引入随机纹理变化。<br>可以在线寻找现成的粒子翻页图，或使用外部工具预渲染它们，例如 Blender 。<br>相比起单个纹理，使用动画翻页需要额外的配置，必须在 <code>GPUParticles2D</code>（或 CPUParticles2D）节点的 Material 部分中创建一个新的 <code>CanvasItemMaterial</code>，启用 <code>Particle Animation</code> ，并将 <code>H Frames</code> 和 <code>V Frames</code> 分别设置为翻页纹理中的列数和行数：<br>完成此操作后，<code>ParticleProcessMaterial</code>（对于 GPUParticles2D）或 <code>CPUParticles2D</code> 检查器中的 动画部分将生效。</p>
<blockquote>
<p>如果你的翻页纹理是黑色背景而不是透明背景，你还需要将混合模式设置为 Add 而不是 Mix 才能使它正确地显示。或者，你也可以修改纹理以使它在图像编辑器中有透明背景。在 GIMP 中，可以使用 Color &gt; Color to Alpha 菜单来完成此操作。</p>
</blockquote>
<p>时间参数</p>
<ol>
<li>生命期（Lifetime）<br> 每个粒子存活的时间，单位为秒。当生命期结束时，将创建一个新粒子来替换它。</li>
<li>单次（One Shot）<br> 启用后，GPUParticles2D 节点将一次发射其所有粒子，之后将不再发射。</li>
<li>预处理（Preprocess）<br> 粒子系统从没有粒子被发射开始，然后开始发射。 当加载场景如火炬，雾等系统时可能会带来不便，因为它会在进入场景的那一刻开始发射。 预处理用于让系统在第一次实际绘制之前处理给定的秒数。</li>
<li>速度缩放（Speed Scale）<br> 速度比例具有默认值 1 ，用于调整粒子系统的速度。 降低值会使粒子变慢，而增加值会使粒子更快。</li>
<li>爆炸性（Explosiveness）<br> 如果有10个寿命为 1 的粒子，则意味着粒子将每0.1秒发射一次. 爆炸性参数改变了这一点，并迫使粒子一起发射. 范围是:<br> 0: 定期发射粒子(默认值)。<br> 1: 同时发射所有粒子。<br> 中间的值也是允许的。 </li>
<li>随机性（Randomness）<br> 所有物理参数都可以随机化。 随机值范围从 0 到 1。 随机化参数的公式为:<br> <code>initial_value = param_value + param_value * randomness</code></li>
<li>固定 FPS（Fixed FPS）<br> 此设置可用于将粒子系统设置为以固定的帧率渲染。 例如，将值更改为 2 将使粒子以每秒2帧的速度渲染。 请注意，这不会减慢粒子系统本身的速度。<blockquote>
<p>Godot 4.3 目前不支持 2D 粒子的物理插值。作为临时解决方案，你可以在检查器底部将粒子节点的 Node &gt; Physics Interpolation &gt; Mode 设置为禁用，以关闭物理插值功能。</p>
</blockquote>
</li>
<li>Fract Delta<br> 将 <code>Fract Delta</code> 设置为 true 会启用分数增量计算，这会使粒子显示效果更加平滑。<br> 这种平滑性的提升源于更高的计算精度。在具有高度随机性或快速移动粒子的系统中，这种差异会更加明显。<br> 有助于保持粒子系统的视觉一致性，确保每个粒子的运动与其实际生命周期保持一致。<br> 如果不启用此选项，当粒子在帧内的某个时间点发射时，可能会出现粒子跳跃或移动超出应有范围的现象。<br> 更高的精度会带来性能上的折衷，特别是在粒子数量较多的系统中。</li>
</ol>
<p>绘图参数</p>
<ol>
<li>可见矩形范围（Visibility Rect）<br> 可见性矩形控制粒子在屏幕上的可见性。如果位于视口之外，则引擎将不会在屏幕上渲染粒子。<br> 可以使用工具栏让 Godot 自动生成可见性矩形。<br> 为此，请选择 GPUParticles2D 节点并单击 粒子 &gt; 生成可见性矩形。 Godot 将模拟 <code>Particles2D</code> 节点发射粒子几秒钟，并设置矩形以适合粒子所占据的表面。<br> 可以使用 Generation Time (sec) 选项控制发射持续时间。 最大值为25秒。 如果需要更多时间让粒子移动，你可以暂时更改<code>Particles2D</code>节点上的 <code>preprocess</code> 时间。</li>
<li>局部坐标（Local Coords）<br> 默认情况启用，移动节点，则所有粒子会跟随移动:<br> 禁用，移动节点，则已发射的粒子不会受到影响:</li>
<li>绘制顺序（Draw Order）<br> 这可以控制绘制单个粒子的顺序。Index 表示粒子根据它们的发射顺序被绘制(默认)。<code>Lifetime</code> 表示它们按照剩余寿命的顺序被绘制。</li>
</ol>
<h4 id="ParticleProcessMaterial-2D-用法"><a href="#ParticleProcessMaterial-2D-用法" class="headerlink" title="ParticleProcessMaterial 2D 用法"></a>ParticleProcessMaterial 2D 用法</h4><p>处理材质属性<br>在这个材质中的属性控制粒子在其生命周期中的行为和变化。<br>它们中的许多拥 Min 、 Max 和 Curve 值，允许对其行为进行微调。<br>值之间的关系是：当一个粒子被生成时，属性会被设置为 Min 和 Max 之间的一个随机值。<br>如果 Min 和 Max 是相同的，那么每个粒子的值将始终是相同的。<br>如果也设置了 <code>Curve</code> ，属性的值将会乘以粒子生命周期当前点上曲线的值。<br>使用曲线来改变粒子生命周期中的属性。这种方式可以表达非常复杂的行为。</p>
<p>下面为ParticleProcessMaterial 2D的属性：</p>
<ol>
<li>随机性的生命周期<br><code>Lifetime Randomness</code> 属性控制应用于每个粒子生命周期的随机性程度。<br>值为 0 表示完全没有随机性，由 <code>Lifetime</code> 属性设置的所有粒子的存活时间相同。<br>值为 1 表示粒子的生命周期在 [0.0, Lifetime] 范围内完全随机。</li>
<li>粒子标志 Particle Flags<br>控制粒子的变幻特效。</li>
<li>生成 Spawn<ol>
<li>位置 (Position)<ul>
<li>发射色彩<br> <code>Capture from Pixel</code> 会使粒子在其产生点处继承遮挡材质的颜色。<br> 在单击“确定”后，将生成遮罩并将其设置为 ParticleProcessMaterial，位于 Spawn 下，然后是 Position<br> 本节中的所有值均由“加载发射遮罩”菜单自动生成，因此通常应将它们保留。<br> 不应将图像直接添加到点纹理（Point Texture）或颜色纹理（Color Texture）中。应始终使用“加载发射遮罩”菜单。</li>
</ul>
</li>
<li>角度（Angle）<br> 确定粒子的初始角度(以度为单位)。 该参数通常在随机化后会有用。</li>
<li>速度（Velocity）<ol>
<li>继承速度比例 (Inherited Velocity Ratio)</li>
<li>速度轴转 (Velocity Pivot)</li>
<li>方向 (Direction)<br> 这是粒子发射的基础方向。 默认值是 Vector3(1,0,0) ，它使粒子向右发射。<br> 然而，在默认的重力设置下，粒子会直线下降。<br> 为了让这个属性作用更明显，你需要一个大于 0 的初始速度(initial velocity)。 </li>
<li>发散（Spread）<br> 此参数是以度为单位的角度，它会被随机加减到基础 Direction 上。<br> 180 的铺开角度将向所有方向发射(+&#x2F;- 180)。</li>
<li>扁平度（Flatness）<br> 这个属性只对3D粒子有用。</li>
<li>初速度（Initial Velocity）<br> 初始速度是粒子发射的速度（单位为像素&#x2F;秒）。<br> 以后可以通过重力或其他加速度来修改速度（后述）。</li>
</ol>
</li>
</ol>
</li>
<li>动画速度 Animation Velocity<ol>
<li>角速度（Angular Velocity）<br> 角速度是粒子围绕其中心转动的速度(以度&#x2F;秒为单位)。</li>
<li>方向速度(Direction Velocity)</li>
<li>环绕速度（Orbit Velocity）<br> 环绕速度速度用于使粒子绕它们的中心转动。</li>
<li>径向速度（Radial Velocity）</li>
<li>速度限制（Velocity Limit）</li>
</ol>
</li>
<li>加速度 Accelerations<ol>
<li>重力（Gravity）<br> 应用于每个粒子上的重力。</li>
<li>线性加速度（Linear Acceleration）<br> 应用于每个粒子的线性加速度。</li>
<li>径向加速度（Radial Acceleration）<br> 如果此加速度为正，则粒子会向远离发射中心加速。 如果是负的，他们会被加速吸进去。</li>
<li>切向加速度（Tangential Acceleration）<br> 该加速度会使用从粒子到中心点的切向量，结合径向加速度可以做出很酷炫的效果。</li>
<li>阻尼（Damping）<br> 阻尼选项会对颗粒施加摩擦力，迫使它们停止。<br> 它特别适用于火花或爆炸，火花或爆炸通常以高线速度开始，然后在他们隐去时停下来。</li>
</ol>
</li>
<li>显示 Display<ol>
<li>缩放（Scale）<br> 确定粒子的初始大小。</li>
<li>随速度缩放（Scale Over Velocity）</li>
<li>颜色曲线 (Color Curve)<br> 用于改变发射出来的粒子颜色。</li>
<li>色相变化 (Hue Variation)<br> Variation 值设置的是应用于每个粒子的初始色调变化。<br> Variation Rand 值控制色调变化的随机性比率。</li>
<li>动画 (Animation)<br> 仅当 <code>GPUParticles2D</code> 或 <code>CPUParticles2D</code> 节点上使用的 <code>CanvasItemMaterial</code> 已进行相应配置时，粒子翻页动画才有效。<br> 如要将粒子翻页设置为线性播放，请将 <code>Speed Min</code> 和 <code>Speed Max</code> 值设置为 1：<br> 默认情况下，循环功能是禁用的。如果粒子在其生命周期结束之前播放完毕，则粒子将继续使用翻页的最后一帧（根据翻页纹理的设计方式，这一帧可能是完全透明的）。如果启用循环，粒子的动画将循环回到第一帧并重复播放。<br> 根据精灵表包含的图像数量以及粒子的存活时间情况，你的动画可能看起来会并不流畅。粒子的存活时间、动画速度和精灵表中图像数量之间的关系是这样的：当动画速度为 1.0 时，动画将在粒子生命周期结束时，播放到序列中的最后一个图像。<br> 如果你希望将粒子翻页用作每个粒子的随机粒子纹理源，请将速度值保持为 0 ，并将 Offset Max 设置为 1<br> 请注意，<code>GPUParticles2D</code> 节点的 Fixed FPS 也会影响动画播放。为了动画播放流畅，建议将其设置为 0，以便在每个渲染帧上模拟粒子。如果这个设置不适合你的用例，请将 Fixed FPS 设置为等于翻页动画使用的有效帧速率（请参阅上面的公式）。</li>
</ol>
</li>
<li>扰动 Turbulence</li>
<li>碰撞 Collision</li>
<li>子发射器 Sub Emitters</li>
<li>资源 Resources</li>
</ol>
<p>发射形状<br><code>ParticleProcessMaterials</code> 允许你设置发射蒙版，它决定发射粒子的区域和方向。 这些可以从项目中的纹理生成。<br>设置 <code>ParticleProcessMaterial</code>，并选择了<code>GPUParticles2D</code> 节点。 工具栏中就会出现“粒子”菜单<br>打开它并选择“加载发射遮罩”，然后选择你想要用作遮挡的纹理，会出现一个具有多个设置的对话框。</p>
<ul>
<li>发射遮罩<br>纹理可以生成三种类型的发射遮挡:</li>
</ul>
<ol>
<li>实体像素（Solid Pixels）：粒子将从纹理的任意区域产生，透明区域除外。</li>
<li>边界像素（Border Pixels）：粒子将从纹理的外边缘产生。</li>
<li>有向边界像素（Directed Border Pixels）：与边界像素类似，但为遮罩添加了额外信息，使粒子能够从边界发射出去。请注意，需要设置初速度（Initial Velocity）才能使用该功能。</li>
</ol>
<h4 id="2D-抗锯齿"><a href="#2D-抗锯齿" class="headerlink" title="2D 抗锯齿"></a>2D 抗锯齿</h4><p>由于分辨率有限，以 2D 渲染的场景可能会出现锯齿现象。<br>使用诸如 Line2D、 Polygon2D 或 TextureProgressBar 等节点时最为明显。<br>2D 中的自定义绘图 对于不支持抗锯齿的方法也可能会出现锯齿现象。<br>为了解决这个问题，Godot 支持多种在 2D 渲染中启用抗锯齿的方法。</p>
<ol>
<li><code>Line2D</code> 和自定义绘图中的反锯齿属性（推荐）<br>Line2D 具有 <code>Antialiased</code>（抗锯齿）属性，可以在检查器中启用。<br>此外，2D 中的自定义绘图中的一些方法支持提供可选的 antialiased 参数，可以在调用函数时设置为 true。</li>
</ol>
<p>这些方法不需要启用 <code>MSAA</code>，这使得它们的 基准 性能成本很低。<br>换句话说，如果你在某个阶段没有绘制任何抗锯齿几何图形，则不会产生永久性的额外性能消耗。</p>
<p>这些抗锯齿方法的缺点是需要生成额外的几何图形。<br>如果要生成每帧都需要更新的复杂 2D 几何图形，这可能会成为程序的性能瓶颈。<br>此外，Polygon2D、TextureProgressBar 和几种自定义绘图方法都不具备抗锯齿属性。<br>对于这些节点，可以使用 2D 多采样抗锯齿来代替。</p>
<ol start="2">
<li>多重采样抗锯齿（MSAA）<br>该功能仅适用于集群 Forward+ 和 Forward 移动后端，不适用于兼容性渲染器。</li>
</ol>
<p>在 2D 中启用 MSAA 之前，必须先了解 MSAA 的操作对象。<br>2D 中的 MSAA 遵循与 3D 中类似的限制。虽然它不会带来任何模糊，但其应用范围是有限的。2D MSAA 的主要应用包括：</p>
<p>几何边缘,如直线和多边形绘图。<br>精灵边缘,仅限于与纹理边缘接触的像素。<br>这适用于线性过滤和最近邻插值过滤。使用图像透明度创建的精灵边缘不受 MSAA 影响。</p>
<p>MSAA 的缺点是它只对边缘起作用。<br>这是因为 MSAA 增加了覆盖采样的数量，但没有增加颜色采样的数量。<br>但是，由于颜色采样的数量没有增加，因此片段着色器仍然只为每个像素运行一次。因此，MSAA 不会影响以下类型的锯齿：</p>
<ul>
<li>最近邻过滤纹理中的锯齿（像素艺术）。</li>
<li>自定义 2D 着色器造成的锯齿。</li>
<li>使用 Light2D 时的镜面反射锯齿。</li>
<li>文字渲染中的锯齿。</li>
</ul>
<p>可以通过更改项目设置中 渲染 &gt; 抗锯齿 &gt; 质量 &gt; MSAA 2D Rendering &gt; Anti Aliasing &gt; Quality &gt; MSAA 2D 的值来启用 MSAA。<br>请注意，要更改的是 MSAA 2D 的值，不是 MSAA 3D 的值，这两个是不同的设置项。</p>
<h4 id="2D-中的自定义绘图"><a href="#2D-中的自定义绘图" class="headerlink" title="2D 中的自定义绘图"></a>2D 中的自定义绘图</h4><p>Godot 有用于绘制精灵、多边形、粒子、文本以及其它各种游戏开发所需东西的节点。<br>你还可以通过自定义命令在屏幕上绘制任何 2D 节点（例如，基于 Control 或 Node2D ）。</p>
<p>2D 节点中的自定义绘制非常有用。下面是一些用例：</p>
<ul>
<li>绘制现有节点类型无法完成的形状或逻辑，例如带有尾迹或特殊动态多边形的图像。</li>
<li>绘制大量简单的对象，例如 2D 游戏中的一个栅格或一个面板。自定义绘制避免了使用大量节点的开销，能降低内存占用，并提高性能。</li>
<li>制作自定义的 UI 控件，以满足很多可用的控件之外的特别需求。</li>
</ul>
<p>添加一个脚本到任何 <code>CanvasItem</code> 的派生节点，如 Control 或 Node2D。然后重载 _draw() 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line">func _draw():</span><br><span class="line">	pass  # Your draw commands here.</span><br></pre></td></tr></table></figure>
<p>绘制命令在 <code>CanvasItem</code> 的类参考中有所描述。绘制命令的数量很多，我们将在下面的示例中看到一些。</p>
<p>_draw 函数只调用一次，然后绘制命令被缓存并记住，因此不需要进一步调用。<br>如果因为状态或其他方面的变化而需要重新绘制，在当前节点中调用 <code>CanvasItem.queue_redraw</code> ，触发新的 <code>_draw()</code> 调用。<br>这是一个稍微复杂一点的例子，我们有一个可以被随时修改的纹理变量，并且使用一个 setter，它在纹理被修改时强制一次该纹理的重绘：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">@export var texture : Texture2D:</span><br><span class="line">	set(value):</span><br><span class="line">		texture = value</span><br><span class="line">		queue_redraw()</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	draw_texture(texture, Vector2())</span><br></pre></td></tr></table></figure>

<p>为了直观地看到这一功能，你可以通过将默认的 icon.svg 文件从 文件系统 标签拖放到 检查器 标签上的 纹理 属性，将编辑器中的纹理设置为 Godot 图标。<br>当先前脚本运行时更改 纹理 属性值，纹理也将自动更改。</p>
<p>在某些情况下，需要绘制每一帧。 为此，可以像这样从 _process 方法中调用 queue_redraw 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	pass  # Your draw commands here.</span><br><span class="line"></span><br><span class="line">func _process(_delta):</span><br><span class="line">	queue_redraw()</span><br></pre></td></tr></table></figure>

<p>坐标和线宽对齐<br>绘图 API 使用的是 CanvasItem 的坐标系，不一定是像素坐标。这意味着 _draw() 使用的是应用 CanvasItem 的变换后创建的坐标空间。此外，你还可以使用 draw_set_transform 或 draw_set_transform_matrix 在其上方应用自定义变换。</p>
<p>当使用 draw_line 时，你应该考虑线的宽度。当使用奇数宽度时，为了使线保持居中，起点和终点的位置应该偏移 0.5 ，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	draw_line(Vector2(1.5, 1.0), Vector2(1.5, 4.0), Color.GREEN, 1.0)</span><br><span class="line">	draw_line(Vector2(4.0, 1.0), Vector2(4.0, 4.0), Color.GREEN, 2.0)</span><br><span class="line">	draw_line(Vector2(7.5, 1.0), Vector2(7.5, 4.0), Color.GREEN, 3.0)</span><br></pre></td></tr></table></figure>
<p>与使用 filled &#x3D; false 的 draw_rect 方法相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	draw_rect(Rect2(1.0, 1.0, 3.0, 3.0), Color.GREEN)</span><br><span class="line">	draw_rect(Rect2(5.5, 1.5, 2.0, 2.0), Color.GREEN, false, 1.0)</span><br><span class="line">	draw_rect(Rect2(9.0, 1.0, 5.0, 5.0), Color.GREEN)</span><br><span class="line">	draw_rect(Rect2(16.0, 2.0, 3.0, 3.0), Color.GREEN, false, 2.0)</span><br></pre></td></tr></table></figure>

<p>抗锯齿绘图<br>Godot 在 draw_line 方法中提供参数来启用抗锯齿功能，但并非所有自定义绘图方法都提供这个 抗锯齿（antialiased） 参数。<br>对于不提供 antialiased 参数的自定义绘图方法，你可以启用 2D MSAA，这会影响整个视口的渲染。这个功能（2D MSAA）提供了高质量的抗锯齿，但性能成本更高，而且只适用于特定元素。详情见 2D 抗锯齿。<br>最小宽度线段 (width&#x3D;-1) 的对比，分别启用 antialiased&#x3D;false 、 antialiased&#x3D;true 以及 antialiased&#x3D;false 搭配 2D MSAA 2x、4x 和 8x 抗锯齿。</p>
<p>工具<br>运行于编辑器中时，也可能需要绘制自己的节点。这可以用于预览或可视化某些特性或行为。<br>为此，你可以在 GDScript 和 C# 上使用工具注解。有关更多信息，请参阅下面的示例和 在编辑器中运行代码。<br>示例 1：绘制自定义形状<br>我们将使用 Godot 引擎的自定义绘制功能来绘制 Godot 本身没有提供函数的图形。将仅使用绘图函数重新创建 Godot 标志。<br>你需要编写一个函数来执行此操作并自行绘制。</p>
<blockquote>
<p>以下说明使用了一组固定坐标，该坐标对于高分辨率屏幕（大于 1080p）可能太小。如果是这种情况，并且绘图太小，请考虑在 菜单 &gt; 项目 &gt; 项目设置 &gt; 显示&#x2F;窗口&#x2F;拉伸&#x2F;缩放Display &gt; Window &gt; Stretch &gt; Scale 中增加窗口缩放比例，以将项目调整到更高的分辨率（2 或 4 倍缩放通常效果良好）。</p>
</blockquote>
<p>绘制自定义多边形形状<br>虽然存在用于绘制自定义多边形的专用节点 (Polygon2D)，但本例中将仅使用更底层的绘制函数，以便将它们组合在同样的节点上，并能够在之后创建更复杂的形状。<br>我们将首先定义一组点（或 X 和 Y 坐标），它们将构成形状的基础：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">var coords_head : Array = [</span><br><span class="line">	[ 22.952, 83.271 ],  [ 28.385, 98.623 ],</span><br><span class="line">	[ 53.168, 107.647 ], [ 72.998, 107.647 ],</span><br><span class="line">	[ 99.546, 98.623 ],  [ 105.048, 83.271 ],</span><br><span class="line">	[ 105.029, 55.237 ], [ 110.740, 47.082 ],</span><br><span class="line">	[ 102.364, 36.104 ], [ 94.050, 40.940 ],</span><br><span class="line">	[ 85.189, 34.445 ],  [ 85.963, 24.194 ],</span><br><span class="line">	[ 73.507, 19.930 ],  [ 68.883, 28.936 ],</span><br><span class="line">	[ 59.118, 28.936 ],  [ 54.494, 19.930 ],</span><br><span class="line">	[ 42.039, 24.194 ],  [ 42.814, 34.445 ],</span><br><span class="line">	[ 33.951, 40.940 ],  [ 25.637, 36.104 ],</span><br><span class="line">	[ 17.262, 47.082 ],  [ 22.973, 55.237 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这是一种简洁的格式，但并不是 Godot 用于绘制多边形所理解的格式。在其他情况下，我们可能需要从文件中加载这些坐标或在应用程序运行时计算它们的位置，因此可能需要进行一些转换。<br>为了将这些坐标转换为正确的格式，我们将创建一个新的方法 float_array_to_Vector2Array()。然后我们将重写 _ready() 函数，Godot 将仅在执行开始时调用该函数一次，以将这些坐标加载到变量中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var head : PackedVector2Array</span><br><span class="line"></span><br><span class="line">func float_array_to_Vector2Array(coords : Array) -&gt; PackedVector2Array:</span><br><span class="line">	# Convert the array of floats into a PackedVector2Array.</span><br><span class="line">	var array : PackedVector2Array = []</span><br><span class="line">	for coord in coords:</span><br><span class="line">		array.append(Vector2(coord[0], coord[1]))</span><br><span class="line">	return array</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	head = float_array_to_Vector2Array(coords_head);</span><br></pre></td></tr></table></figure>
<p>为了最终绘制第一个形状，我们将使用 draw_polygon 方法，并传递点（ Vector2 坐标数组）及其颜色，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	# We are going to paint with this color.</span><br><span class="line">	var godot_blue : Color = Color(&quot;478cbf&quot;)</span><br><span class="line">	# We pass the PackedVector2Array to draw the shape.</span><br><span class="line">	draw_polygon(head, [ godot_blue ])</span><br></pre></td></tr></table></figure>
<p>注意图标的下部看起来像是分段的，这是因为用于定义该部分的点数量较少。为了模拟平滑曲线，可以向数组中添加更多点，或者使用数学函数来插值曲线以从代码中创建平滑形状（参见 示例 2）。<br>多边形为了形成封闭的形状，总是会将 最后一个定义的点连接到第一个点 。</p>
<p>绘制连接线<br>绘制一系列不封闭成多边形的连接线与之前的方法非常相似。我们将使用一系列连接的线条来绘制 Godot 图标的嘴巴。<br>首先，我们将定义构成嘴巴形状的坐标列表，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var coords_mouth = [</span><br><span class="line">	[ 22.817, 81.100 ], [ 38.522, 82.740 ],</span><br><span class="line">	[ 39.001, 90.887 ], [ 54.465, 92.204 ],</span><br><span class="line">	[ 55.641, 84.260 ], [ 72.418, 84.177 ],</span><br><span class="line">	[ 73.629, 92.158 ], [ 88.895, 90.923 ],</span><br><span class="line">	[ 89.556, 82.673 ], [ 105.005, 81.100 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>我们将把这些坐标加载到一个变量中，并定义另一个变量来设置可配置的线条粗细：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var mouth : PackedVector2Array</span><br><span class="line">var _mouth_width : float = 4.4</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	head = float_array_to_Vector2Array(coords_head);</span><br><span class="line">	mouth = float_array_to_Vector2Array(coords_mouth);</span><br></pre></td></tr></table></figure>
<p>最终我们使用方法 draw_polyline 来真正绘制这条线，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	# We will use white to draw the line.</span><br><span class="line">	var white : Color = Color.WHITE</span><br><span class="line">	var godot_blue : Color = Color(&quot;478cbf&quot;)</span><br><span class="line"></span><br><span class="line">	draw_polygon(head, [ godot_blue ])</span><br><span class="line"></span><br><span class="line">	# We draw the while line on top of the previous shape.</span><br><span class="line">	draw_polyline(mouth, white, _mouth_width)</span><br></pre></td></tr></table></figure>
<p>与 draw_polygon() 不同，折线（polyline）的所有点只能有一个唯一的颜色（第二个参数）。此方法有 2 个附加参数：线的宽度（默认情况下尽可能小），和启用或禁用抗锯齿（默认情况下禁用）。</p>
<p>_draw 调用的顺序很重要，就像树状层次结构上的节点位置一样，将从上到下绘制不同的形状，这会使得新绘制的形状在重叠时隐藏掉较早绘制的形状。在本例中，我们希望将嘴放在头上，因此我们将其放在后面。</p>
<p>请注意我们如何以不同的方式定义颜色，无论是使用十六进制代码还是预定义的颜色名称。请检查类 Color 的其他常量和定义颜色的方法。</p>
<p>绘制圆<br>为了创建眼睛，我们将添加 4 个额外的调用来绘制不同大小、颜色和位置的眼睛形状。<br>为了绘制圆形，请使用 <code>draw_circle</code> 方法根据其圆的中心定位它。第一个参数是以 <code>Vector2</code> 形式写下的中心坐标，第二个参数是其半径，第三个参数是其颜色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	var white : Color = Color.WHITE</span><br><span class="line">	var godot_blue : Color = Color(&quot;478cbf&quot;)</span><br><span class="line">	var grey : Color = Color(&quot;414042&quot;)</span><br><span class="line"></span><br><span class="line">	draw_polygon(head, [ godot_blue ])</span><br><span class="line">	draw_polyline(mouth, white, _mouth_width)</span><br><span class="line"></span><br><span class="line">	# Four circles for the 2 eyes: 2 white, 2 grey.</span><br><span class="line">	draw_circle(Vector2(42.479, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(85.524, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(43.423, 65.92), 6.246, grey)</span><br><span class="line">	draw_circle(Vector2(84.626, 66.008), 6.246, grey)</span><br></pre></td></tr></table></figure>
<p>对于部分未填充的圆弧（某些任意角度之间的圆形部分），可以使用方法 draw_arc。</p>
<p>绘制线<br>为了绘制最终的形状（鼻子），我们将使用一条线来近似模拟它。<br>通过提供其开始和结束坐标作为参数，<code>draw_line</code> 可用于绘制单个线段，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	var white : Color = Color.WHITE</span><br><span class="line">	var godot_blue : Color = Color(&quot;478cbf&quot;)</span><br><span class="line">	var grey : Color = Color(&quot;414042&quot;)</span><br><span class="line"></span><br><span class="line">	draw_polygon(head, [ godot_blue ])</span><br><span class="line">	draw_polyline(mouth, white, _mouth_width)</span><br><span class="line">	draw_circle(Vector2(42.479, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(85.524, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(43.423, 65.92), 6.246, grey)</span><br><span class="line">	draw_circle(Vector2(84.626, 66.008), 6.246, grey)</span><br><span class="line"></span><br><span class="line">	# Draw a short but thick white vertical line for the nose.</span><br><span class="line">	draw_line(Vector2(64.273, 60.564), Vector2(64.273, 74.349), white, 5.8)</span><br></pre></td></tr></table></figure>
<p>请注意，如果要同时绘制多条未连接的线，可以通过使用 draw_multiline 方法在一次调用中绘制所有线，来获得额外的性能提升。</p>
<p>绘制文本<br>虽然向程序中添加文本的最常见方法是使用 <code>Label</code> 节点，但是低阶的 <code>_draw</code> 函数提供了在自定义 Node 绘制时添加文本的功能。我们就用这个方法在机器人的脑袋下面加上它的名字“GODOT”。<br>具体做法是调用 <code>draw_string</code>，类似于这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var default_font : Font = ThemeDB.fallback_font;</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	var white : Color = Color.WHITE</span><br><span class="line">	var godot_blue : Color = Color(&quot;478cbf&quot;)</span><br><span class="line">	var grey : Color = Color(&quot;414042&quot;)</span><br><span class="line"></span><br><span class="line">	draw_polygon(head, [ godot_blue ])</span><br><span class="line">	draw_polyline(mouth, white, _mouth_width)</span><br><span class="line">	draw_circle(Vector2(42.479, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(85.524, 65.4825), 9.3905, white)</span><br><span class="line">	draw_circle(Vector2(43.423, 65.92), 6.246, grey)</span><br><span class="line">	draw_circle(Vector2(84.626, 66.008), 6.246, grey)</span><br><span class="line">	draw_line(Vector2(64.273, 60.564), Vector2(64.273, 74.349), white, 5.8)</span><br><span class="line"></span><br><span class="line">	# Draw GODOT text below the logo with the default font, size 22.</span><br><span class="line">	draw_string(default_font, Vector2(20, 130), &quot;GODOT&quot;,</span><br><span class="line">				HORIZONTAL_ALIGNMENT_CENTER, 90, 22)</span><br></pre></td></tr></table></figure>

<p>其他参数以及其他和文本字符相关的方法都可以在 CanvasItem 的类参考中找到。</p>
<p>编辑时显示绘制<br>虽然目前这段代码已经可以在运行中的窗口中绘制 Logo，但却并没有在编辑器中的 2D 视图 上显示。在某些特定情况下，你希望自制的 Node2D 或者控件节点能够在编辑器中显示，跟其他绝大多数节点一样，这以便于定位和缩放。<br>为了能够在编辑器中直接显示 Logo，而不必运行程序，你可以使用 @tool 注解，来要求自制的绘制节点在编辑时显示，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@tool</span><br><span class="line">extends Node2D</span><br></pre></td></tr></table></figure>
<p>每当你添加或移除 @tool 注解时，你需要保存场景，重新构建项目（仅限 C#），并且选择菜单选项 场景 &gt; 重载已保存场景 来手动重载当前场景，才能刷新 2D 视图中的节点。</p>
<p>动画<br>如果希望自制图形在运行时改变形状，便需要修改执行时调用的方法或者参数，或者应用一个变换。<br>举个例子，如果想让我们刚刚设计的自制形状旋转，那么可以先 _ready 和<code>_process</code> 方法中添加如下变量和代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">@export var rotation_speed : float = 1  # In radians per second.</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	rotation = 0</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">func _process(delta: float):</span><br><span class="line">	rotation -= rotation_speed * delta</span><br></pre></td></tr></table></figure>
<p>上述代码的问题在于，我们所创建的点是差不多是从左上角，即坐标轴的 (0, 0) 处，扩展到右下角，所以看到的旋转才是以左上角为轴心的。对于节点的位置变换并不能帮到我们，因为旋转变化会先作用。</p>
<p>不过我们可以重写所有点的坐标，使其以 (0, 0) 点为中心，这就包括了坐标的负半轴，那可是个大工程。</p>
<p>一个可行的方案就是使用更底层的 draw_set_transform 方法来解决此问题，这个方法能够平移 CanvasItem 自身空间的所有点，然后再使用常规的节点变换将其移动至原位，用编辑器或代码均可，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func _ready():</span><br><span class="line">	rotation = 0</span><br><span class="line">	position = Vector2(60, 60)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	draw_set_transform(Vector2(-60, -60))</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>这就是最终结果，以 (60, 60) 点为轴心旋转</p>
<p>如果我们在 _draw() 中调用属性而动画化，必须调用 queue_redraw() 来强制刷新，否则不会在屏幕上更新内容。<br>例如，可以通过改变嘴巴线条的宽度，使机器人“张嘴”和“闭嘴”，宽度的变化遵循正弦 (sin) 曲线</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var _mouth_width : float = 4.4</span><br><span class="line">var _max_width : float = 7</span><br><span class="line">var _time : float = 0</span><br><span class="line"></span><br><span class="line">func _process(delta : float):</span><br><span class="line">	_time += delta</span><br><span class="line">	_mouth_width = abs(sin(_time) * _max_width)</span><br><span class="line">	queue_redraw()</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	...</span><br><span class="line">	draw_polyline(mouth, white, _mouth_width)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>请注意， _mouth_width 与任何其他属性一样，都是用户定义的属性。它或任何其他用作绘图参数的属性，都可以使用更标准的高级方法进行动画处理，例如 Tween 或 AnimationPlayer 节点。唯一区别是需要调用 queue_redraw() 应用更改，使内容在屏幕上显示。</p>
<p>示例 2：绘制动态线条<br>先前示例展示了如何使用自定义形状和动画绘制和修改节点。这种方法具有一些优势，如使用精确坐标和向量进行绘制，而不是位图（在屏幕上缩放时仍然清晰）。在某些情况下，也可以通过组合如 sprites 或 AnimatedSprites 等高级功能与节点来实现类似的效果，这些节点可以加载 SVG 格式资源，并使用 <code>AnimationPlayer</code> 节点。<br>在两点之间绘制直线<br>假设我们想要绘制一条连接两个点的直线，第一个点固定在屏幕左上角 (0, 0) ，第二个点由屏幕上的光标位置决定。<br>可以像这样绘制这两个点之间的动态的线:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">var point1 : Vector2 = Vector2(0, 0)</span><br><span class="line">var width : int = 10</span><br><span class="line">var color : Color = Color.GREEN</span><br><span class="line"></span><br><span class="line">var _point2 : Vector2</span><br><span class="line"></span><br><span class="line">func _process(_delta):</span><br><span class="line">	var mouse_position = get_viewport().get_mouse_position()</span><br><span class="line">	if mouse_position != _point2:</span><br><span class="line">		_point2 = mouse_position</span><br><span class="line">		queue_redraw()</span><br><span class="line"></span><br><span class="line">func _draw():</span><br><span class="line">	draw_line(point1, _point2, color, width)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们在每一帧都使用 get_mouse_position 方法获取鼠标在默认视口中的位置。如果位置与上次绘制请求时相比发生了变化（小优化，避免在每一帧都重新绘制），而进行一次重新绘制。<code>_draw()</code> 方法只有一行代码：请求绘制一条绿色线条，宽度为 10 像素，左上角和获取到的坐标之间。<br>起始点的宽度、颜色和位置可以通过相应的属性进行配置。</p>
<p>绘制两点之间的弧线<br>上面的例子可以实现效果，但有时可能想用除直线以外的形状或函数连接这两个点。<br>让我们尝试在两个点之间创建一个弧线（圆周的一部分）。<br>通过将线段的起始点、段数、宽度、颜色和抗锯齿属性导出为变量，从而可在编辑器检查器面板中方便修改这些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">@export var point1 : Vector2 = Vector2(0, 0)</span><br><span class="line">@export_range(1, 1000) var segments : int = 100</span><br><span class="line">@export var width : int = 10</span><br><span class="line">@export var color : Color = Color.GREEN</span><br><span class="line">@export var antialiasing : bool = false</span><br><span class="line"></span><br><span class="line">var _point2 : Vector2</span><br></pre></td></tr></table></figure>
<p>为了绘制弧线，可以使用 draw_arc 方法。事实上，穿过两个点的弧线有很多种，在这个例子中，我们将选择一个半圆，它的圆心位于初始两个点之间的中点。<br>确实，计算此弧线要比计算直线复杂得多:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func _draw():</span><br><span class="line">	# Average points to get center.</span><br><span class="line">	var center : Vector2 = Vector2((_point2.x + point1.x) / 2,</span><br><span class="line">								   (_point2.y + point1.y) / 2)</span><br><span class="line">	# Calculate the rest of the arc parameters.</span><br><span class="line">	var radius : float = point1.distance_to(_point2) / 2</span><br><span class="line">	var start_angle : float = (_point2 - point1).angle()</span><br><span class="line">	var end_angle : float = (point1 - _point2).angle()</span><br><span class="line">	if end_angle &lt; 0:  # end_angle is likely negative, normalize it.</span><br><span class="line">		end_angle += TAU</span><br><span class="line"></span><br><span class="line">	# Finally, draw the arc.</span><br><span class="line">	draw_arc(center, radius, start_angle, end_angle, segments, color,</span><br><span class="line">			 width, antialiasing)</span><br></pre></td></tr></table></figure>
<p>半圆的圆心将是两个点之间的中点。半径将是两个点之间距离的一半。起始角度和结束角度将分别为点 1 到点 2 的向量角度以及点 2 到点 1 的向量角度。需要注意的是，我们需要将 <code>end_angle</code> 归一化为正值，因为如果 <code>end_angle</code> 小于 <code>start_angle</code> ，则弧线将逆时针绘制，在这里，并不想要该效果 (弧线会上下颠倒)。</p>
<p>结果应该像这样，弧线向下延伸并穿过这些点：<br>可在检查器中调整参数以获得不同的结果：<br>改变颜色、宽度、抗锯齿，以及增加段数以提高曲线的平滑度，但这样会牺牲部分性能。</p>
<h4 id="2D-视差"><a href="#2D-视差" class="headerlink" title="2D 视差"></a>2D 视差</h4><p>视差是一种视觉效果，通过让图像纹理相对于相机以不同速度移动来模拟纵深。<br>Godot 提供了 <code>Parallax2D</code> 节点来实现这种效果。<br>建议使用他替代 <code>ParallaxLayer</code> 和 <code>ParallaxBackground</code> 节点。<br>使用方式：<br>确保使用的纹理的左上角位于 (0, 0) 交叉点，如下图所示。</p>
<p>滚动缩放<br>视差效果的核心是 <code>scroll_scale</code> 属性，滚动速度系数<br>设为 1 时视差节点与相机同速。<br>远，请使用小于 1 的值，设为 0 就会完全停止。<br>近，请使用大于 1 的值，这样图像滚动得就会更快。<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/2d_parallax_size_viewport.webp"><br>上面这个场景由五个图层构成，对应的 <code>scroll_scale</code> 可以设置为：<br>(0.7, 1) - 森林<br>(0.5, 1) - 山丘<br>(0.3, 1) - 低处的云<br>(0.2, 1) - 高处的云<br>(0.1, 1) - 天空</p>
<p>无限重复<br>相机移动时，<code>repeat_size</code> 可以让节点的位置根据这个值向前或向后吸附。<br>这个效果的原理是让所有子级画布项重复一次并使用这个值进行偏移。<br>而相机在原本的图像和重复的图像之间滚动，悄悄跳回原本的位置就会造成图像循环的效果。</p>
<p>大小问题<br>为了方便实现无限重复效果，图像本身最好就需要能够无缝重复，并且需要图像的大小在设置 <code>repeat_size</code> 之前至少要和视口大小一致。<br>下例是一个在视口中显得太小的纹理:<br>我们可以看到视口的尺寸是 500x300 而纹理的尺寸是 288x208。<br>如果我们把 <code>repeat_size</code> 设置为图像的尺寸，无限重复效果在滚动时就会出问题，因为原始纹理没有覆盖整个视口。<br>如果我们把 <code>repeat_size</code> 设置为视口的尺寸，那么就会有一个很大的间隙。那该怎么办呢？</p>
<ol>
<li>把视口调小<br>最简单的答案是将视口设置为与纹理大小相同或更小。在 项目设置 &gt; 显示 &gt; 窗口 中，更改视口宽度和视口高度设置，使其与背景匹配。</li>
<li>缩放 Parallax2D<br>如果你想要实现的不是完美像素风，或者不介意存在略微的模糊，那么你可以选择将纹理放大到适合屏幕的尺寸。<br>请设置 <code>Parallax2D</code> 的 scale，所有子级纹理都会对应发生缩放。</li>
<li>缩放子节点<br>和放大 <code>Parallax2D</code> 类似的是将 Sprite2D 节点放大到能够覆盖住屏幕。请注意，Parallax2D.repeat_size 和 Sprite2D.region_rect 等设置并不会考虑缩放，因此这些值也需要根据缩放进行调整。</li>
<li>重复纹理<br>你也可以通过提前准备子节点来确保从一开始就走上正确的道路。如果你有一个希望重复的 Sprite2D，但它的尺寸太小，就可以按照以下步骤来重复它：<br>将 <code>texture_repeat</code> 设置为 CanvasItem.TEXTURE_REPEAT_ENABLED<br>将 <code>region_enabled</code> 设置为 true<br>将 <code>region_rect</code> 设置为纹理大小的倍数，让纹理足够覆盖住视口。<br>下图中可以看到，把图像重复一次就足够覆盖住屏幕了。</li>
</ol>
<p>位置问题<br>应当尽量避免把所有纹理都设成在 (0,0) 居中<br>“无限重复画布”从 (0,0) 开始，向右下扩展至 repeat_size 的大小值。<br>如果纹理是以 (0,0) 交叉点为中心的，那么无限重复画布只会被部分覆盖，因此也只会部分地重复。</p>
<p>把 repeat_times 调大有用吗？<br>从技术上来说，增加 <code>repeat_times</code> 在某些情况下将是可行的，但这是一种暴力的解决方案，而不是它被设计用于解决的问题（我们稍后会讨论这个问题）。<br>更好的解决方法是理解重复效果的工作原理，并在开始时就适当地设置视差纹理。<br>首先，检查是否有任何纹理溢出到画布的负轴向。确保在视差节点中使用的纹理都位于从 (0,0) 开始的“无限重复画布”内。<br>这样，如果正确设置了 <code>Parallax2D.repeat_size</code>，效果应该看起来像这样，图像的单次循环与视口大小相同或更大：<br>想象一下图像是如何在屏幕上滚动的，它首先显示红色矩形内的内容（由 repeat_size 确定），当到达黄色矩形内时，它会将图像向前拉动，从而给人一种永远滚动的感觉。<br>如果你将图像放置在“无限重复画布”之外的位置，当摄像机到达黄色矩形区域时，图像的一半会被裁切掉，然后才会向前跳转，就像下图所示：</p>
<p>滚动偏移<br>如果你的视差纹理已经正常工作，但你希望它从不同的点开始，Parallax2D 附带一个 <code>scroll_offset</code> 属性，用于偏移无限重复画布的开始位置。<br>例如，如果你的图像是 288x208，将 <code>scroll_offset</code> 设置为 (-144,0) 或 (144,0) 可使其从图像的中间位置开始。</p>
<p>重复次数<br>理想情况下，按照本指南操作，你的视差纹理足够大，即使在缩小时也能覆盖屏幕。到目前为止，我们在 288x208 视口内拥有一个完美贴合的 288x208 纹理。<br>但是，当我们通过将 <code>Camera2D.zoom</code> 设置为 (0.5, 0.5) 进行缩小时，会出现问题：<br>尽管在默认缩放级别下，视口的所有内容都已正确设置，但缩小后会使它小于该视口，从而破坏无限重复效果。<br>这时 repeat_times 就可以提供帮助。将值设置为 3（前后各一个额外的重复），现在它就足够大，可以容纳无限重复的效果了。<br>如果这些纹理需要垂直地重复，我们应该为 repeat_size 指定一个 y 值。repeat_times 也会自动在上方和下方添加重复。<br>这只是一个水平视差，因此它会在图像上方和下方留下一个空白块。<br>我们如何解决这个问题？我们需要发挥创造力！在这个例子中，我们将天空拉高，将草精灵拉低。纹理现在支持正常缩放级别以及缩小到一半大小。</p>
<p>分屏<br>大多数用 Godot 制作分屏游戏的教程一开始都是要写一个简单的脚本.<br>把第一个 SubViewport 的 Viewport.world_2d 赋值给第二个 SubViewport，从而实现屏幕的共享。此时就会产生如何在这两个屏幕之间共享视差效果的问题。<br>视差效果模拟透视的方法是让不同的纹理根据其与相机的关系移动不同的距离。<br>存在多个相机时，很显然就会出现问题，因为同一个纹理不可能同时出现在两个不同的地方！<br>解决方法也是有的，把视差节点往第二个（或者第三第四个） SubViewport 里复制一份就好了。在双人游戏里是这个样子的：<br>当然，现在两个背景都会在两个 SubViewport 中显示。我们希望的是每个视差背景只在其对应的视口中显示。你可以通过以下方式实现这一点：<br>将所有视差节点的 visibility_layer 保留为其默认值 1 。<br>将第一个 SubViewport 的 canvas_cull_mask 设置为仅 1 号图层和 2 号图层。<br>对第二个 SubViewport 执行相同的操作，但使用图层 1 和 图层 3。<br>为第一个 SubViewport 中的视差节点提供一个共同的父节点，并将其 visibility_layer 设置为 2。<br>对第二个 SubViewport 的视差节点执行相同的操作，但使用 3 号图层。</p>
<p>这是如何工作的？<br>如果一个画布项的 visibility_layer 与 SubViewport 的 canvas_cull_mask 不匹配，它将隐藏所有子节点，即使它们匹配也是如此。<br>我们利用这一点，让 SubViewport 停止那些父节点没有匹配的 visibility_layer 的视差节点的渲染。</p>
<p>在编辑器中预览<br>4.3 版本之前推荐的是把每个层都放到各自的 ParallaxBackground 下面，然后启用 follow_viewport_enabled 属性，再对各个层进行缩放。这个方法要用对还挺难的，用 CanvasLayer 代替 ParallaxBackground 也能达到想要的效果。</p>
<blockquote>
<p>另外推荐 KoBeWi 的“Parallax2D Preview”插件。这个插件提供了很多预览模式，挺好用的！</p>
</blockquote>
<h3 id="物理与移动"><a href="#物理与移动" class="headerlink" title="物理与移动"></a>物理与移动</h3><p>2D 运动概述<br>使用 <code>CharacterBody2D</code><br>也适用于其他节点类型（如 Area2D、RigidBody2D）。</p>
<p>场景布置<br>以下每个示例都使用相同的场景布置。<br>从带有 <code>Sprite2D</code> 和 <code>CollisionShape2D</code> 这两个子节点的 <code>CharacterBody2D</code> 开始。</p>
<ol>
<li>八向移动</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extends CharacterBody2D</span><br><span class="line"></span><br><span class="line">@export var speed = 400</span><br><span class="line"></span><br><span class="line">func get_input():</span><br><span class="line">	var input_direction = Input.get_vector(&quot;left&quot;, &quot;right&quot;, &quot;up&quot;, &quot;down&quot;)</span><br><span class="line">	velocity = input_direction * speed</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	get_input()</span><br><span class="line">	move_and_slide()</span><br></pre></td></tr></table></figure>
<p>在函数 get_input() 中，我们使用 Input 的 get_vector() 来检查四个按键事件，并返回一个方向向量的累加值。<br>然后，我们可以将长度为 1 的方向矢量乘以所需的速度来设定速度。<br>2. 旋转+移动<br>“Asteroids式运动”类似于经典街机游戏Asteroids的工作方式。<br>按左&#x2F;右旋转角色，而按上&#x2F;下使得角色在面向的方向上向前或向后。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extends CharacterBody2D</span><br><span class="line"></span><br><span class="line">@export var speed = 400</span><br><span class="line">@export var rotation_speed = 1.5</span><br><span class="line">var rotation_direction = 0</span><br><span class="line"></span><br><span class="line">func get_input():</span><br><span class="line">	rotation_direction = Input.get_axis(&quot;left&quot;, &quot;right&quot;)</span><br><span class="line">	velocity = transform.x * Input.get_axis(&quot;down&quot;, &quot;up&quot;) * speed</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	get_input()</span><br><span class="line">	rotation += rotation_direction * rotation_speed * delta</span><br><span class="line">	move_and_slide()</span><br></pre></td></tr></table></figure>
<p>这里我们添加了两个变量来跟踪我们的旋转方向和速度。旋转直接应用于主体的 rotation 属性。<br>要设置速度，我们使用物体的 transform.x ，这是一个指向物体 “前进” 方向的矢量，然后乘以速度。<br>3. 旋转+移动（鼠标）<br>这种运动方式是前一种运动方式的变体。角色将始终“看向”鼠标指针。前进&#x2F;后退输入保持不变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extends CharacterBody2D</span><br><span class="line">@export var speed = 400</span><br><span class="line"></span><br><span class="line">func get_input():</span><br><span class="line">	look_at(get_global_mouse_position())</span><br><span class="line">	velocity = transform.x * Input.get_axis(&quot;down&quot;, &quot;up&quot;) * speed</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	get_input()</span><br><span class="line">	move_and_slide()</span><br></pre></td></tr></table></figure>
<p>这里我们用到 Node2D 中的 look_at() 方法，使玩家朝向鼠标的位置。如果没有此功能，可以通过如下设置角度以获得相同的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rotation = get_global_mouse_position().angle_to_point(position)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>点击并移动<br>最后一个示例仅使用鼠标来控制角色。 单击屏幕将使游戏角色移动到目标位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extends CharacterBody2D</span><br><span class="line"></span><br><span class="line">@export var speed = 400</span><br><span class="line">var target = position</span><br><span class="line"></span><br><span class="line">func _input(event):</span><br><span class="line">	# Use is_action_pressed to only accept single taps as input instead of mouse drags.</span><br><span class="line">	if event.is_action_pressed(&amp;&quot;click&quot;):</span><br><span class="line">		target = get_global_mouse_position()</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	velocity = position.direction_to(target) * speed</span><br><span class="line">	# look_at(target)</span><br><span class="line">	if position.distance_to(target) &gt; 10:</span><br><span class="line">		move_and_slide()</span><br></pre></td></tr></table></figure>
<p>注意我们在移动之前做的 distance_to() 检查。<br>如果没有这个检查，物体在到达目标位置时会 “抖动”，因为它稍微移过该位置时就会试图向后移动，只是每次移动步长都会有点远从而导致来回重复移动。<br>如果你喜欢，取消注释的 rotation 代码可以使物体转向其运动方向。<br>小技巧:<br>该技术也可以用到“跟随”的游戏角色中。<br>target 目标位置可以是任何你想移动到的对象的位置。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="使用-TileSet"><a href="#使用-TileSet" class="headerlink" title="使用 TileSet"></a>使用 TileSet</h4><p>使用 <code>TileMapLayer</code> 节点设计关卡有很多好处。<br>首先，在绘制布局时可以直接把图块“画”到栅格上，比放置 Sprite2D 节点要快很多。<br>其次，由于图块地图针对大量图块的绘制进行了优化，支持更大的关卡。<br>最后，可以添加更强大的功能，诸如碰撞、遮挡、导航等形状。</p>
<p>用法：</p>
<ol>
<li>创建 TileSet（图块集）</li>
<li>添加图块表（Tilesheet）<br> 默认图块形状是 Square（正方形），也可以选择 Isometric（等轴）、Half-Offset Square（半偏移正方形）、Hexagon（六边形）。<br> 使用了 Square 以外的图块形状可能需要调整 Tile Layout（图块布局）和 Tile Offset Axis（图块偏移轴）。<br> 要让图块被图块坐标裁剪，还可以启用 Rendering &gt; UV Clipping（渲染 &gt; UV 裁剪）属性。<br> 这样就能够保证图块无法绘制到它们在图块表上分配的区域之外。</li>
</ol>
<p>如果依赖于自动图块创建，必须在创建图集前设置图块大小。<br>图集将确定哪些从图块表中而来的图块可以添加到 TileMap 节点（因为并不是图像的每一个部分都是有效的图块）。</p>
<p>如果你想在一个 TileSet 中使用好几张图块表来选择图块，新建几个图块集，并为每个图块集配置纹理再继续。<br>也可以用这种方法把单张图片作为一个图块来使用。（但是用图块表会方便得多）。</p>
<p>可以在图集上调整以下属性：</p>
<ul>
<li>ID： 标识符（在该 TileSet中每个图块集的标识符是唯一的），用于排序。</li>
<li>名称： 在此处使用描述性的名称来方便管理（例如“地形”，“装饰”等）。</li>
<li>边距： 图像边缘上的边距不应选择为图块（以像素为单位）。当你下载的图块表图像的边缘有边距（例如，用于表明归属），则增加这个值可能会很有用。</li>
<li>间距： 以像素为单位的地图集上的每个图块之间的间距。如果你使用的图块表图像包含辅助线（例如每个图块之间的轮廓），则增加间距可能会很有用。</li>
<li>纹理区域大小：以像素为单位的图集上的每个图块的大小。在大多数情况下，这应该与 TileMapLayer 属性中定义的图块大小相匹配（尽管并不是必需的）。</li>
<li>使用纹理内边距： 选用，则在每个图块周围添加一个1像素的透明的边缘，以防止启用过滤时纹理渗出（bleeding）。建议默认将其启用。<br>请注意，更改纹理边距，间距和区域大小都有可能会导致图块丢失（其中一些将位于图集图片的坐标之外）。<br>如要自动从图块表中再生图块，请使用图块集编辑器顶部的三个垂直点菜单按钮，然后选择<strong>在不透明纹理区域创建图块</strong> ：<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/using_tilesets_recreate_tiles_automatically.webp"></li>
</ul>
<p>使用场景合集<br>可以将实际的<strong>场景</strong>放置为图块。允许将任何节点集合用作图块。<br>比如说，可以使用场景图块来放置游戏元素，例如玩家可以与之互动的商店。<br>还可以使用场景图块来放置 AudioStreamPlayer2D （用于环境声音）、粒子效果等。</p>
<p class="div-border" style="background-color: rgba(196, 26, 26, 0.1);border: 1px solid #c41a1aff;border-radius: 0.4rem;">
<mark class="hl-label red">警告</mark><br>
与图集相比，场景图块具有更大的性能开销，因为每个场景都是为每个放置的图块单独实例化的。<br>
建议仅在必要时使用场景图块。要在没有任何高级操作的图块中绘制精灵，请使用图集代替。
</p>

<p>对于本例，将创建一个包含 <code>CPUParticles2D</code> 根节点的场景。<br>将此场景保存到场景文件（与包含 TileMapLayer 的场景分离）<br>然后切换到包含 <code>TileMapLayer</code> 节点的场景，创建一个新的场景集合。<br>为场景合集输入描述名称，创建一个新的场景槽。</p>
<p>将若干图集合并为单个图集<br>必须在TileSet资源处创建了不止一个图集(atlas)。<br>在图集(atlas)列表下找到“三个垂直排列的点”的菜单按钮，选择<strong>打开图集合并工具</strong><br>通过按住 Shift 或 Ctrl 键并同时点击多个元素来选择多个图集<br>选择<strong>合并</strong>合并成一个图集图片。</p>
<p class="div-border" style="background-color: rgba(26, 196, 35, 0.1);border: 1px solid #1ac439ff;border-radius: 0.4rem;">
<mark class="hl-label green">小技巧</mark><br>
TileSet 具有一个 图块代理 系统。图块代理是一张映射表，它允许通知使用了给定 TileSet 的 TileMap，以便将一组给定的图块标识符替换为另一组图块标识符。<br>
合并不同图集时会自动设置图块代理，但也可以通过 管理图块代理 对话框手动设置，你可以使用上面提到的“三个竖点”菜单访问该对话框。<br>
当你更改了图集 ID 或想用另一个图集的图块替换一个图集的所有图块时，手动创建图块代理可能会很有用。请注意，编辑 TileMap 时，你可以用相应的映射值替换所有网格。
</p>

<p>向 <code>TileSet</code> 添加碰撞、导航和遮挡<br>首先为 <code>TileSet</code> 资源创建物理层、导航层或遮挡层。</p>
<ol>
<li>请选择 <code>TileMapLayer</code> 节点，单击检查器中的 <code>TileSet</code> 属性值进行编辑，然后展开 物理层 并选择 添加元素：</li>
<li>导航辅助，可以创建导航层</li>
<li>光照多边形遮挡器，可以创建遮挡层<br>本教程的后续步骤专门用于创建碰撞多边形，但导航和遮挡的步骤非常相似。<br>唯一需要注意的是，图块的遮挡多边形属性是图集检查器中<strong>渲染</strong>分节的一部分。请确保展开该部分，以便编辑多边形。<br>创建物理层后访问 TileSet 检查器中<strong>选择</strong>的<strong>物理层</strong>部分。</li>
</ol>
<p class="div-border" style="background-color: rgba(26, 196, 35, 0.1);border: 1px solid #1ac439ff;border-radius: 0.4rem;">
<mark class="hl-label green">小技巧</mark><br>
你可以在聚焦 TileSet 编辑器时按 F 快速创建矩形碰撞形状。<br>
如果你有一个大的图块集，为每个图块单独指定碰撞可能会花费很多时间。<br>
要快速将类似的碰撞形状应用到多个图块，请使用<一次为多个图块指定属性的功能>。
</p>

<p>为 <code>TileSet</code> 的图块分配自定义元数据<br>使用<strong>自定义数据层</strong>用来存储游戏过程中所需的特定信息。<br>例如玩家接触该图块时应该受到的伤害，以及是否能够使用物理将图块摧毁。<br>数据是在 <code>TileSet</code> 中与图块进行关联的：放置的所有图块使用的都是相同的自定义数据。<br>如果你需要创建拥有不同自定义数据的变体图块，可以通过创建备选图块并为该备选图块更改自定义数据来实现。<br>改变自定义数据的顺序不会损坏现有的元数据：TileSet 编辑器会在自定义数据属性的顺序发生改变后自动进行更新。</p>
<p>创建地形集（自动图块）</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
这个功能和 Godot 3.x 中的自动图块使用了不同的实现方式。<br>
地形系统能够完全替代自动图块，功能也更强大。与自动图块不同，地形系统支持不同地形之间的过渡，这样就可以为同一个图定义多个地形。<br>
与以前不同的是，自动图块是一种特定类型的图块，而地形只是分配给图集图块的一组属性。<br>
使用专门的 TileMap 绘制模式时就会用到这些属性，该模式能够对带有地形数据的图块进行智能选择。<br>
这意味着地形图块既可以作为地形绘制，也可以像其他图块一样作为单个图块绘制。
</p>
“完善”的图块集中通常会包含很多变体图块，适用于平台、地板等位置的角落和边缘。
这种图块虽然可以手动放置，但是很快就会感觉非常麻烦。
在程序式生成的关卡中如果要处理这种情况也很困难，需要编写大量的代码。

<p>Godot 提供的地形系统就能够自动进行图块的连接。这样就可以自动使用“正确”的图块变体。</p>
<ol>
<li>地形按照地形集分组。</li>
<li>地形集有固定的模式，包括 Match Corners and Sides、Match Corners、Match sides（匹配角落和边缘、匹配角落、匹配边缘）。</li>
<li>模式决定了地形集中的地形如何相互匹配。</li>
</ol>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
上述模式在 Godot 3.x 中对应的自动图块位掩码模式为 2×2、3×3、3×3 Minimal。
也和 Tiled 编辑器中使用的模式类似。
</p>

<p>选中 <code>TileMapLayer</code> 节点，转到检查器的 TileSet 资源中创建一个新的地形集：<br>创建地形集后，你必须在地形集中再创建若干地形：<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/using_tilesets_create_terrain.webp"></p>
<p>在 TileSet 编辑器中，切换到“选择”模式并单击图块。<br>在中间一栏展开地形部分，为图块分配地形集 ID 和地形 ID。<br>-1 表示“没有地形集”和“没有地形”，因此你必须先将地形集设置为大于等于 0 的值，然后才能将地形设置为大于 0 的值。</p>
<blockquote>
<p>地形集 ID 和地形 ID 互相独立。从 0 开始，不从 1 开始。</p>
</blockquote>
<p>完成此操作后，现在可以配置<strong>地形邻接值（Terrain Peering Bits）</strong>，该部分在中间一列中可见。<br>邻接值决定了根据相邻图块的情况放置哪个图块。-1 是一个特殊值，表示空白空间。<br>例如，如果一个地砖的所有位都设置为 0 或更大，那么只有在 所有 8个相邻图块都使用具有相同地形 ID 的图块时，它才会出现。<br>如果图块的位设置为“0”或更大，但左上、上和右上的位设置为“-1”，则只有在其顶部（包括对角线）有空位时才会出现。</p>
<p>一次为多个图块指定属性<br>有两种方法可以同时为多个图块分配属性。根据你的使用情况，一种方法可能比另一种方法更快：</p>
<ol>
<li>使用多个图块选择<br> 如果希望一次在多个图块上配置多种属性，请选择 TileSet 编辑器顶部的 选择 模式：<ul>
<li>选择多个图块。</li>
<li>使用 TileSet 编辑器中间一列的检查器分配属性。只有在此更改的属性才会应用到所有选定的图块。</li>
</ul>
</li>
<li>使用图块属性绘制<br>如果要一次将单个属性应用于多个图块，则可以使用<em>属性绘制</em>模式来实现此目的。<br>在中间一列配置要绘制的属性，然后点击右列中的图块（或按住鼠标左键）以将属性“绘制”到图块上。<br>对于手动设置耗时的属性（例如碰撞形状），图块属性绘制特别有用</li>
</ol>
<p>创建备选图块<br>使用单一的图块图像（在图集中只能找到一次），但要以不同的方式进行配置。<br>例如，使用相同的图块图像，但对它进行旋转、翻转或调制成不同的颜色。这就可以使用<strong>备选图块</strong>来实现。</p>
<p class="div-border" style="background-color: rgba(26, 196, 35, 0.1);border: 1px solid #1ac439ff;border-radius: 0.4rem;">
<mark class="hl-label green">小技巧</mark><br>
从 Godot 4.2 开始，你将不再必须通过创建替代图块来旋转或翻转图块。<br>
你可以使用 TileMap 编辑器工具栏中的旋转/翻转按钮，在任何图块放置进 TileMap 编辑器中时旋转它。
</p>

<p>创建备选图块，右键基本图块:</p>
<ul>
<li>备用 ID： 此可选图块的唯一数字标识符。更改它会破坏现有的瓦片地图，所以要小心！此 ID 还控制在编辑器中显示的可选图块列表中的排序。</li>
<li>渲染 &gt; 水平翻转</li>
<li>渲染 &gt; 垂直翻转</li>
<li>渲染 &gt; 转置</li>
<li>渲染 &gt; 纹理原点：绘制图块时使用的原点。可以用来将图块进行相对于基础图块的视觉偏移。</li>
<li>渲染 &gt; 调制：渲染图块时的颜色乘数。</li>
<li>渲染 &gt; 材质：当前图块使用的材质。可以使用此选项为单个图块应用不同的混合模式或自定义着色器。</li>
<li>Z 索引： 当前图块的排序。数值大的图块会渲染在同一层中的其他图块之上。</li>
<li>Y 排序原点（Y Sort Origin）：基于其 Y 坐标（以像素为单位）进行图块排序时要使用的垂直偏移量。<br>  这使得可以将图层视为在不同高度上用于俯视角的游戏。<br>  调整此值可以帮助缓解某些图块排序的问题。仅当 CanvasItem &gt; Ordering 下的 TileMapLayer 图层的 Y Sort Enabled 为<strong>启用</strong>时才有效。<blockquote>
<p>可以通过点击在备选图块旁的大 “+” 图标来创建额外的 备选图块变体。这相当于选择基本图块并右键点击它以再次选择创建备选图块。</p>
</blockquote>
</li>
</ul>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
当创建一个备选图块时，其基本图块的任何属性将不会被继承下来。如果你希望备选图块与基本图块的属性相同，那么你需要在备选图块中重新设置这些属性。
</p>


<h4 id="使用-TileMap"><a href="#使用-TileMap" class="headerlink" title="使用 TileMap"></a>使用 TileMap</h4><p>在 TileMapLayer 中指定 TileSet<br>如果你已经进行了使用 TileSet 所述的步骤，你现在应该有一个内嵌进 TileMapLayer 节点的 TileSet 资源。<br>这样的做法适合制作原型，但在实际项目当中，你一般会有多个关卡复用同一个图块集。</p>
<p>要在多个 TileMapLayer 节点中复用同一个 TileSet ，建议将 TileSet 保存到外部资源。<br>为此，请点击 TileSet 资源旁边的下拉菜单 ，然后选择 保存 ：<br><img src="https://wzcwzc10.github.io/posts_img/godot/04/using_tilemaps_save_tileset_to_resource.webp"></p>
<p>多 TileMapLayer 及相关设置<br>使用图块地图时，适当情况下通常建议使用多个TileMapLayer节点。<br>你可以每个图层放置一个图块在给定位置，如果你有不止一层就能实现多个图块的叠加。<br>每个TileMapLayer节点都有几个可以调整的属性： </p>
<ol>
<li>Enabled：true，当前图层在编辑器中和运行项目时可见。</li>
<li>TileSet：图块集。</li>
<li>渲染 (Rendering)<ul>
<li>Y Sort Origin： 每个图块在Y 轴排序时使用的垂直偏移量（以像素为单位）。仅在CanvasItem设置下 Y Sort Enabled 为 true 时有效。</li>
<li>X轴绘制顺序反转：反转X轴上图块的绘制顺序。要求在CanvasItem设置中“Y轴排序启用”为真。</li>
<li>Rendering Quadrant Size 象限是为了优化目的而绘制在单个 CanvasItem 上的一组图块。此设置定义了地图坐标系中正方形边的长度。该象限大小不适用于 Y 排序的 TileMapLayer，因为在这种情况下图块是按 Y 位置分组的。</li>
</ul>
</li>
<li>物理 (Physics)<ul>
<li>Collision Enabled 启用或禁用碰撞。</li>
<li>Use Kinematic Bodies 当为 true 时，TileMapLayer 的碰撞形状将实例化为运动学刚体。</li>
<li>Collision Visibility Mode TileMapLayer的碰撞形状是否可见。如果设置为默认，则取决于显示碰撞的调试设置。</li>
</ul>
</li>
<li>导航 (Navigation)<ul>
<li>Navigation Enabled（导航启用）是否启用导航区域。</li>
<li>Navigation Visible TileMapLayer 的导航网格是否可见。如果设置为默认，则取决于显示导航的调试设置。</li>
</ul>
</li>
</ol>
<p class="div-border" style="background-color: rgba(26, 196, 35, 0.1);border: 1px solid #1ac439ff;border-radius: 0.4rem;">
<mark class="hl-label green">小技巧</mark><br>
TileMap 内置导航存在许多实际限制，导致寻路性能和路径跟随质量较差。<br>
在设计完 TileMap 后，考虑将其烘焙成一个更优化的导航网格（并禁用TileMap的NavigationLayer）<br>
使用 NavigationRegion2D 或 NavigationServer2D。查看 使用导航网格 以获取更多信息。
</p>
2D 导航网格不能像视觉元素或物理形状那样进行“分层”或彼此堆叠。尝试在同一导航地图上堆叠导航网格会导致合并和逻辑错误，破坏寻路功能。

<p>绘制模式和工具<br>TileMap 编辑器顶部的工具栏从左到右，可以选择的绘制模式和工具是：</p>
<ul>
<li>选择<br>在2D编辑器中，可以通过单击单个图块或按住鼠标左键框选多个图块来选择。<br>请注意，无法选择空白区域：如果创建了一个矩形选择，只会选择非空图块。<br>要追加到当前选择，按 Shift 键，然后选择一个图块。要从当前选择中删除，请按 Ctrl 键，然后选择一个图块。<br>然后可以在任何其他绘画模式下使用该选择来快速创建已放置模式的副本。<br>可以通过按 Del ，从 TileMap 中删除选定的图块。<br>在绘制模式下，可以通过按住 Ctrl 键然后进行选择来暂时切换到此模式。<br>可以复制并粘贴已经放置的图块：选择图块，按 Ctrl+C 键，然后按 Ctrl+V 键，也可以通过左键单击将所选内容粘贴到图中。还可以按 Ctrl+V 键再次进行复制，右键单击或按 Escape 键可取消粘贴。</li>
<li>绘制</li>
<li>线段</li>
<li>矩形</li>
<li>油漆桶填充</li>
<li>拾取器</li>
<li>橡皮</li>
<li>使用散布随机绘图</li>
</ul>
<p>使用模式保存和加载预制的图块放置<br>要创建图案，切换到“选择”模式，选择已经在2D场景绘制的图案 Ctrl+C。<br>单击“图案”选项卡中的空白区域 Ctrl+V。<br>要使用现有图案，请在图案选项卡中单击其图像，切换到绘画模式。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
尽管图案是在 TileMap 编辑器中编辑的，但它存储在 TileSet 资源中。<br>
这样允许在加载保存到外部文件的 TileSet 资源后，在不同的 TileMapLayer 节点中复用图案。
</p>

<p>自动处理地形的图块连接<br>要使用地形，TileMapLayer 节点必须至少包含一个地形集和该地形集中的一个地形。如果尚未为 TileSet 创建地形集，请参考 创建地形集（自动图块） 。<br>地形连接有 3 种绘图模式可选：</p>
<ol>
<li>连接 ，图块与相同 TileMapLayer 上的周围图块相连。</li>
<li>路径，图块会与相同笔画绘制出的图块相连（直到松开鼠标按键）。</li>
<li>图块特定的覆盖以解决冲突或处理地形系统未涵盖的情况。<br>“连接”模式更容易使用，但“路径”更灵活，因为它允许艺术家在绘制过程中进行更多控制。<br>例如，“路径”可以让道路直接相邻而不相互连接，而“连接”则会强制两条道路相连。<br>最后，在某些情况下，你可以从地形中选择特定的图块来解决冲突。<br>任何至少有一个位（bit）设置为对应地形 ID 的值的图块将出现在可供选择的图块列表中。</li>
</ol>
<p>处理缺失图块<br>如果删除 TileMap 所引用 TileSet 中的图块，TileMap 将显示一个占位符，表示放置的图块 ID 无效：<br>这些占位符在运行的项目中不可见，但图块数据仍会持久保存在磁盘中。这样你就可以安全地关闭和重新打开此类场景。<br>重新添加具有匹配 ID 的图块后，图块将以新图块的外观出现。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
在选择 TileMapLayer 节点并打开 TileMap 编辑器之前，可能无法看到缺失的图块占位符。
</p>


<h2 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h2><h3 id="3D-简介"><a href="#3D-简介" class="headerlink" title="3D 简介"></a>3D 简介</h3><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><p>坐标系<br>Godot 在 3D 中使用公制，1 个单位等于 1 米。<br>使用 3D 资产时，最好始终使用正确的比例（在 3D 建模软件中将单位设置为公制）。<br>Godot 允许在导入后缩放，尽管在大多数时都没问题，但在极少数情况下，会在渲染或物理等敏感区域带来浮点精度问题（从而导致故障或伪影）。<br>确保你的艺术家始终在正确的比例下进行创作！<br>X 是两边<br>Y 是上&#x2F;下<br>Z 是前&#x2F;后<br><img src="https://wzcwzc10.github.io/posts_img/godot/05/introduction_to_3d_coordinate_systems.webp" alt="坐标系"><br>一些有用的键盘绑定:<br>要吸附放置或旋转，在移动、缩放或旋转时按 Ctrl 键。<br>要将视图居中到所选对象上，请按 F。</p>
<p>在 3D 环境中导航<br>默认的3D场景导航控制类似于 Blender<br>在编辑器设置中也包含了自定义鼠标按钮和行为的选项，就仿佛使用其他工具那样。<br>打开 编辑器设置&gt;各编辑器&gt;3D 。然后在导航下，找到导航方案 。</p>
<p>使用 Blender 风格的变换快捷键<br>从 Godot 4.2 开始，可以启用 Blender 风格的快捷键来平移、旋转和缩放节点。<br>在 Blender 中，这些快捷键分别是：</p>
<ul>
<li>G 用于平移</li>
<li>R 用于旋转</li>
<li>S 用于缩放</li>
</ul>
<p class="div-border" style="background-color: rgba(26, 196, 35, 0.1);border: 1px solid #1ac439ff;border-radius: 0.4rem;">
<mark class="hl-label green">小技巧</mark><br>
在聚焦于 3D 编辑器视口的同时，按下快捷键，可以移动鼠标或输入数字以将选定节点移动指定的 3D 单位量。<br>
你可以通过用字母指定特定的轴，然后指定距离（如果使用键盘来输入值），以此来将选中节点的平移限制到特定的轴上。<br>
例如，要将选中物体向上移动 2.5 个单位，请按顺序输入以下序列<br>
G-Y-2-.-5-Enter
</p>

<p>在 Godot 中使用 Blender 风格的变换快捷键<br>编辑器设置的快捷键选项卡，然后在 <code>Spatial Editor</code> 部分中进行以下调整：</p>
<ul>
<li>将开始平移变换绑定到 G。</li>
<li>将开始旋转变换绑定到 R。</li>
<li>将开始缩放变换绑定到 S。</li>
<li>取消缩放模式快捷键的绑定，避免冲突。</li>
</ul>
<h4 id="Node3D-节点"><a href="#Node3D-节点" class="headerlink" title="Node3D 节点"></a>Node3D 节点</h4><p>使用专业的 3D 工具（通常称为数字内容创建工具 DCC）来创建3D资源<br>然后导出到某种交换文件格式，才能被 Godot 导入。</p>
<ol>
<li>手动制作的模型（使用 3D 建模软件）<br>可以导入外部工具创建的3D模型。<br>具体取决于格式导入整个场景，包括其中的动画、骨骼绑定、混合形状，也可以简单地作为资源使用。</li>
<li>生成的几何体（静态）<ul>
<li>可以直接使用 ArrayMesh 资源创建自定义几何体。<br> 只需创建数组并使用 ArrayMesh.add_surface_from_arrays() 函数即可。</li>
<li>也可以使用辅助类 SurfaceTool，它提供了更直接的 API 和辅助工具，用于索引、生成法线、切线等。<br>用于生成静态几何体，因为创建顶点数组并将它们提交给3D API具有显著的性能开销。</li>
</ul>
</li>
<li>即时几何体（经常更新）<br>提供了一种特殊的 ImmediateMesh 资源，它可以在 MeshInstance3D 节点中使用。<br>这提供了 OpenGL 1.x 风格的即时模式 API 来创建点、线、三角形等。</li>
<li>3D 中的 2D<br>通过使用不旋转的固定相机(正交或透视)<br>可以使用诸如 Sprite3D 和 AnimatedSprite3D 等节点来创建混合了具有3D背景，更逼真的视差，灯光&#x2F;阴影效果等的2D游戏。<br>缺点在于与2D相比增加了复杂性并降低了性能，以及缺乏进行像素工作时的参考。</li>
<li>环境<br>Godot提供了一个 WorldEnvironment 节点，该节点允许更改背景颜色。<br>模式(就像放一个天空盒时那样)以及应用多种内置处理后效果。 环境可以在Camera中被覆写。</li>
<li>预览环境和灯光<br>默认情况下，如果 3D 场景中没有 WorldEnvironment 或者 DirectionalLight3D 节点，就会打开对应预览项为场景布光。<br>图标右侧画着三个点的下拉菜单中可以调整预览灯光和预览环境的属性。<br>同一个项目中，不同场景使用相同的预览太阳和预览环境。因此，在这里作出的调整应该适合所有需要预览灯光和预览环境的场景。</li>
<li>相机<br>相机可以在正交或透视投影中工作。<br>摄像机与父视口或其祖先视口相关联，且仅显示到他们上面。<br>由于场景树的根是一个视口，默认情况下会在其上显示摄像机，但如果需要子视口(作为渲染目标或画中画)，则需要自己的子摄像头才能显示。<br>处理多台摄像机时，每个视口都遵循以下规则:</li>
</ol>
<ul>
<li>如果场景树中没有摄像机，则第一个进入的摄像机将成为活跃摄像机。进入场景的其他摄像机将被忽略（除非它们被设置为 current）。</li>
<li>如果相机设置了“current”属性，则无论场景中是否有其他相机，都会使用它。如果该属性已设置，它将变为活动状态，取代之前的摄像机。</li>
<li>如果活动摄像机离开了场景树，则按树形顺序排列的第一台摄像机将取代它。</li>
</ul>
<h3 id="使用-3D-变换"><a href="#使用-3D-变换" class="headerlink" title="使用 3D 变换"></a>使用 3D 变换</h3><h4 id="对欧拉角说不"><a href="#对欧拉角说不" class="headerlink" title="对欧拉角说不"></a>对欧拉角说不</h4><ol>
<li>旋转顺序<br>第一人称控制器(例如FPS游戏)。<br>实现希望的效果，必须先在 Y 轴上应用旋转，然后在 X 轴上旋转。<br>如果先在 X 轴上应用旋转，然后再在 Y 轴上应用旋转，则效果会不理想。<br>在X,Y和Z中应用旋转是不够的: 你还需要<strong>旋转顺序</strong>。</li>
<li>插值<br>设想你想在两个不同的相机或敌人位置(包括旋转)之间转换。<br>解决这个问题的一个合乎逻辑的方法是从一个位置插值到下一个位置。<br>相机实际上旋转去了相反的方向！<br>这可能有几个原因:</li>
</ol>
<ul>
<li>旋转不会线性映射到方向，因此它们插值并不总是会形成最短路径(即从 270 到 0 的度数与从 270 开始到 360 的度数不同，即使角度是相同的)。</li>
<li><strong>万向节锁死</strong>正在发挥作用(第一个和最后一个旋转的轴对齐，因此失去了一个自由度)<br><img src="https://wzcwzc10.github.io/posts_img/godot/05/transforms_gimbal.gif" alt="万向节"><br>所有这些的结论是，不应该在游戏中使用 Node3D 节点的 rotation 属性。<br>它主要用在编辑器中，为了与2D引擎一致，并且用于简单的旋转（通常只有一个轴，或者，在有限的情况下，两个）。<br>尽管你可能会受到诱惑，但不要使用它。<br>相反，有一个更好的方法来解决你的旋转问题。（变换）</li>
</ul>
<h4 id="变换的介绍"><a href="#变换的介绍" class="headerlink" title="变换的介绍"></a>变换的介绍</h4><p>方向使用 <code>Transform3D</code> 数据类型。<br>每个 Node3D 节点都包含一个与父级变换相关的 transform 属性（如果父级是 Node3D 派生类型）。<br>也可以通过 <code>global_transform</code> 属性访问世界坐标变换。<br>变换拥有一个基 Basis（transform.basis 子属性）由三个 Vector3 向量组成。<br>这些向量可以通过 <code>transform.basis</code> 属性访问，也可以使用 transform.basis.x、transform.basis.y、transform.basis.z 直接访问。<br>每个向量指向它的轴被旋转的方向，因此它们可以有效地描述节点的总旋转。<br>比例（只要它三个轴长度是一致的）也可以从轴的长度推断出来。一个基也可以被解释为一个 3x3 矩阵并像 transform.basis[x][y] 这样使用。<br>默认的基（未经修改）类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var basis = Basis()</span><br><span class="line"># 包含以下默认值：</span><br><span class="line">basis.x = Vector3(1, 0, 0) # 指向X轴方向的向量</span><br><span class="line">basis.y = Vector3(0, 1, 0) # 指向y轴方向的向量</span><br><span class="line">basis.z = Vector3(0, 0, 1) # 指向z轴方向的向量</span><br></pre></td></tr></table></figure>
<p>这类似于一个 3x3 单位矩阵。<br>变换除了基以外还有一个原点。这是一个 Vector3，用于指定该变换距离实际原点 (0, 0, 0) 有多远。<br>变换是基与原点的组合，可以有效地表示空间中特定的平移、旋转和缩放。<br>可视化变换的一种方法是在“本地空间”模式下查看该对象的 3D 小工具。</p>
<h4 id="操作变换"><a href="#操作变换" class="headerlink" title="操作变换"></a>操作变换</h4><p>当然，变换并不像角度那样容易控制，并且有它自己的问题。<br>可以对变换进行旋转，方法是将基与另一个基相乘（称作累加），或者使用其旋转方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var axis = Vector3(1, 0, 0) # Or Vector3.RIGHT</span><br><span class="line">var rotation_amount = 0.1</span><br><span class="line"># 将变换绕X轴旋转0.1弧度。</span><br><span class="line">transform.basis = Basis(axis, rotation_amount) * transform.basis</span><br><span class="line"># 缩短的</span><br><span class="line">transform.basis = transform.basis.rotated(axis, rotation_amount)</span><br></pre></td></tr></table></figure>
<p>简化方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将变换绕X轴旋转0.1弧度。</span><br><span class="line">rotate(Vector3(1, 0, 0), 0.1)</span><br><span class="line"># 缩短的</span><br><span class="line">rotate_x(0.1)</span><br></pre></td></tr></table></figure>
<p>这会相对于父节点来旋转节点。要相对于对象空间旋转(节点自己的变换)，请使用下面的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将变换绕X轴旋转0.1弧度。</span><br><span class="line">rotate_object_local(Vector3(1, 0, 0), 0.1)</span><br></pre></td></tr></table></figure>
<p>轴应该定义在物体的局部坐标系中。<br>例如，要围绕物体的局部 X、Y 或 Z 轴旋转，可以使用 Vector3.RIGHT 表示 X 轴， Vector3.UP 表示 Y 轴， Vector3.FORWARD 表示 Z 轴。</p>
<h4 id="度误差"><a href="#度误差" class="headerlink" title="度误差"></a>度误差</h4><p>对变换执行连续的操作将导致由于浮点错误导致的精度损失.<br>这意味着每个轴的比例可能不再精确地为 1.0 ，并且它们可能不完全相互为 90 度.<br>如果一个变换每帧旋转一次，最终会随着时间的推移开始变形。 不可避免。<br>有两种不同的方法来处理这个问题。 </p>
<ol>
<li>首先是在一段时间后对变换进行**正交归一化(orthonormalize)**处理(如果每帧修改一次，则可能每帧一次):<br><code>transform = transform.orthonormalized()</code><br>这将使所有的轴再次拥有有 1.0 的长度并且彼此成 90 度角. 但是，应用于变换的任何缩放都将丢失.<br>建议不要缩放将要操作的节点；而是缩放其子节点（例如 MeshInstance3D）。如果你绝对必须要缩放节点，请在最后重新应用它：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform = transform.orthonormalized()</span><br><span class="line">transform = transform.scaled(scale)</span><br></pre></td></tr></table></figure>

<h4 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h4><p>怎么从变换中获得角度？没有必要。你必须尽最大努力停止用角度思考。<br>游戏角色面对的方向射击子弹,只需使用向前的轴(通常为 Z 或 -Z )。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bullet.transform = transform</span><br><span class="line">bullet.speed = transform.basis.z * BULLET_SPEED</span><br></pre></td></tr></table></figure>
<p>敌人在看着游戏角色吗？ 为此判断你可以使用点积</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 获取从玩家指向敌人的方向向量</span><br><span class="line">var direction = enemy.transform.origin - player.transform.origin</span><br><span class="line">if direction.dot(enemy.transform.basis.z) &gt; 0:</span><br><span class="line">	enemy.im_watching_you(player)</span><br><span class="line"></span><br><span class="line"># 向左平移:</span><br><span class="line"># 记住，+X方向是右方。</span><br><span class="line">if Input.is_action_pressed(&quot;strafe_left&quot;):</span><br><span class="line">	translate_object_local(-transform.basis.x)</span><br><span class="line"></span><br><span class="line"># 跳跃:</span><br><span class="line"># 记住，Y轴是向上的轴</span><br><span class="line">if Input.is_action_just_pressed(&quot;jump&quot;):</span><br><span class="line">	velocity.y = JUMP_SPEED</span><br><span class="line"></span><br><span class="line">move_and_slide()</span><br></pre></td></tr></table></figure>
<p>所有常见的行为和逻辑都可以用向量来完成。</p>
<h4 id="设置信息"><a href="#设置信息" class="headerlink" title="设置信息"></a>设置信息</h4><p>当然，有些情况下你想要将一些信息赋予到变换上。<br>想象一下第一人称控制器或环绕旋转的摄像机。<br>那些肯定是用角度来完成的，因为你确实希望变换以特定的顺序进行。<br>对于这种情况，请保证角度和旋转在变换外部 ，并在每帧设置他们。<br>不要尝试获取并重新使用它们，因为变换是不应该以这种方式使用的。<br>环顾四周,FPS风格的示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># accumulators</span><br><span class="line">var rot_x = 0</span><br><span class="line">var rot_y = 0</span><br><span class="line"></span><br><span class="line">func _input(event):</span><br><span class="line">	if event is InputEventMouseMotion and event.button_mask &amp; 1:</span><br><span class="line">		# modify accumulated mouse rotation</span><br><span class="line">		rot_x += event.relative.x * LOOKAROUND_SPEED</span><br><span class="line">		rot_y += event.relative.y * LOOKAROUND_SPEED</span><br><span class="line">		transform.basis = Basis() # reset rotation</span><br><span class="line">		rotate_object_local(Vector3(0, 1, 0), rot_x) # first rotate in Y</span><br><span class="line">		rotate_object_local(Vector3(1, 0, 0), rot_y) # then rotate in X</span><br></pre></td></tr></table></figure>
<p>如你所见，在这种情况下，保持外部旋转更为简单，然后使用变换作为最后的方向。</p>
<h4 id="用四元数插值"><a href="#用四元数插值" class="headerlink" title="用四元数插值"></a>用四元数插值</h4><p>四元数能有效率地完成两个变换之间的插值。<br>在实际应用中，了解它们的主要用途是做最短路插值就足够了。<br>同样，如果你有两个旋转，四元数将平滑地使用最近的轴在它们之间进行插值。<br>将旋转转换为四元数很简单:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 将基（Basis）转换为四元数，需注意缩放（Scale）信息会丢失。</span><br><span class="line">var a = Quaternion(transform.basis)</span><br><span class="line">var b = Quaternion(transform2.basis)</span><br><span class="line"># 使用球面线性插值（SLERP）进行插值。</span><br><span class="line">var c = a.slerp(b,0.5) # 找到ab之间的中点。</span><br><span class="line"># 应用并返回</span><br><span class="line">transform.basis = Basis(c)</span><br></pre></td></tr></table></figure>
<p>Quaternion 类型参考包含有关数据类型的更多信息（它还可以进行变换累积、变换点等，尽管使用较少）。<br>如果你多次对四元数进行插值或应用运算，请记住它们最终需要归一化。否则，会带来数值精度误差。<br>四元数在处理相机&#x2F;路径&#x2F;等东西的移动轨迹时很有用。 插值的结果总会是正确且平滑的。</p>
<h3 id="程序式几何体"><a href="#程序式几何体" class="headerlink" title="程序式几何体"></a>程序式几何体</h3><h4 id="网格（Mesh）"><a href="#网格（Mesh）" class="headerlink" title="网格（Mesh）"></a>网格（Mesh）</h4><p>由一个或多个表面（Surface）组成。<br>表面是由多个子数组组成的数组，包含顶点、法线、UV 等。<br>在 Godot 中，几何体用 Mesh（网格）来表示。<br>Godot 中很多东西的名称里都含有“Mesh”：</p>
<ol>
<li>MeshInstance3D 节点绘制 Mesh 和 ArrayMesh 资源。代表的是某个网格在场景中的实例。<br> 可以在多个 MeshInstance3D 中重复使用同一个网格，用不同的材质或变换（缩放、旋转、位置等）在场景的不同部分绘制它。</li>
<li>MultiMesh 与 MultiMeshInstance3D 结合使用多次绘制同一个对象。<br>MultiMeshInstance3D 可以以非常低的性能成本绘制数千次网格，利用的是硬件实例化的优势。<br>使用 MultiMeshInstance3D 的缺点是所有网格的表面都只能使用同一种材质。<br>它使用一个实例数组为每个实例存储不同的颜色和变换，但所有实例的表面使用的都是相同的材质。</li>
</ol>
<h4 id="表面"><a href="#表面" class="headerlink" title="表面"></a>表面</h4><p>每个表面都有自己的材质。<br>使用 MeshInstance3D 时，你也可以使用 material_override 属性来覆盖 Mesh 中所有表面的材质。</p>
<h4 id="表面数组"><a href="#表面数组" class="headerlink" title="表面数组"></a>表面数组</h4><p>长度为 ArrayMesh.ARRAY_MAX 的数组。<br>数组中的每个位置都填充了一个包含每个顶点信息的子数组。<br>例如，位于 ArrayMesh.ARRAY_NORMAL 处的数组是一个顶点法线的 PackedVector3Array。有关更多信息，请参阅 Mesh.ArrayType。<br>表面数组可以是有索引的，也可以是非索引的。<br>创建非索引数组就像在索引 ArrayMesh.ARRAY_INDEX 处不分配数组一样简单。<br>非索引数组为每个三角形存储唯一的顶点信息，也就是说，当两个三角形共用一个顶点时，顶点在数组中是重复的。<br>有索引的曲面数组只存储每个唯一顶点的顶点信息，然后还存储一个索引数组，它映射出如何从顶点数组构造三角形。<br>一般来说，使用索引数组的速度更快，但这意味着你必须在三角形之间共享顶点数据，这并不总是需要的（例如，当你想要每面法线时）。</p>
<h4 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h4><p>Godot 提供了不同的访问和处理几何体的方法.</p>
<ol>
<li>ArrayMesh (阵列网格体)<br> 扩展了 Mesh，增加了一些不同的便捷函数，最重要的是，可以通过脚本构建 Mesh 表面。</li>
<li>MeshDataTool (网格数据工具)<br> 将Mesh数据转换为顶点，面和边的数组的资源，可以在运行时进行修改.</li>
<li>SurfaceTool (表面工具)<br> 允许使用OpenGL 1.x即时模式风格的接口创建网格.</li>
<li>ImmediateMesh (即时网格体)<br> 使用立即模式风格的接口绘制对象的网格（像 SurfaceTool 一样）。<br> ImmediateMesh 和 SurfaceTool 的区别在于，ImmediateMesh 是直接用代码动态绘制的，而 SurfaceTool 则是用来生成一个 Mesh，你可以用它做任何你想做的事。<br> ImmediateMesh 因为其直接的 API 而对原型设计很有用，但它的速度很慢，因为每次进行修改时都要重建几何体。<br> 最有用的是快速添加简单的几何体来进行可视化调试（例如，通过绘制线条来可视化物理光线投射等）。</li>
</ol>
<h4 id="使用-ArrayMesh"><a href="#使用-ArrayMesh" class="headerlink" title="使用 ArrayMesh"></a>使用 ArrayMesh</h4><p>使用函数 add_surface_from_arrays() 最多需要五个参数，前两个必须，后三个可选：</p>
<ol>
<li>第一个参数是 PrimitiveType（图元类型）OpenGL 中的概念<br>用于指示 GPU 如何根据给定的顶点来排列图元，即它们是否代表三角形、线条、点等。有关可用选项，请参阅 Mesh.PrimitiveType。</li>
<li>第二个参数 arrays 是存储网格信息的实际 Array<br>该数组是一个普通的 Godot 数组，用空括号 [] 构造。它为每一种类型的信息存储一个 Packed**Array（如 PackedVector3Array、PackedInt32Array等），用于构建表面。<br>arrays 的常见元素列出如下，还有必须在 arrays 中包含位置信息。有关完整列表，另请参阅 Mesh.ArrayType。<table>
<thead>
<tr>
<th align="left">索引</th>
<th align="left">Mesh.ArrayType 枚举</th>
<th align="left">数组类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left"><code>ARRAY_VERTEX</code></td>
<td align="left">PackedVector3Array 或 PackedVector2Array</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left"><code>ARRAY_NORMAL</code></td>
<td align="left">PackedVector3Array</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>ARRAY_TANGENT</code></td>
<td align="left">PackedFloat32Array 或 PackedFloat64Array 4 个浮点数组。前 3 个浮点数确定切线，最后一个浮点数确定副法线方向，即 -1 或 1。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><code>ARRAY_COLOR</code></td>
<td align="left">PackedColorArray</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>ARRAY_TEX_UV</code></td>
<td align="left">PackedVector2Array 或 PackedVector3Array</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>ARRAY_TEX_UV2</code></td>
<td align="left">PackedVector2Array 或 PackedVector3Array</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><code>ARRAY_BONES</code></td>
<td align="left">4 个 float 一组的 PackedFloat32Array 或 4 个 int 一组的 PackedInt32Array。每一组都列出了影响给定顶点的 4 根骨骼的索引。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><code>ARRAY_WEIGHTS</code></td>
<td align="left">4 个 float 一组的 PackedFloat32Array 或 PackedFloat64Array。每个 float 都列出了给定顶点对 ARRAY_BONES 中特定骨骼的权重。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><code>ARRAY_INDEX</code></td>
<td align="left">PackedInt32Array</td>
</tr>
</tbody></table>
</li>
</ol>
<p>在创建网格的大部分情况中，我们通过顶点位置来定义网格。<br>因此（位于索引 0 处的）顶点数组通常是必需的。<br>而（位于索引 12 处的）索引数组是可选的，只有在它被包含时才会使用。<br>也可以只用索引数组而不用顶点数组来创建网格，但这不在本教程的内容范围之中。<br>其他所有数组包含的都是关于顶点的信息。<br>它们也是可选的，只有在包含时才会用到。<br>有些数组（例如 ARRAY_COLOR&#96;）用每个顶点一个元素的形式来提供额外的顶点信息。<br>它们的大小必须与顶点数组一致。<br>另一些数组（例如 ARRAY_TANGENT）用四个元素来描述一个顶点。它们必须正好是顶点数组的四倍。<br>正常的使用场景下，add_surface_from_arrays() 的最后三个参数通常都是留空的。</p>
<p>设置 ArrayMesh<br>创建一个 MeshInstance3D ，并在检查器中为其添加一个 ArrayMesh。<br>通常，在编辑器里添加 ArrayMesh 没什么用，但这里可以让我们免去用代码创建的麻烦，直接使用这个 ArrayMesh。<br>接下来，在 MeshInstance3D 上添加一个脚本。<br>在 _ready() 下创建一个新的数组。<code>var surface_array = []</code><br>这将是保存表面信息的数组——将保存表面需要的所有数据数组。Godot 希望它的大小是 Mesh.ARRAY_MAX，所以要相应地调整。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var surface_array = []</span><br><span class="line">surface_array.resize(Mesh.ARRAY_MAX)</span><br></pre></td></tr></table></figure>
<p>接下来，为你将使用的每种数据类型创建数组.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var verts = PackedVector3Array()</span><br><span class="line">var uvs = PackedVector2Array()</span><br><span class="line">var normals = PackedVector3Array()</span><br><span class="line">var indices = PackedInt32Array()</span><br></pre></td></tr></table></figure>
<p>一旦你用几何体填充了你的数据数组，就可以通过将每个数组添加到 surface_array ，然后提交到网格中来创建网格.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">surface_array[Mesh.ARRAY_VERTEX] = verts</span><br><span class="line">surface_array[Mesh.ARRAY_TEX_UV] = uvs</span><br><span class="line">surface_array[Mesh.ARRAY_NORMAL] = normals</span><br><span class="line">surface_array[Mesh.ARRAY_INDEX] = indices</span><br><span class="line"></span><br><span class="line"># No blendshapes, lods, or compression used.</span><br><span class="line">mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个例子中，使用了 Mesh.PRIMITIVE_TRIANGLES，但你也可以使用网格所提供的任何图元类型。<br>把这些放到一起，完整的代码是这样的：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">extends MeshInstance3D</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	var surface_array = []</span><br><span class="line">	surface_array.resize(Mesh.ARRAY_MAX)</span><br><span class="line"></span><br><span class="line">	# PackedVector**Arrays for mesh construction.</span><br><span class="line">	var verts = PackedVector3Array()</span><br><span class="line">	var uvs = PackedVector2Array()</span><br><span class="line">	var normals = PackedVector3Array()</span><br><span class="line">	var indices = PackedInt32Array()</span><br><span class="line"></span><br><span class="line">	#######################################</span><br><span class="line">	## Insert code here to generate mesh ##</span><br><span class="line">	#######################################</span><br><span class="line"></span><br><span class="line">	# Assign arrays to surface array.</span><br><span class="line">	surface_array[Mesh.ARRAY_VERTEX] = verts</span><br><span class="line">	surface_array[Mesh.ARRAY_TEX_UV] = uvs</span><br><span class="line">	surface_array[Mesh.ARRAY_NORMAL] = normals</span><br><span class="line">	surface_array[Mesh.ARRAY_INDEX] = indices</span><br><span class="line"></span><br><span class="line">	# Create mesh surface from mesh array.</span><br><span class="line">	# No blendshapes, lods, or compression used.</span><br><span class="line">	mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)</span><br></pre></td></tr></table></figure>
<p>中间可以放你想要的任何代码。下面我们会给出一些示例代码，用于生成球体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">extends MeshInstance3D</span><br><span class="line"></span><br><span class="line">var rings = 50</span><br><span class="line">var radial_segments = 50</span><br><span class="line">var radius = 1</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">    # 在此处插入设置 PackedVector**Arrays 的代码。</span><br><span class="line"></span><br><span class="line">    # 存储顶点坐标的数组（需提前定义，例如：var verts = PackedVector3Array()）</span><br><span class="line">    # 存储法线向量的数组（需提前定义，例如：var normals = PackedVector3Array()）</span><br><span class="line">    # 存储 UV 坐标的数组（需提前定义，例如：var uvs = PackedVector2Array()）</span><br><span class="line">    # 存储三角形索引的数组（需提前定义，例如：var indices = PackedInt32Array()）</span><br><span class="line"></span><br><span class="line">    var thisrow = 0  # 当前行第一个顶点的索引</span><br><span class="line">    var prevrow = 0  # 上一行第一个顶点的索引</span><br><span class="line">    var point = 0    # 当前已生成的顶点总数</span><br><span class="line"></span><br><span class="line">    # 遍历所有环（从球体顶部到底部）</span><br><span class="line">    for i in range(rings + 1):</span><br><span class="line">        var v = float(i) / rings</span><br><span class="line">        var w = sin(PI * v)  # 水平缩放因子（在顶部和底部为0，赤道处为1）</span><br><span class="line">        var y = cos(PI * v)  # Y轴坐标（从1到-1）</span><br><span class="line"></span><br><span class="line">        # 遍历当前环上的所有径向段</span><br><span class="line">        for j in range(radial_segments + 1):</span><br><span class="line">            var u = float(j) / radial_segments  # 水平纹理坐标</span><br><span class="line">            var x = sin(u * PI * 2.0)           # X轴分量</span><br><span class="line">            var z = cos(u * PI * 2.0)           # Z轴分量</span><br><span class="line">            var vert = Vector3(x * radius * w, y * radius, z * radius * w)  # 计算顶点位置</span><br><span class="line"></span><br><span class="line">            # 将顶点、法线和UV添加到对应数组</span><br><span class="line">            verts.append(vert)</span><br><span class="line">            normals.append(vert.normalized())  # 法线为顶点方向的单位向量</span><br><span class="line">            uvs.append(Vector2(u, v))          # UV坐标：u为经度，v为纬度</span><br><span class="line">            point += 1</span><br><span class="line"></span><br><span class="line">            # 使用索引创建环之间的三角形面片</span><br><span class="line">            if i &gt; 0 and j &gt; 0:</span><br><span class="line">                # 第一个三角形</span><br><span class="line">                indices.append(prevrow + j - 1)</span><br><span class="line">                indices.append(prevrow + j)</span><br><span class="line">                indices.append(thisrow + j - 1)</span><br><span class="line"></span><br><span class="line">                # 第二个三角形</span><br><span class="line">                indices.append(prevrow + j)</span><br><span class="line">                indices.append(thisrow + j)</span><br><span class="line">                indices.append(thisrow + j - 1)</span><br><span class="line"></span><br><span class="line">        # 更新行索引：当前行变为下一行的上一行</span><br><span class="line">        prevrow = thisrow</span><br><span class="line">        thisrow = point</span><br><span class="line"></span><br><span class="line">    # 在此处插入将数组提交到 ArrayMesh 的代码，例如：</span><br><span class="line">    # var array = []</span><br><span class="line">    # array.resize(Mesh.ARRAY_MAX)</span><br><span class="line">    # array[Mesh.ARRAY_VERTEX] = verts</span><br><span class="line">    # array[Mesh.ARRAY_NORMAL] = normals</span><br><span class="line">    # array[Mesh.ARRAY_TEX_UV] = uvs</span><br><span class="line">    # array[Mesh.ARRAY_INDEX] = indices</span><br><span class="line">    #</span><br><span class="line">    # var array_mesh = ArrayMesh.new()</span><br><span class="line">    # array_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, array)</span><br><span class="line">    # set_mesh(array_mesh)</span><br></pre></td></tr></table></figure>
<p>保存<br>最后，我们可以使用 ResourceSaver 类来保存该 ArrayMesh。当你想生成一个网格，然后在以后使用它而不需要重新生成时，这个方法很有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 保存网格到 .tres 文件，并启用压缩。</span><br><span class="line">ResourceSaver.save(mesh, &quot;res://sphere.tres&quot;, ResourceSaver.FLAG_COMPRESS)</span><br></pre></td></tr></table></figure>

<h4 id="使用-MeshDataTool"><a href="#使用-MeshDataTool" class="headerlink" title="使用 MeshDataTool"></a>使用 MeshDataTool</h4><p>MeshDataTool 不是用来生成几何体的，但它对动态改变几何体很有帮助，例如，如果你想写一个脚本来分割，简化或变形网格.<br>MeshDataTool不像直接使用ArrayMesh改变数组那么快.<br>但是，它提供了比ArrayMesh更多的信息和工具来处理网格.<br>当使用MeshDataTool时，它会计算ArrayMeshes中没有的网格数据，如面和边，这些数据对于某些网格算法来说是必要的.<br>如果你不需要这些额外的信息，那么使用 ArrayMesh 可能会更好.</p>
<blockquote>
<p>MeshDataTool 只能用于使用 Mesh.PRIMITIVE_TRIANGLES PrimitiveType 的网格。<br>我们通过调用 <code>create_from_surface()</code> 来使用 ArrayMesh 初始化 MeshDataTool。<br>如果该 MeshDataTool 中已经有初始化的数据了，调用 create_from_surface() 会为你将其清除。或者你可以在重用 MeshDataTool 之前自己调用 <code>clear()</code>。<br>下面的例子中，假定已经创建了一个名叫 mesh 的 ArrayMesh。网格生成的示例见 ArrayMesh 教程。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mdt = MeshDataTool.new()</span><br><span class="line">mdt.create_from_surface(mesh, 0)</span><br></pre></td></tr></table></figure>
<p><code>create_from_surface()</code> 使用 ArrayMesh 中的顶点数组来计算另外两个数组，一个是边、一个是面，总计三个数组。<br>边缘是任意两个顶点之间的连接. 边缘数组中的每一条边缘都包含了对它所组成的两个顶点的引用，以及它所包含的最多的两个面.<br>面是由三个顶点和三条对应的边组成的三角形. 面数组中的每个面都包含了它所组成的三个三角形和三条边的参考.<br>顶点数组包含与每个顶点相连的边、面、法线、颜色、切线、uv、uv2、骨骼和权重信息。<br>为了从这些数组中获取信息，你可以使用 <code>get_ **** ()</code> 的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mdt.get_vertex_count() # 返回顶点数组中的顶点数量</span><br><span class="line">mdt.get_vertex_faces(0) # 返回包含顶点[0]的所有面组成的数组</span><br><span class="line">mdt.get_face_normal(1) # 计算并返回第二个面的法线向量</span><br><span class="line">mdt.get_edge_vertex(10, 1) # 返回索引为10的边的第二个顶点</span><br></pre></td></tr></table></figure>
<p>你选择用这些函数做什么取决于你。一个常见的用例是对所有顶点进行迭代，并以某种方式对它们进行转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(get_vertex_count):</span><br><span class="line">	var vert = mdt.get_vertex(i)</span><br><span class="line">	vert *= 2.0 # Scales the vertex by doubling size.</span><br><span class="line">	mdt.set_vertex(i, vert)</span><br></pre></td></tr></table></figure>
<p>这些修改不是在 ArrayMesh 上直接进行的。如果你要动态更新现有的 ArrayMesh，请在添加新表面前使用 <code>commit_to_surface()</code> 来删除已有表面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mesh.clear_surfaces() # 删除所有的网格表面.</span><br><span class="line">mdt.commit_to_surface(mesh)</span><br></pre></td></tr></table></figure>
<p>下面是一个完整的示例，将一个叫做 mesh 的球体网格变成随机变形的块状，并更新了法线和顶点颜色。如何生成基础网格见 ArrayMesh 教程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">extends MeshInstance3D</span><br><span class="line"></span><br><span class="line">var fnl = FastNoiseLite.new()</span><br><span class="line">var mdt = MeshDataTool.new()</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">    fnl.frequency = 0.7</span><br><span class="line"></span><br><span class="line">    # 从当前网格的第0个表面创建 MeshDataTool 数据</span><br><span class="line">    mdt.create_from_surface(mesh, 0)</span><br><span class="line"></span><br><span class="line">    # 遍历所有顶点，使用噪声扰动顶点位置</span><br><span class="line">    for i in range(mdt.get_vertex_count()):</span><br><span class="line">        var vertex = mdt.get_vertex(i).normalized()  # 将顶点归一化到单位球面</span><br><span class="line">        # 根据3D噪声值向外推拉顶点（噪声值范围映射到 0.25~1.25 倍半径）</span><br><span class="line">        vertex = vertex * (fnl.get_noise_3dv(vertex) * 0.5 + 0.75)</span><br><span class="line">        mdt.set_vertex(i, vertex)  # 更新顶点位置</span><br><span class="line"></span><br><span class="line">    # 按面计算并累加顶点法线（逐面处理）</span><br><span class="line">    for i in range(mdt.get_face_count()):</span><br><span class="line">        # 获取第 i 个面的三个顶点在顶点数组中的索引</span><br><span class="line">        var a = mdt.get_face_vertex(i, 0)</span><br><span class="line">        var b = mdt.get_face_vertex(i, 1)</span><br><span class="line">        var c = mdt.get_face_vertex(i, 2)</span><br><span class="line">        # 根据索引获取三个顶点的实际坐标</span><br><span class="line">        var ap = mdt.get_vertex(a)</span><br><span class="line">        var bp = mdt.get_vertex(b)</span><br><span class="line">        var cp = mdt.get_vertex(c)</span><br><span class="line">        # 计算该三角面的法线（通过叉积）</span><br><span class="line">        var n = (bp - cp).cross(ap - bp).normalized()</span><br><span class="line">        # 将该面的法线累加到对应顶点的当前法线上</span><br><span class="line">        # 此方法不会得到完全精确的法线，但结果足够接近</span><br><span class="line">        mdt.set_vertex_normal(a, n + mdt.get_vertex_normal(a))</span><br><span class="line">        mdt.set_vertex_normal(b, n + mdt.get_vertex_normal(b))</span><br><span class="line">        mdt.set_vertex_normal(c, n + mdt.get_vertex_normal(c))</span><br><span class="line"></span><br><span class="line">    # 最后遍历所有顶点，归一化法线，并将法线向量映射为顶点颜色</span><br><span class="line">    for i in range(mdt.get_vertex_count()):</span><br><span class="line">        var v = mdt.get_vertex_normal(i).normalized()  # 归一化最终法线</span><br><span class="line">        mdt.set_vertex_normal(i, v)</span><br><span class="line">        # 将法线的 X、Y、Z 分量映射为红、绿、蓝颜色值（范围 0~1）</span><br><span class="line">        mdt.set_vertex_color(i, Color(v.x, v.y, v.z))</span><br><span class="line"></span><br><span class="line">    # 清除原始网格表面数据</span><br><span class="line">    mesh.clear_surfaces()</span><br><span class="line">    # 将修改后的数据提交回网格，生成新的渲染表面</span><br><span class="line">    mdt.commit_to_surface(mesh)</span><br></pre></td></tr></table></figure>


<h4 id="使用-SurfaceTool"><a href="#使用-SurfaceTool" class="headerlink" title="使用 SurfaceTool"></a>使用 SurfaceTool</h4><p>SurfaceTool 提供了一个用于构造几何体的有用接口。<br>该接口类似于 ImmediateMesh 类。你设置每个顶点的属性（例如法线、uv、颜色），然后当你添加顶点时，它就会捕获这些属性。<br>SurfaceTool 还提供了一些有用的辅助函数，如 index() 和 generate_normals()。<br>属性是在添加每个顶点之前添加的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st.set_normal() # 被下面的法线设置覆盖，无效。</span><br><span class="line">st.set_normal() # 将被添加到下一个顶点。</span><br><span class="line">st.set_color()  # 将被添加到下一个顶点。</span><br><span class="line">st.add_vertex() # 捕获上方设置的法线和颜色，并应用到该顶点。</span><br><span class="line">st.set_normal() # 此法线未被任何顶点使用（后续无顶点添加）。</span><br></pre></td></tr></table></figure>
<p>当使用 SurfaceTool 完成生成几何体后，调用 commit() 完成生成网格。<br>如果将一个 ArrayMesh 传递给了 commit()，那么它就会在这个 ArrayMesh 的末尾附加一个新的表面。<br>而如果没有传递任何信息，commit() 则返回一个 ArrayMesh。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">st.commit(mesh)</span><br><span class="line"># Or:</span><br><span class="line">var mesh = st.commit()</span><br></pre></td></tr></table></figure>
<p>代码创建一个有索引的三角形</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var st = SurfaceTool.new()</span><br><span class="line"></span><br><span class="line"># 开始绘制，指定图元类型为三角形</span><br><span class="line">st.begin(Mesh.PRIMITIVE_TRIANGLES)</span><br><span class="line"></span><br><span class="line"># 为添加顶点准备属性</span><br><span class="line">st.set_normal(Vector3(0, 0, 1))      # 设置法线方向（朝向 Z 轴正方向）</span><br><span class="line">st.set_uv(Vector2(0, 0))             # 设置纹理坐标 (U=0, V=0)</span><br><span class="line"># 每个顶点最后调用此方法，将上述属性添加为一个顶点</span><br><span class="line">st.add_vertex(Vector3(-1, -1, 0))    # 添加第一个顶点（左下角）</span><br><span class="line"></span><br><span class="line">st.set_normal(Vector3(0, 0, 1))      # 设置法线</span><br><span class="line">st.set_uv(Vector2(0, 1))             # 设置纹理坐标 (U=0, V=1)</span><br><span class="line">st.add_vertex(Vector3(-1, 1, 0))     # 添加第二个顶点（左上角）</span><br><span class="line"></span><br><span class="line">st.set_normal(Vector3(0, 0, 1))      # 设置法线</span><br><span class="line">st.set_uv(Vector2(1, 1))             # 设置纹理坐标 (U=1, V=1)</span><br><span class="line">st.add_vertex(Vector3(1, 1, 0))      # 添加第三个顶点（右上角）</span><br><span class="line"></span><br><span class="line"># 将绘制的数据提交生成网格</span><br><span class="line">var mesh = st.commit()</span><br></pre></td></tr></table></figure>
<p>你可以选择添加一个索引数组，可以通过调用 add_index() 将顶点添加到索引数组中，也可以通过调用 index() 将顶点数组缩小以删除重复的顶点.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 继续之前的代码，先添加第四个顶点</span><br><span class="line">st.set_normal(Vector3(0, 0, 1))      # 设置法线方向（朝向 Z 轴正方向）</span><br><span class="line">st.set_uv(Vector2(1, 0))             # 设置纹理坐标 (U=1, V=0)</span><br><span class="line">st.add_vertex(Vector3(1, -1, 0))     # 添加第四个顶点（右下角）</span><br><span class="line"></span><br><span class="line"># 现在添加索引来定义两个三角形</span><br><span class="line">st.add_index(0)   # 第一个三角形的第一个顶点</span><br><span class="line">st.add_index(1)   # 第一个三角形的第二个顶点</span><br><span class="line">st.add_index(2)   # 第一个三角形的第三个顶点</span><br><span class="line"></span><br><span class="line">st.add_index(1)   # 第二个三角形的第一个顶点</span><br><span class="line">st.add_index(3)   # 第二个三角形的第二个顶点</span><br><span class="line">st.add_index(2)   # 第二个三角形的第三个顶点</span><br><span class="line"></span><br><span class="line"># 提交到网格</span><br><span class="line">var mesh = st.commit()</span><br></pre></td></tr></table></figure>
<p>同样，如果你有一个索引数组，但希望每个顶点都是唯一的(例如，因为想在每个面而不是每个顶点使用唯一的法线或颜色)，可以调用 deindex() .<br><code>st.deindex()</code><br>如果你不想自行添加自定义法线，那么可以使用 generate_normals() 来添加，调用时机应该是在生成几何体之后、使用 commit() 或 commit_to_arrays() 提交网格之前。调用 generate_normals(true) 会将最终的法线翻转。另外请注意，generate_normals() 只有在图元类型为 Mesh.PRIMITIVE_TRIANGLES 时有效。</p>
<p>你可能发现了，在生成的网格上，法线贴图或者其他一些材质属性看上去不对劲。这是因为对法线贴图而言，必需的是切线，这和法线是两码事。有两种解决方法，手动添加切线信息，或者使用 generate_tangents() 自动生成。这个方法要求每个顶点都已经具有 UV 和法线。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st.generate_normals()</span><br><span class="line">st.generate_tangents()</span><br></pre></td></tr></table></figure>
<p>默认情况下，当生成法线时，它们将以每个面为基础进行计算. 如果想要平滑的顶点法线，在添加顶点时，调用 add_smooth_group() . add_smooth_group() 需要在建立几何体时调用，例如在调用 add_vertex() (如果没有索引)或 add_index() (如果有索引)之前.</p>
<h4 id="使用-ImmediateMesh"><a href="#使用-ImmediateMesh" class="headerlink" title="使用 ImmediateMesh"></a>使用 ImmediateMesh</h4><p>ImmediateMesh 是一个使用 OpenGL 1.x 风格的 API 创建动态几何体的便捷工具。<br>这使得它对于需要每帧更新的网格来说，既易于使用又高效。<br>使用这个工具生成复杂的几何体（几千个顶点）效率很低，即使只做一次。相反，它的设计是为了生成每一帧变化的简单几何体。<br>首先，你需要创建一个 MeshInstance3D 并在检查器中向其添加一个 ImmediateMesh。<br>接下来，将脚本添加到 MeshInstance3D 上。如果你希望 ImmediateMesh 每帧都更新，则应该把 ImmediateMesh 的代码放在 _process() 函数中；如果你想创建一次网格体而后不再更新它，则代码应放在 <em>ready() 函数中。如果仅生成一次表面，则 ImmediateMesh 与任何其他类型的网格一样高效，因为生成的网格会被缓存并重用。<br>必须调用 surface_begin() 才能开始生成几何体 。surface_begin() 将一个 PrimitiveType 作为参数。PrimitiveType（图元类型）指示 GPU 如何根据给定的顶点来安排图元，可以是三角形、线、点等。完整的列表可以在 Mesh 的类参考页面中找到。<br>一旦你调用了 surface_begin() ，就可以开始添加顶点了。每次添加一个顶点，首先使用 surface_set</em>****() （例如 surface_set_normal() ）添加顶点的特定属性，如法线或 UV。然后调用 surface_add_vertex() 来添加一个带有这些属性的顶点。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 添加一个带有法线和UV坐标的顶点</span><br><span class="line">surface_set_normal(Vector3(0, 1, 0))      # 设置顶点法线（朝上）</span><br><span class="line">surface_set_uv(Vector2(1, 1))             # 设置顶点纹理坐标</span><br><span class="line">surface_add_vertex(Vector3(0, 0, 1))      # 添加顶点位置，此时将上述属性一并提交</span><br></pre></td></tr></table></figure>
<p>只有在调用 surface_add_vertex() 之前添加的属性才会被包含在该顶点中。如果在调用 surface_add_vertex() 之前添加属性两次，则仅第二次调用才会被使用。<br>最后，当添加了所有的顶点后，调用 surface_end() 来表示已经完成了网格的生成。你可以多次调用 surface_begin() 和 surface_end() 来为网格生成多个表面。<br>下面的示例代码在 _ready() 函数中绘制了一个三角形。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extends MeshInstance3D</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">    # 开始绘制，准备构建网格表面</span><br><span class="line">    mesh.surface_begin(Mesh.PRIMITIVE_TRIANGLES)</span><br><span class="line"></span><br><span class="line">    # 为添加顶点设置属性</span><br><span class="line">    mesh.surface_set_normal(Vector3(0, 0, 1))     # 设置法线方向（沿 Z 轴正方向）</span><br><span class="line">    mesh.surface_set_uv(Vector2(0, 0))            # 设置纹理坐标 (U=0, V=0)</span><br><span class="line">    # 每个顶点最后调用此方法，将上述属性与位置一起添加为一个顶点</span><br><span class="line">    mesh.surface_add_vertex(Vector3(-1, -1, 0))   # 添加第一个顶点（左下角）</span><br><span class="line"></span><br><span class="line">    mesh.surface_set_normal(Vector3(0, 0, 1))     # 设置法线</span><br><span class="line">    mesh.surface_set_uv(Vector2(0, 1))            # 设置纹理坐标 (U=0, V=1)</span><br><span class="line">    mesh.surface_add_vertex(Vector3(-1, 1, 0))    # 添加第二个顶点（左上角）</span><br><span class="line"></span><br><span class="line">    mesh.surface_set_normal(Vector3(0, 0, 1))     # 设置法线</span><br><span class="line">    mesh.surface_set_uv(Vector2(1, 1))            # 设置纹理坐标 (U=1, V=1)</span><br><span class="line">    mesh.surface_add_vertex(Vector3(1, 1, 0))     # 添加第三个顶点（右上角）</span><br><span class="line"></span><br><span class="line">    # 结束绘制，完成表面构建</span><br><span class="line">    mesh.surface_end()</span><br></pre></td></tr></table></figure>
<p>ImmediateMesh 也可以跨帧使用。每次调用 surface_begin() 和 surface_end() 时，你都会向 ImmediateMesh 添加一个新表面。如果你想在每一帧从头开始重新创建网格，请在调用 surface_begin() 之前先调用 clear_surfaces()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extends MeshInstance3D</span><br><span class="line"></span><br><span class="line">func _process(delta):</span><br><span class="line">    # 绘制前清理已有的表面数据</span><br><span class="line">    mesh.clear_surfaces()</span><br><span class="line"></span><br><span class="line">    # 开始绘制，准备构建新的网格表面</span><br><span class="line">    mesh.surface_begin(Mesh.PRIMITIVE_TRIANGLES)</span><br><span class="line"></span><br><span class="line">    # 在此处添加绘制网格的代码（例如：设置顶点属性并添加顶点）</span><br><span class="line">    # 示例：</span><br><span class="line">    # mesh.surface_set_normal(Vector3(0, 0, 1))</span><br><span class="line">    # mesh.surface_set_uv(Vector2(0, 0))</span><br><span class="line">    # mesh.surface_add_vertex(Vector3(-1, -1, 0))</span><br><span class="line">    # ... 添加更多顶点</span><br><span class="line"></span><br><span class="line">    # 结束绘制，完成表面构建</span><br><span class="line">    mesh.surface_end()</span><br></pre></td></tr></table></figure>
<p>上面的代码将在每个帧里动态地创建并绘制一个表面。</p>
<h4 id="应该使用哪一个？"><a href="#应该使用哪一个？" class="headerlink" title="应该使用哪一个？"></a>应该使用哪一个？</h4><p>SurfaceTool和ArrayMesh都是生成静态几何体(网格)的绝佳工具.<br>使用 ArrayMesh 比使用 SurfaceTool 稍快一些，但 API 的难度更大一些。另外，SurfaceTool 还有一些便捷的方法，比如 generate_normals() 和 index()。<br>ImmediateMesh 比 ArrayMesh 和 SurfaceTool 受到更多限制。<br>但是，如果你本来就需要每一帧都改变几何体，它提供的接口更简单，甚至可能比每一帧生成一个 ArrayMesh 更快。<br>MeshDataTool 的速度并不快，但它可以让你访问网格的各种属性，而这些属性是其他工具无法获得的（边、面等）。当你需要根据这类数据来变换网格时，它是非常有用的，但如果不需要这些信息，就不适合使用。如果你要使用需要访问面数组或边数组的算法，最好使用 MeshDataTool。</p>
<h3 id="3D-文本"><a href="#3D-文本" class="headerlink" title="3D 文本"></a>3D 文本</h3><p>有三种使用方法：</p>
<ol>
<li>Label3D 节点<br>优势</li>
</ol>
<ul>
<li>生成速度比 TextMesh 快。</li>
<li>可以使用位图字体和动态字体（带或不带 MSDF 或 mipmap）。<br>限制</li>
<li>默认情况下，Label3D 与 3D 环境的交互有限。着色标志启用时能够接受光照、被光源着色。<br>但是，即使在 Label3D 的 GeometryInstance3D 属性中将阴影投射设置为开启 ，它也不会投射阴影。<br>这是因为该节点内部生成具有透明纹理的四边形网格（每个四边形一个字形），并且具有与 Sprite3D 相同的限制。<br>当多个 Label3D 重叠，尤其是当它们具有轮廓时，透明度排序问题也会变得明显。<br>这可以将 Label3D 的透明度模式设置为 Alpha Cut 来缓解 ，但代价是文字渲染不够流畅。<br>Opaque Pre-Pass 透明度模式可以保持文本的流畅性，同时允许 Label3D 投射阴影，但仍会存在一些透明度排序问题。</li>
<li>从远处看Label3D时，文本渲染质量也会受影响。想提升文本渲染质量可参考这些方法，对字体使用mipmap or 切换成MSDF 字体渲染.</li>
</ul>
<ol start="2">
<li>MeshInstance3D 节点的 TextMesh 资源<br>TextMesh 生成的不是透明四边形，而是代表字形轮廓的 3D 网格，具有和网格一样的属性。<br>因此，TextMesh 默认是开启着色的，会自动在环境中投射阴影。TextMesh 也可以设置材质（包括自定义着色器）。<br>优势<br>相对于 Label3D 而言，TextMesh 有以下优点：</li>
</ol>
<ul>
<li>TextMesh 可以使用纹理来修改文本各个面的颜色。</li>
<li>TextMesh 几何体具有深度，字形看上去是 3D 的。</li>
<li>TextMesh 可以使用自定义的着色器，而 Label3D 无法使用。<br>限制<br>TextMesh 的局限性有：</li>
<li>没有内置的轮廓支持，而 Label3D 支持。但是可以使用自定义着色器模拟。</li>
<li>仅支持动态字体（.ttf、.otf、.woff、.woff2）。不支持 .fnt 和 .font 格式的位图字体。</li>
<li>无法正确渲染轮廓自相交的字体。如果使用从 Google Fonts 等处下载到的字体时出现渲染问题，请尝试改为从作者的官方网站下载。</li>
<li>对文本进行抗锯齿，需要启用全场景抗锯齿，比如：MSAA，FXAA，Temporal Antialiasing（TAA）。如果未启动抗锯齿，文本会产生颗粒状，尤其是远距离观察时颗粒状更为明显。参考 3D 抗锯齿 。</li>
</ul>
<ol start="3">
<li>投影 Label 节点（或者其他 Control 节点）<br>做法是在脚本的 _process() 函数中使用 Camera3D 节点的 unproject_position 的返回值。<br>使用这个返回值来设置 Control 节点的 position 属性。<br>优势</li>
</ol>
<ul>
<li>Label、RichTextLabel 等任何 Control 节点，甚至 Button 这样的节点都可以用这种方法。这样就能够实现强大的格式和 GUI 交互。</li>
<li>基于脚本的做法能够在定位方面做到最大的自由度。例如，这样就能够在超出屏幕范围后将 Control 吸附到屏幕的边缘（用于在游戏中实现 3D 标记）。</li>
<li>Control 主题仍然有效。这样实现自定义项目全局的设置就更方便。<br>限制</li>
<li>投影的 Control 无法以任何形式被 3D 几何体遮挡。目标位置被遮挡时，你可以借助 RayCast 将该控件完全隐藏，但是无法实现位于墙壁后面时只隐藏部分区域的效果。</li>
<li>可以根据距离调整 Control 的 scale 属性，从而调整文本的大小，但是需要手动缩放。Label3D 和 TextMesh 会自动处理，但是灵活性不足（无法设置最小&#x2F;最大的文本像素大小）。</li>
<li>必须在脚本中考虑到分辨率和纵横比的变化，这可能具有挑战性。</li>
</ul>
<h3 id="渲染-1"><a href="#渲染-1" class="headerlink" title="渲染"></a>渲染</h3><h4 id="3D-渲染的局限性"><a href="#3D-渲染的局限性" class="headerlink" title="3D 渲染的局限性"></a>3D 渲染的局限性</h4><p>出于对性能的要求，实时渲染引擎有很多局限性。</p>
<ol>
<li><p>纹理尺寸限制<br>PC上，旧设备可能不支持大于 8192×8192 的纹理。在 GPUinfo.org 上检查目标 GPU 的限制。<br>移动端 GPU 通常限制为 4096×4096 纹理。此外，某些移动端 GPU 不支持非 2 的幂大小的纹理的重复操作。<br>因此，如果想纹理在所有平台上都能正确显示，则应避免使用大于 4096×4096 的纹理，如果纹理需要重复，则大小应为 2 的幂。<br>要限制可能因为尺寸太大而无法渲染的特定纹理的大小，你可以将 Process &gt; Size Limit 导入选项设置为大于 0 的值。<br>这将减少导入时纹理的尺寸（保留纵横比），而不影响源文件。</p>
</li>
<li><p>带状颜色<br>使用 Forward+ 或 Mobile 移动渲染方法时，Godot 的 3D 引擎在内部以 HDR 进行渲染。<br>但是渲染输出会经过色调映射到低动态范围，以便在屏幕上显示。这可能会导致可见的条带效应，尤其是在使用无纹理的材质时。<br>出于性能原因，使用 Mobile 移动渲染方法时颜色精度也比使用 Forward+ 时要低。<br>使用兼容性渲染方法时，不使用 HDR，并且颜色精度是所有渲染方法中最低的。这也适用于 2D 渲染，在 2D 渲染中，使用平滑渐变纹理时可以看到条带。</p>
</li>
</ol>
<ul>
<li>有两个主要的方法来缓解条带:<ol>
<li>如果使用 Forward+ 或 Forward 移动渲染方法，请在 项目设置 &gt; 渲染 &gt; 抗锯齿 中启用 Use Debanding 。 这会应用全屏去色带着色器作为后期处理效果，并且非常经济合算。</li>
<li>将一些噪点烘焙到纹理中。这主要在 2D 中有效，例如用于渐晕（vignetting）效果。在 3D 中，你还可以使用一个自定义去色带着色器应用于你的材质。即使你的项目以低颜色精度渲染，该技术也能发挥作用，这意味着它在使用移动端和兼容性渲染方法时也能发挥作用。</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>深度缓冲精度<br>为了在 3D 空间中排序对象，渲染引擎使用了深度缓冲区（也称为 Z 缓冲区）。<br>这个缓冲区具有有限的精度：在桌面平台上是 24 位，在移动平台上有时是 16 位（出于性能原因）。<br>如果两个不同的对象最终具有相同的缓冲值，那么就会发生 Z 冲突（Z-fighting），此时移动或旋转相机，将观察到纹理来回闪烁。<br>为了使深度缓冲在渲染区域上更精确，你应该增加摄像机节点的 Near 属性。<br>但是要小心，如果你设置得太高，玩家就会看穿附近的几何体。<br>同时，还应该减少摄像机节点的 Far 属性到你用例允许的最低值，尽管它不会像 Near 属性那样影响精度。<br>如果你仅在玩家能够看得远时才需要高精度，则可以根据游戏条件动态更改它。<br>例如，如果玩家进入飞机，则可以暂时增加 Near 属性以避免远处的 Z 冲突（ Z-fighting）。玩家离开飞机，就可以减少它。<br>根据场景和玩家视野条件，你还可以在玩家不会看出差异的情况下将产生z冲突的对象移得更远。</p>
</li>
<li><p>透明度排序<br>在 Godot 中，透明材质是在不透明材质之后绘制的。<br>透明对象在绘制之前会从后向前排序，排序依据是该 Node3D 的位置，而不是世界空间中顶点的位置。<br>因此, 互相有重叠的对象可能会出现排序错误的情况。<br>要修复排序不当的对象，可以调整材质的 渲染优先级 属性，或节点的 排序偏置 属性。<br>渲染优先级将强制特定材质出现在其他透明材质的前面或后面，而排序偏置将向前或向后移动对象以进行排序。即便如此，这可能也并不总是能解决问题。<br>一些渲染引擎会使用顺序无关的透明技术来缓解这个问题，但这类技术对于 GPU 而言开销很大。</p>
</li>
</ol>
<ul>
<li>Godot 目前没有提供这个功能，但仍然有几种方法可以避免这个问题：<ol>
<li>只有在你真正需要的时候才让材质透明。<br>  如果一种材质只有一个很小的透明部分，请考虑将它分割成一个单独的材质。<br>  这将允许不透明部分投射阴影，也可以提高性能。</li>
<li>如果你的纹理大部分都是完全不透明和完全透明的区域，则可以使用 Alpha 测试而不是 Alpha 混合。<br>  这种透明模式渲染速度更快，并且不会出现透明度问题。<br>  在 StandardMaterial3D 中启用 Transparency &gt; Transparency 至 Alpha Scissor ，并根据需要相应调整 Transparency &gt; Alpha Scissor Threshold 。<br>  请注意，除非在材质属性中启用了 alpha 抗锯齿，否则 MSAA 不会对纹理边缘进行抗锯齿。<br>  但是，无论材质上是否启用了 alpha 抗锯齿功能，FXAA、TAA 和超级采样都能够对纹理边缘进行抗锯齿处理。</li>
<li>如果你需要渲染纹理上的半透明区域，Alpha Scissor 就不适用了。<br>  将 StandardMaterial3D 的 Transparency &gt; Transparency 属性设置为 Depth Pre-Pass 有时会有作用（以性能为代价）。<br>  你还可以尝试 Alpha Hash 模式。</li>
<li>如果你想让材质随着距离增加而淡出<br>  使用 StandardMaterial3D 的距离淡出模式（distance fade mode）的 Pixel Dither 或 Object Dither 来代替 PixelAlpha。<br>  这将使材质不透明，还可以加快渲染速度。</li>
</ol>
</li>
</ul>
<h4 id="标准-3D-材质与-ORM-3D-材质"><a href="#标准-3D-材质与-ORM-3D-材质" class="headerlink" title="标准 3D 材质与 ORM 3D 材质"></a>标准 3D 材质与 ORM 3D 材质</h4><p><code>StandardMaterial3D</code> 和 <code>ORMMaterial3D</code> （遮挡、粗糙度、金属）<br>旨在提供大部分功能无需编写着色器代码，但如果需要附加功能也可以转换为着色器代码。<br>添加材质到对象有 4 种方法:</p>
<ol>
<li>可以在网格的 <code>Material</code>（材质）属性中添加。该网格每次被使用时，它都会具有该材质。</li>
<li>可以在使用该网格的节点（比如 MeshInstance3D 节点）的 Material 属性中添加，该材质将仅由该节点使用，它还将覆盖网格的材质属性。</li>
<li>可以使用该网格的节点的 Material Override（材质覆盖）属性中添加，该材质将仅由该节点使用。它还将覆盖节点的常规材质属性和网格的材质属性。</li>
<li>可以是 Material Overlay（材质覆盖层）属性中。会在该网格所使用的当前材质上方再渲染一个材质。例如，可以用来在网格上放置半透明护盾效果。</li>
</ol>
<p>BaseMaterial 3D 设置<br>StandardMaterial3D 有许多设置来决定材质的外观。所有这些设置属性都属于 BaseMaterial3D 类别<br>ORM 材质的设置几乎完全相同，只有一处不同：没有单独的环境光遮蔽、粗糙度和金属度贴图设置，而是使用单个 ORM 纹理。<br>该纹理的不同颜色通道用来对应这三个参数。<br>像 Substance Painter 和 Armor Paint 这样的程序将为你提供以此格式导出的选项，对于这两个程序，它们具有虚幻引擎的导出预设，该引擎也使用 ORM 纹理。</p>
<p>Transparency（透明）<br>默认情况下，Godot 中的材质是不透明的。<br>这样的设置下渲染速度很快，但这也意味着即使在 Albedo &gt; Texture 属性中使用透明纹理（或将 Albedo &gt; Color 设置为透明颜色），材质在视觉上也不是透明的。<br>为了能让视线透过材质，材质需要设置成透明的。<br>Godot 提供了几种透明度模式：</p>
<ol>
<li>Disabled： 材质不透明。这个设置的渲染速度最快，支持所有渲染功能。</li>
<li>Alpha： 材质是透明的。半透明区域是通过混合绘制的。这个设置渲染速度很慢，但它允许半透明。<br> 此外，使用 Alpha 混合的材质无法投射阴影，并且在屏幕空间反射中不可见。<ul>
<li>Alpha 非常适合粒子效果和 VFX。</li>
</ul>
</li>
<li>Alpha Scissor（Alpha 裁剪）： 材质是透明的。<br> 不透明度低于 Alpha Scissor Threshold（Alpha 裁剪阈值）的半透明区域不会被绘制（高于此阈值的区域则绘制为不透明）。<br> 这个设置比 Alpha 渲染速度更快，并且不会出现透明度排序问题。<br> 它的缺点是会导致“要么有或要么无”的透明度情况，不存在中间值。使用 Alpha 裁剪的材质可以投射阴影。<ul>
<li>Alpha Scissor 非常适合树叶和栅栏，因为它们具有硬边，需要正确地区分才能看上去表现不错。</li>
</ul>
</li>
<li>Alpha Hash： （Alpha 哈希）材质是透明的。<br> 使用颜色抖动绘制半透明区域。这种也是“要么有或要么没有”的透明度，但颜色抖动有助于以有限的精度表示部分不透明的区域，具体取决于视口分辨率。<br> 使用 alpha 哈希的材质可以投射阴影。<ul>
<li>Alpha Hash 适合逼真效果的头发，而风格化的头发使用 alpha 裁剪可能效果更好。</li>
</ul>
</li>
<li>Depth Pre-Pass： （深度预通过）首先通过不透明管道渲染对象的完全不透明像素，然后通过 Alpha 混合渲染其余部分。<br> 这可让透明度排序<strong>大部分</strong>正确（尽管不完全如此，因为部分透明区域可能仍然表现出不正确的排序）。使用深度预通道的材质可以投射阴影。</li>
</ol>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
如果满足 任何 这些条件，Godot 将自动强制材质通过 alpha 混合变得透明：<br>
将透明度模式设置为 Alpha （如此处所述）。<br>
设置除默认 Mix 之外的混合模式<br>
启用 Refraction 、 Proximity Fade 或 Distance Fade 。
</p>
Alpha 混合（左）和 Alpha 裁剪（右）之间透明度的比较：
![](https://wzcwzc10.github.io/posts_img/godot/05/spatial_material12.webp)

<p>Alpha 混合透明有一些限制：</p>
<ul>
<li>Alpha 混合材质的渲染速度明显较慢，尤其是当它们重叠时。</li>
<li>当透明表面相互重叠时，Alpha 混合材料可能会出现排序问题。这意味着表面可能会以错误的顺序渲染，后面的表面看起来位于实际上更靠近相机的表面的前面。</li>
<li>Alpha 混合材质虽然可以接收阴影，但不会投射阴影。</li>
<li>Alpha 混合材质不会出现在任何反射中（反射探针除外）。</li>
<li>屏幕空间反射和锐利的 SDFGI 反射不会出现在 Alpha 混合材质上。启用 SDFGI 后，无论材质粗糙度如何，都会使用粗糙反射作为后备。<br>在使用 Alpha 透明度模式之前，请始终先考虑其他透明度模式是否更适合你的需求。</li>
</ul>
<p>Alpha 抗锯齿</p>
<blockquote>
<p>这个属性仅当透明度模式为 Alpha Scissor 或 Alpha Hash 时才可见。<br>虽然 Alpha 裁剪和 Alpha 哈希材质的渲染速度比 Alpha 混合材质更快，但它们会在不透明和透明区域之间渲染出硬边缘。虽然可以使用基于后处理的 抗锯齿技术（例如 FXAA 和 TAA），但这并不总是理想的，因为这些技术往往会使最终结果看起来更模糊或出现重影伪影。<br>有 3 种 Alpha 抗锯齿模式可用：</p>
</blockquote>
<ol>
<li>Disabled： 无 alpha 抗锯齿功能。除非使用基于后处理的抗锯齿解决方案，否则透明材质的边缘将出现锯齿。</li>
<li>Alpha Edge Blend： （Alpha 边缘混合）使不透明和透明区域之间平滑过渡。也称为“alpha to coverage”（alpha 覆盖）。</li>
<li>Alpha Edge Clip： （Alpha 边缘剪辑）在不透明和透明区域之间产生清晰但仍然有抗锯齿的过渡。也称为“alpha to coverage + alpha to one”（alpha 覆盖 + alpha 到 1）。</li>
</ol>
<p>当 Alpha 抗锯齿模式设置为 Alpha Edge Blend 或 Alpha Edge Clip 时，新的 Alpha Antialiasing Edge （alpha 抗锯齿边缘值）属性在检查器下方可见。这个属性用于控制阈值，低于该阈值的像素应变为透明。虽然你已经定义了 Alpha 裁剪阈值（仅当使用 Alpha Scissor 时），但此附加阈值用于在不透明和透明像素之间平滑过渡。 Alpha Antialiasing Edge 必须 始终 设置为严格低于Alpha 裁剪阈值的值。当 alpha 裁剪阈值为 0.5 ，alpha 抗锯齿边缘值的默认值 0.3 是比较合理的。但请记住，在修改 alpha 裁剪阈值时，必须调整此调整此 alpha 抗锯齿边缘值。</p>
<p>如果你发现抗锯齿效果不佳，请尝试增加 Alpha Antialiasing Edge ，同时确保其低于 Alpha Scissor Threshold （如果材质使用了 Alpha 裁剪）。另一方面，如果你注意到，随着相机靠近材质，纹理的外观发生明显变化，请尝试减小 Alpha Antialiasing Edge 。</p>
<p>为了获得最佳效果，当使用 Alpha 抗锯齿功能时，应在“项目设置”中将 MSAA 3D 设置为至少 2x。这是因为，此 Alpha 抗锯齿功能依赖于 Alpha 覆盖，而 Alpha 覆盖是 MSAA 提供的功能。如果没有使用 MSAA，则会在材质的边缘应用固定的抖动模式，这对于平滑边缘并不是很有效（尽管也有一点用）。</p>
<p>Blend Mode（混合模式）<br>控制材质的混合模式。请记住，Mix 以外的任何模式都会强制对象通过透明管道。</p>
<ul>
<li>Mix：（混合）默认混合模式，Alpha 控制对象可见的程度。</li>
<li>Add：（添加）对象的最终颜色会添加到屏幕的颜色中，非常适合耀斑或类似火焰的效果。</li>
<li>Sub：（减去）从屏幕颜色中减去对象的最终颜色。</li>
<li>Mul：（相乘） 对象的最终颜色与屏幕的颜色相乘。</li>
<li>预乘 Alpha： 对象的颜色应该已经乘以 alpha。当 alpha 为 0.0 时，其行为类似于 Add （完全透明），并且在 alpha 为 1.0（不透明）时类似于混合 。</li>
</ul>
<p>Cull Mode（剔除模式）<br>确定渲染背面时不绘制对象的哪一侧:<br>Back: 当不可见时，对象的背面被剔除(默认)。<br>Front: 当不可见时，物体的正面被剔除。<br>Disabled: 用于双面对象(不进行剔除)。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
默认情况下，Blender 在材质上禁用背面剔除，导出材质时匹配其在 Blender 中的渲染方式。<br>
这意味着 Godot 中的材质会将其剔除模式设置为 Disabled。<br>
这会降低性能，因为背面将被渲染，即使它们不可见。<br>
要解决此问题，请在 Blender 的材质选项卡中启用 Backface Culling ，然后再次将场景导出为 glTF。
</p>

<p>深度绘制模式（Depth Draw Mode）<br>指定何时必须进行深度渲染。</p>
<ul>
<li>仅不透明（默认，Opaque Only）：仅为不透明对象绘制深度。</li>
<li>始终（Always）：为不透明和透明物体深度绘制。</li>
<li>从不（Never）：不进行深度绘制（不要将其与下面的无深度测试选项混淆）。</li>
<li>深度预处理（Depth Pre-Pass）：对于透明物体，首先对不透明部分进行不透明处理，然后在上面绘制透明度。对透明草或树叶使用该选项。</li>
</ul>
<p>无深度测试（No Depth Test）<br>为了使近距离物体出现在远处的物体上，进行深度测试。 禁用它会导致对象出现在其他所有内容之上(或之下)。<br>禁用此选项对于在世界空间中绘制指标最有意义，并且与Material的 Render Priority 属性一起效果很好(请参阅本页底部)。</p>
<p>着色<br>着色模式<br>材质支持三种着色模式：逐像素、逐顶点和无着色。</p>
<ol>
<li>逐像素（Per-Pixel）着色模式会为每个像素计算光照，适用于大多数使用场景。但是，在某些情况下，你可能希望通过使用其他着色模式来提高性能。</li>
<li>逐顶点（Per-Vertex）着色模式，通常称为”顶点着色”或”顶点光照”，该模式会为每个顶点计算一次光照，然后在像素之间对结果进行插值。<br> 在低端或移动设备上，使用逐顶点光照可以显著提升渲染性能。渲染多层透明度时（例如使用粒子系统时），使用逐顶点着色可以提升性能，尤其是在相机贴近粒子时。<br> 你也可以使用逐顶点光照来实现复古风格的外观。</li>
<li>无着色（Unshaded）着色模式完全不会计算光照。直接输出 Albedo （反照率）颜色。光源不会对材质产生任何影响，无光照材质通常会显得比有光照材质亮很多。<br> 无光照渲染在某些特定的视觉效果中非常有用。如果需要最大性能，它也可以用于粒子效果、低端设备或移动设备。</li>
</ol>
<p>漫反射模式（Diffuse Mode）<br>指定光线照射到物体时发生漫散射所使用的算法：</p>
<ol>
<li>Burley：默认模式，原始的 Disney Principled PBS 漫反射算法。</li>
<li>Lambert：不受粗糙度的影响。</li>
<li>Lambert Wrap：当粗糙度增加时，将 Lambert 拓展至覆盖 90 度以上。适用于头发和模拟廉价的次表面散射。这种实现是节能的。</li>
<li>Toon： 为照明提供硬边缘，光滑度受粗糙度的影响。<br> 建议你从环境的环境光设置中禁用 sky contribution（天空补偿），或在 StandardMaterial3D 中禁用环境光以获得更好的效果。</li>
</ol>
<p>镜面反射模式（Specular Mode）<br>指定镜面反射斑点的呈现方式。镜面反射斑点是在对象中反射的光源的形状。<br>ShlickGGX： 现在 PBR 3D引擎使用的最常见的斑点。<br>Toon: 创建一个toon blob，根据粗糙度改变大小。<br>禁用: 有时候blob很烦人。 消失吧！</p>
<p>禁用环境光（Disable Ambient Light）<br>使物体不会接收任何会照亮它的环境光。</p>
<p>禁用雾<br>使对象不受基于深度或体积雾的影响。<br>这对于粒子或其他添加混合的材质很有用，否则它们会显示网格的形状（即使在没有雾的情况下看不见的地方）。</p>
<p>禁用镜面遮挡<br>使对象在通常被遮挡的地方不减少反射。</p>
<p>顶点颜色（Vertex Color）<br>此设置允许选择默认情况下如何处理来自 3D 建模应用程序的顶点颜色。默认情况下，它们会被忽略。</p>
<p>Use as Albedo（用作反照率）<br>选择此选项意味着用顶点颜色作为反射颜色。</p>
<p>是 sRGB（Is sRGB）<br>大多数 3D 建模软件可能会将顶点颜色导出为 sRGB，因此切换此选项将有助于使它们看起来正确。</p>
<p>Albedo（反照率）<br>Albedo 是材质的基色，所有其他设置都在其上运行. 设置为 Unshaded 时，这是唯一可见的颜色. 在以前版本的Godot中，这个通道被命名为 Diffuse . 名称的改变主要是因为在PBR(Physically Based Rendering，基于物理渲染)中，这种颜色影响的计算远不止漫射光照路径.<br>反照率颜色（Albedo Color）可以和纹理一起使用，因为它们会被相乘。<br>反照率颜色和纹理的 Alpha通道 也用于对象透明度. 如果你使用带 alpha通道 的颜色或纹理，请确保启用透明度或 alpha scissoring 以使其正常工作.</p>
<p>Metallic（金属度）<br>Godot 使用了金属模型，因为它比别的模型简单得多。该参数定义了材质的反射程度。反射性越高，漫射&#x2F;环境光对材质的影响就越小，反射的光就越多。这种模型被称为“能量守恒”。<br>Specular 参数是反射率的一般数量（与 Metallic 不同，能量不守恒，因此请将其保留为 0.5 并且除非你需要，否则不要碰它）。<br>最小的内部反射率是 0.04，因此不可能使材质完全不产生反射，就像在现实生活中一样。</p>
<p>Roughness（粗糙度）<br>粗糙度 会影响反射的发生方式. 值 0 使其成为完美的镜子，而 1 的值完全模糊了反射(模拟自然微表面).<br>最常见的材质类型可以通过 Metallic 和 Roughness 的正确组合来实现.</p>
<p>Emission（自发光）<br>Emission 指定材质发出的光量（请记住，这不包括环绕几何体的光, 除非使用 VoxelGI 或 SDFGI)。<br>此值将添加到生成的最终图像中，并且不受场景中其他光照的影响。</p>
<p>法线贴图<br>法线贴图允许你设置一个代表更精细形状细节的纹理，这不会修改几何体，只会修改光的入射角.<br>在Godot中，为了更好的压缩和更广泛的兼容性，只使用了法线贴图的红色和绿色通道.</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
Godot 需要法线贴图使用 X+、Y+、Z+ 坐标，即 OpenGL 风格。如果你导入了用于其他引擎的材质，它可能使用的是 DirectX 风格，那么就需要对法线贴图的进行转换，翻转 Y 轴。
</p>

<p>弯曲法线贴图<br>弯曲法线贴图描述环境光照的平均方向。<br>与常规法线贴图不同，这用于改进材质对光照的反应方式，而不是添加表面细节。<br>这可以通过两种方式实现：</p>
<ol>
<li>间接漫反射照明旨在更紧密地匹配全局照明。</li>
<li>如果启用了镜面反射遮挡，则使用弯曲法线和环境光遮挡来计算，而不仅仅是根据环境光进行计算。这包括屏幕空间环境光遮挡 （SSAO） 和其他环境光遮挡源。</li>
</ol>
<p>Godot 仅使用弯曲法线贴图的红色和绿色通道，以获得更好的压缩和更广泛的兼容性。<br>创建弯曲法线贴图时，它需要满足三件事才能在 Godot 中正常工作：</p>
<ol>
<li>烘烤时必须使用射线的余弦分布 。</li>
<li>纹理必须在切线空间中创建。</li>
<li>弯曲的法线贴图需要使用 X+、Y+ 和 Z+ 坐标，这称为 OpenGL 样式。如果您导入了用于其他引擎的材质，则它可能是 DirectX 风格，在这种情况下，需要转换弯曲的法线贴图，以便翻转其 Y 轴。这可以通过将 通道重新映射（Channel Remap） 部分下的绿色通道设置为 导入停靠栏中的倒置绿色 。</li>
</ol>
<blockquote>
<p>弯曲法线贴图不同于常规法线贴图。两者不可互换。</p>
</blockquote>
<p>Rim（边缘）<br>一些织物具有小的微毛，导致光在其周围散射.<br>Godot使用 Rim 参数模拟它.<br>与仅使用发射通道的其他边缘照明实施方式不同，这实际上考虑了光(没有光意味着没有边缘). 这使得效果显著地更加可信.</p>
<p>边缘大小取决于粗糙度，并且有一个特殊参数来指定它必须如何着色。如果染色（Tint）为 0，则使用光的颜色作为边缘。如果染色（Tint）为 1，则使用材质的反照色。使用中间的值通常效果最好。</p>
<p>Clearcoat（清漆）<br>Clearcoat 参数用于为材质添加辅助的透明涂层。<br>这在汽车油漆和玩具中很常见。在实践中，它是在现有材质之上添加的较小的镜面反射斑点。</p>
<p>Anisotropy（各向异性）<br>这会更改镜面反射斑点的形状并将其与切线空间对齐。各向异性通常与头发一起使用，或使诸如拉丝铝之类的材质更加逼真。与流向贴图结合使用时效果特别好。</p>
<p>Ambient Occlusion（环境光遮蔽）<br>可以指定烘焙的环境遮挡贴图. 此贴图会影响有多少环境光到达物体每个表面(默认情况下它不会影响直接光). 虽然可以使用屏幕空间环境遮挡(Screen-Space Ambient Occlusion，SSAO)来生成环境遮挡，但没有什么能比良好烘焙的AO贴图的质量更好. 建议尽可能烘焙环境遮挡.</p>
<p>Height（高度）<br>在材质上设置高度贴图会做一个光线步进搜索，以模拟沿视图方向的凹陷的正确位移。这不会增加真正的几何体，而是创建一种深度的幻觉——想了解用于物理碰撞（如地形）的高度贴图形状，请查看 HeightMapShape3D。它可能不适用于复杂的物体，但会为纹理产生逼真的深度效果。为获得最佳效果，Height 应与法线贴图一起使用。</p>
<p>Subsurface Scattering（次表面散射）<br>该功能仅适用于 Forward+ 渲染器，不适用于 Mobile 或 Compatibility 渲染器。<br>此效果模拟穿透物体表面，散射然后散出的光. 创造逼真的皮肤，大理石，有色液体等有用.</p>
<p>Back Lighting（背光照明）<br>这可以控制有多少光从被点亮的一侧(正对灯光)传输到暗侧(背对灯光). 这适用于植物叶子，草，人耳等薄物体.</p>
<p>Refraction（折射）<br>当启用折射时，Godot 会尝试从正在渲染的对象后面获取信息。这允许以类似于现实生活中折射的方式扭曲透明度。<br>记住使用透明的反照率纹理（或减少反照率颜色的 alpha 通道）使折射可见，因为折射依赖于透明度才能产生可见效果。<br>折射也会考虑材质的粗糙度。粗糙度越高，受折射影响的物体看起来越模糊，这模拟了现实生活中的行为。如果开启了折射且降低了Albedo的透明度后，依然看不见物体后方，可通过降低材质的<strong>粗糙度</strong>解决。<br>可以选择在 Refraction Texture 属性中指定法线贴图，以便在每个像素的基础上扭曲折射方向。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
折射效果是作为屏幕空间效果实现的，并强制材料透明。这使得效果相对较快，但也造成了一些限制：<br>
透明度排序 可能会出现问题。<br>
折射材料不能折射到自身或其他透明材料上。在另一种透明材料后面的折射材料是不可见的。<br>
屏幕外的物体无法出现在折射效果中。这在折射强度值较高时最为明显。<br>
折射材料前面的不透明材料将看起来具有 "折射 "边缘，尽管它们不应该出现这种边缘。
</p>

<p>细节（Detail）<br>Godot允许使用辅助反射和法线贴图生成细节纹理，可以通过多种方式进行混合. 通过将其与二级UV或三平面模式相结合，可以实现许多有趣的纹理.</p>
<p>有几种设置可以控制细节的使用方式.</p>
<ol>
<li>遮罩（Mask）：细节遮罩是一张黑白图像，用于控制纹理上的混合位置。白色用于细节纹理，黑色用于常规材质纹理，不同深浅的灰色用于材质纹理和细节纹理的部分混合。</li>
<li>混合模式: 有四种模式控制纹理的混合方式.</li>
<li>融合: 合并两个纹理的像素值. 黑色时，仅显示材质纹理；白色时，仅显示细节纹理. 灰色的值在两者之间创建一个平滑的混合.</li>
<li>相加: 将一个纹理与另一个纹理的像素值相加. 与融合模式不同的是，两个纹理在蒙板的白色部分而不是灰色部分完全混合. 原始纹理在黑色部分基本没有变化</li>
<li>相减: 将一个纹理的像素值与另一个纹理的像素值相减. 第二种纹理在蒙版的白色部分被完全减去，在黑色部分只被减去一点，灰色部分根据具体实际纹理减去不同的程度.</li>
<li>相乘: 将上方纹理中每个像素的 RGB 通道数与下方纹理中相应像素的值相乘.</li>
<li>Albedo: 在此处放置要混合的反射纹理. 如果此插槽中没有任何内容，则默认情况下将其解释为纯白.</li>
<li>法线: 在此处放置需要混合的法线纹理. 如果这个槽中没有任何东西，它将被解释为一个平坦的法线贴图. 即使材质未启用法线贴图也可以使用这个槽.</li>
</ol>
<p>UV1 和 UV2<br>Godot每种材质支持两个UV通道. 二级UV通常可用于环境遮挡或发射(烘焙的光照).<br>UV可以缩放和偏移，这在使用重复纹理时很有用.</p>
<p>三平面映射（Triplanar Mapping）<br>UV1 和 UV2 都支持三平面映射。这是获得纹理坐标的另一种方法，有时称为“自动纹理”。纹理在 X、Y、Z 中采样，通过法线混合。可以在世界空间或对象空间中执行三平面映射。<br>在下图中，你可以看到所有图元如何与世界三平面共享相同的材质，因此砖纹理在它们之间平滑地继续。</p>
<p>世界三平面（World Triplanar）<br>使用三平面映射时（见下文，在 UV1 和 UV2 设置中），它是在对象局部空间中计算的。此选项使三平面映射使用世界空间。</p>
<p>采样<br>过滤器<br>材质使用的纹理过滤方法。请参阅 this page 获取完整的选项列表及其说明。</p>
<p>重复<br>材质使用的纹理是否重复，以及重复的方式。请参阅 this page 获取完整的选项列表及其说明。</p>
<p>阴影<br>不接受阴影（Do Not Receive Shadows）<br>使对象不会接收任何可能会被投射到其上的阴影。</p>
<p>使用阴影到不透明度（Use Shadow to Opacity）<br>光照会改变alpha值，阴影部分是不透明的，而没有阴影的地方是透明的。 对于AR中将阴影堆叠到一个照相机反馈中很有用。</p>
<p>公告板<br>公告板模式（Billboard Mode）<br>启用公告板模式来绘制材质。这控制对象如何面向相机：<br>已禁用（Disabled）：公告板模式已被禁用。<br>已启用（Enabled）：公告板模式已启用。对象的 -Z 轴将始终面向相机的观察平面。<br>Y 公告板（Y-Billboard）：物体的 X 轴将始终与相机的观察平面对齐。<br>粒子公告板（Particle Billboard）：最适合粒子系统，因为它允许指定翻页动画。</p>
<p>仅当公告板模式为粒子公告板（Particle Billboard）时，粒子动画（Particles Anim）部分才可见。</p>
<p>公告板保持比例（Billboard Keep Scale）<br>启用在公告板模式下缩放网格。<br>生长（Grow）<br>沿法线指向的方向增长对象顶点:<br>这通常用于创建廉价的轮廓. 添加第二个material pass，使其变为黑色，无阴影(unshaded)，反向剔除(Cull Front)，并添加一些增长:</p>
<blockquote>
<p>要使 Grow 功能按预期工作，网格必须具有共享顶点的连接面，即”平滑着色”。如果网格具有独立顶点的断开面，即”平面着色”，使用 Grow 时网格会出现缝隙。</p>
</blockquote>
<p>Transform<br>固定大小（Fixed Size）<br>这使得无论距离如何，对象都以相同的大小呈现。 这主要用于指示物(无深度测试和高渲染优先级)和某些类型的广告牌。</p>
<p>使用点大小（Use Point Size）<br>此选项仅在渲染的几何体由点组成时有效（通常从3D 建模软件中导入时由三角形组成）。如果是这个情况，那么这些点可以被调整大小（见下文）。</p>
<p>点大小（Point Size）<br>绘制点时，指定点的大小，单位为像素。</p>
<p>使用粒子轨迹 (Particle Trails)<br>如果为 true，则启用 GPUParticles3D 轨迹所需的着色器部分功能。这还需要使用具有适当蒙皮的网格体，例如 RibbonTrailMesh 或 TubeTrailMesh。在 GPUParticles3D 网格中使用的材质之外启用此功能将中断材质渲染。</p>
<p>使用 Z Clip Scale<br>将渲染的对象缩放到摄像机上，以避免夹入墙壁等物体。这旨在用于相对于摄像机固定的对象，例如玩家手臂、工具等。<br>调整此设置后，光照和阴影将继续正常工作，但 SSAO 和 SSR 等屏幕空间效果可能会因比例较低而中断。因此，尽量保持此设置尽可能接近 1.0。</p>
<p>使用 FOV Override<br>覆盖 Camera3D 的视场角（以度为单位）。</p>
<blockquote>
<p>这就像在 Camera3D 上设置视野一样，使用 Camera3D.keep_aspect 设置为 Camera3D.KEEP_HEIGHT。此外，在忽略视野设置的非透视相机上，它可能看起来不正确。</p>
</blockquote>
<p>Proximity and Distance Fade（邻近和距离淡入淡出）<br>Godot允许材质通过彼此接近以及取决于与观察者的距离而隐去。邻近淡入淡出（Proximity Fade）对于诸如软粒子或大量水平滑地过渡到海岸很有效。<br>距离渐变适用于在一定距离后才出现的光轴或指示器。<br>请注意，使用 Pixel Alpha 模式启用近距离渐变或远距离渐变时，会启用 Alpha 混合。Alpha 混合对 GPU 的要求较高，可能会导致透明度排序问题。Alpha 混合也会禁用许多材质功能，例如阴影投射。</p>
<blockquote>
<p>当角色距离相机太近时，想隐藏角色可考虑使用 Pixel Dither 或更好的 Object Dithe (比<strong>Pixel Dither</strong>更快).<br>Pixel Alpha 模式：对象身上像素的透明度会随相机距离而改变。效果最好，但会直接跳过常规渲染管线，强制把材质送入透明处理阶段 (这会导致一些问题，比如：物体无法产生阴影).<br>像素抖动模式：该模式通过仅渲染一小部分像素来近似透明度。<br>对象抖动模式：与前一种模式类似，但计算出的透明度在整个对象的表面是相同的。</p>
</blockquote>
<p>材质设置<br>渲染优先级（Render priority）<br>可以更改对象的渲染顺序，尽管这对于透明对象有用(或执行深度绘制但没有颜色绘制的不透明对象，例如地板上的裂缝).<br>物体首先按照不透明&#x2F;透明队列进行排序，然后根据 render_priority，优先级越高绘制越晚。透明物体还会根据深度进行排序。<br>深度测试优先于渲染优先级。仅靠优先级无法强制不透明物体相互覆盖绘制。</p>
<p>Next Pass（下一阶段）<br>在材质上设置 next_pass 将导致物体使用该下一个材质再次渲染。<br>材质会根据不透明&#x2F;透明队列进行排序，然后按 render_priority 排序，优先级越高绘制越晚。<br>除非使用了 grow 设置或其他顶点变换，否则两种材质之间的深度测试将相等。多个透明通道应使用 render_priority 来确保正确排序。</p>
<h4 id="3D-灯光和阴影"><a href="#3D-灯光和阴影" class="headerlink" title="3D 灯光和阴影"></a>3D 灯光和阴影</h4><p>场景可以有很多不同类型的光源：</p>
<ol>
<li>来自材质本身的自发光颜色（但是无法影响附近的对象，除非进行了烘焙，或者启用了屏幕空间间接光照）。自发光是材质的属性。</li>
<li>灯光节点：DirectionalLight3D、OmniLight3D、SpotLight3D。</li>
<li>Environment 或 反射探针 中的环境光。</li>
<li>全局光照（LightmapGI、VoxelGI、SDFGI）。</li>
</ol>
<p>灯光节点<br>灯光节点有三种：<br>DirectionalLight3D、OmniLight3D、SpotLight3D。<br>让我们来看看灯光的通用参数：</p>
<ul>
<li>Color：发光的基础颜色。</li>
<li>Energy：能量乘数。这对于使灯光饱和或使用 高动态范围光照 非常有用。</li>
<li>Indirect Energy：间接能量。用于间接光（反弹的光）的次级乘数。适用于 使用光照贴图全局照明、VoxelGI 和 SDFGI。</li>
<li>Volumetric Fog Energy：体积雾能量。用于体积雾的次级乘数。仅在启用体积雾时有效。</li>
<li>Negative： （减色）光变为减色而不是添加。对于手动补偿一些黑暗角落有时很有用。</li>
<li>Specular：镜面反射。影响受此光影响的物体中镜面反射斑点的强度。值为零时，该光变为纯漫反射光。</li>
<li>Bake Mode：设置灯光的烘焙模式。见 使用光照贴图全局照明。</li>
<li>Cull Mask： （剔除遮罩）在下面选定的图层中的物体将受到此光的影响。请注意，通过这个剔除遮罩禁用的对象仍然会投射阴影。<br>  如果你不希望被禁用的物体投射阴影，请将 GeometryInstance3D上的 Cast Shadow 属性调整为所需的值。<blockquote>
<p>如果你希望使用真实世界的单位来配置灯光的强度和色温，请参阅 物理灯光和相机单位。</p>
</blockquote>
</li>
</ul>
<p>灯光数量限制</p>
<ol>
<li>使用 Forward+ 渲染器时，Godot 使用集群方法进行实时光照。可以添加任意数量的灯光（只要性能允许）。<br>但是，当前相机视图中可以存在的集群元素的默认上限仍为 512 个。<br>集群元素是指全向灯、聚光灯、贴花或反射探针。<br>可以通过调整项目设置 &gt; 渲染 &gt; 限制 &gt; 集群构建器的 最大集群元素数 来增加该上限。</li>
<li>使用 Mobile 渲染器时，每个网格资源有 8 个 OmniLight 加 8 个 SpotLight 的限制。<br>此外，在当前相机视图中可渲染的 OmniLight 和 SpotLight 数量限制为 256 个。这些限制目前无法更改。</li>
<li>使用兼容渲染器时，每个网格资源最多可渲染 8 个 OmniLight 加 8 个 SpotLight。<br>此限制可以在 渲染 &gt; 限制 &gt; OpenGL 的高级项目设置里调整 最大可渲染元素数 和&#x2F;或 单对象最大光源数 来提升，但会牺牲性能和延长着色器编译时间。<br>可以通过减少此限制来减少着色器编译时间并略微提升性能。</li>
</ol>
<p>在所有的渲染方法中，最多可以同时显示 8 个 DirectionalLight。<br>但是，每增加一个启用阴影的 DirectionalLight，都会降低每个 DirectionalLight 的有效阴影分辨率。这是因为所有灯光共享方向阴影图集。<br>如果超过了渲染限制，灯光就会在摄像机移动过程中跳进跳出，这可能会分散注意力。<br>在灯光节点上启用 Distance Fade 有助于减少这一问题，同时还能提高性能。将网格分割成更小的部分也会有所帮助，尤其是关卡几何体（这也能提高剔除效率）。<br>如果你需要渲染的灯光数量超过了给定渲染器所能提供的数量，请考虑使用 烘焙光照贴图，并将灯光的烘焙模式设置为 静态 。<br>这样就可以完全烘焙光照，从而加快渲染速度。你也可以使用任何全局光照技术的自发光材质来替代在大范围内发光的灯光节点。</p>
<p>阴影贴图<br>灯光可以可选地投射阴影. 这使它们具有更好的真实感(光线不会照到被遮挡的区域)，但它会带来更大的性能开销.<br>有一个通用阴影参数列表，每个参数也有一个特定的功能:</p>
<ul>
<li>Enabled： 启用此灯光下的阴影贴图。</li>
<li>Opacity： （不透明度）被遮挡的区域会因该不透明度系数而变暗。<br>  默认情况下，阴影是完全不透明的，但是可以更改此设置，以使阴影对于给定的光线来说是半透明的。</li>
<li>Bias：（偏置）当此参数太小时，阴影会打在物体自己身上。当太大时，阴影会与物体本体分开。请调整到最适合你的状态。</li>
<li>Normal Bias：当此参数太小时，阴影会打在物体自己身上。当太大时，阴影会与物体本体分开。请调整到最适合你的状态。</li>
<li>Transmittance Bias：（透射率偏置）当此参数太低时，启用透射率的材质上，阴影会打在物体自己身上。<br>  如果太高，阴影将不会影响始终启用透射率的材质。请调整到最适合你的状态。</li>
<li>Reverse Cull Face：反转表面剔除，当阴影贴图使用反转表面剔除渲染时，在某些场景表现更好。</li>
<li>Blur（模糊）：倍增该灯光的阴影模糊半径。<br>  这适用于传统阴影贴图和接触硬化阴影（角度距离（Angular Distance）或大小（Size）大于 0.0 的灯光）。<br>  数值越大，阴影越柔和，对于移动的物体来说，阴影在时间上也会显得更加稳定。<br>  增加阴影模糊的缺点是，它会让用于滤波的颗粒图案更加明显。另请参阅 阴影过滤模式。</li>
<li>Caster Mask（投射遮罩）： 只有在这些图层中的对象才能投射阴影。注意，这个遮罩不会影响阴影投射到哪些对象上。</li>
</ul>
<p>调整阴影偏置<br>下图是调整偏置的图像。默认值适用于大多数情况，但通常来说，它取决于几何的大小和复杂程度。<br>如果给定灯光的 Shadow Bias 或 Shadow Normal Bias 设置得太低，阴影就会 “涂抹 “到物体上。<br>这将导致光线的预期外观变暗，称为 阴影失真 （shadow acne）：<br>另一方面，如果给定光线的 Shadow Bias 或 Shadow Normal Bias 设置得太高，阴影可能看起来与物体脱节。这被称为<strong>阴影悬浮</strong>（peter-panning）：<br>一般来说，增加 Shadow Normal Bias 比增加 Shadow Bias 更可取。<br>增大 Shadow Normal Bias 不会像增大 Shadow Bias 那样导致更多的阴影悬浮，但仍能有效解决大多数阴影失真问题。<br>增加 Shadow Normal Bias 的缺点是会使某些物体的阴影看起来更薄。<br>任何偏置问题都可以通过 提高阴影贴图分辨率 来解决，尽管这可能会导致性能下降。<br><strong>外观更改注意事项</strong>：在光源上启用阴影时，请注意，与在兼容性渲染器中渲染无阴影时相比，光源的外观可能会发生变化。<br>由于旧移动设备的限制，阴影是使用多通道渲染方法实现的，因此带有阴影的光源在 sRGB 空间而不是线性空间中渲染。<br>渲染空间的这种变化有时会极大地改变灯光的外观。要获得与无阴影光源相似的外观，您可能需要调整光源的能量设置。</p>
<p>平行光<br>计算中最便宜的光，应该尽可能使用(虽然它不是计算起来最便宜的阴影贴图，但这点稍后再说).<br>平行光模拟覆盖整个场景的无限数量的平行光线。<br>平行光节点由指示光线方向的大箭头表示。但是，节点的位置根本不会影响照明，它可以在任何地方。<br>每个表面的正面被光线照射，而其他部分则保持黑暗。与大多数其他类型的光不同，平行光没有特定的参数。<br>定向光源还提供 角距离（Angular Distance） 属性，该属性确定光源的角度大小（以度为单位）。将其增加到 0.0 以上 会在距离施法者较远的地方使阴影更柔和，同时还 影响程序化天空材质中太阳的外观。这称为 接触硬化阴影（也称为 PCSS）。<br>作为参考，从地球看太阳的角距离约为 0.5。这种阴影的性能消耗资源较高，因此如果在启用阴影的灯光上将此值设置为高于 0.0，请查看 PCSS 建议 中的建议。</p>
<p>方向光阴影贴图<br>为了计算阴影贴图，从覆盖整个场景（或最大距离）的正交角度渲染场景（仅深度）。<br>但是，这种方法存在一个问题，因为靠近相机的物体接收到的低分辨率阴影可能看起来是块状的。<br>为了解决这个问题，我们使用了一种名为平行分割阴影贴图（PSSM，Parallel Split Shadow Maps）的技术。<br>这将视锥体分割成 2 个或 4 个区域。每个区域都有自己的阴影贴图。这使得靠近观察者的小区域可以具有与远处巨大区域相同的阴影分辨率。<br>当为 DirectionalLight3D 启用阴影时，默认阴影模式为具有 4 个分割的 PSSM。<br>在对象大到足以出现在所有四个分割区域中的情况下，它会导致绘制调用增加。<br>具体来说，这样的对象将被总共渲染五次：四个阴影分割各渲染一次，最终场景渲染一次。<br>这可能会影响性能，理解该行为对于优化场景和管理性能预期非常重要。<br>有了它，阴影变得更加详细:<br>为了控制PSSM，暴露了许多参数:<br>每个分割距离都是相对于相机最远处进行控制的（如果大于 0 ，则为阴影 Max Distance(最大距离) ）。0.0 是眼睛位置，1.0 是阴影在一定距离处结束的位置。分割介于两者之间。默认值通常效果很好，但一般会调整第一个分割数值，以便为近处对象提供更多细节（比如第三人称游戏中的角色）。<br>请务必根据场景需要设置阴影的 Max Distance 。最大距离越小，阴影效果越好，性能也越高，因为阴影渲染中需要包含的物体越少。你还可以调整 Fade Start 来控制远处阴影淡出距离的强度。对于 Max Distance 完全覆盖任何给定摄像机位置的场景，可以将 Fade Start 增加到 1.0 ，以防止阴影在远处渐变。在 Max Distance 没有完全覆盖场景的场景中，不应该这样做，因为阴影会在远处突然消失。<br>有时，一个分割与下一个之间的过渡看起来很糟糕。要解决此问题，可以打开 Blend Splits （混合分割）选项，牺牲细节和性能以换取更平滑的过渡：<br>Shadow &gt; Normal Bias 参数可用于修复当对象垂直于光线时自阴影的特殊情况。唯一的缺点是它会使阴影变得更薄。在大多数情况下，在增加 Shadow &gt; Bias 之前，请考虑增加 Shadow &gt; Normal Bias 。<br>最后，如果未细分网格的大型对象出现了阴影缺失的情况，可以调整 Pancake Size（压平区大小）属性来修复。只有在发现阴影缺失与阴影偏置问题无关时，才可以更改此值。</p>
<p>全向光<br>全向光是一种点光源，可在所有方向上发射光，直至给定的半径。<br>在现实生活中，光衰减是个和距离成反比的函数，这意味着全向光没有半径。这是一个问题，因为这意味着计算几个全向光会变得很困难。<br>为了解决这个问题，引入了 Range （范围）参数和衰减函数。<br>这两个参数允许调整其在视觉上的工作方式，以便找到美学上令人愉悦的结果.<br>OmniLight3D 中还提供了“ 大小” 参数。增加此值将使光源淡出速度变慢，并且当远离施法者时阴影显得更模糊。这可用于在一定程度上模拟区域光。这称为接触硬化阴影（也称为 PCSS）。这种影子是 价格昂贵，因此请查看 PCSS 建议如果将此值设置为上述值 0.0 在启用了阴影的光源上。</p>
<p>全向光阴影贴图<br>全向光的阴影贴图相对简单。需要考虑的主要问题是用于渲染它的算法。<br>全向阴影可以渲染为双抛物面或立方体映射。 双抛物面渲染速度快，但会导致变形，而立方体 更正确，但速度较慢。<br>默认值为 立方体（Cube），但对于视觉上没有太大差异的光源，请考虑将其更改为 双抛物面（Dual Paraboloid）。<br>如果渲染的对象大部分是不规则且细分的，那么 Dual Paraboloid （双抛物线）通常就足够了。<br>无论怎么说，由于这些阴影被缓存在阴影图集中（后面会详细介绍）， 对于大多数场景而言，它可能不会对性能产生影响。<br>启用阴影功能的全向灯光可以使用投影。投影纹理会将灯光的颜色乘以纹理上给定点的颜色。<br>因此，一旦分配了投影纹理，灯光通常会显得更暗；你可以增加 Energy 来弥补这一点。<br>全方位光投影纹理需要特殊的 360° 全景贴图，类似于 PanoramaSkyMaterial 纹理。<br>通过下面的投影纹理，可以得到以下结果：</p>
<p>小技巧<br>如果你已获得立方体贴图形式的全方位投影图像，你可以使用 这个基于网络的转换工具 将它们转换为单一的全景图像。</p>
<p>聚光<br>聚光与全向光类似，但是它们只发光到锥形（或“截断”）中。<br>用于模拟手电筒、车灯、反射器、聚光灯等。这种类型的光也会向其指向的相反方向衰减。<br>聚光和<strong>OmniLight3D</strong>共用相同的 Range（范围）、 Attenuation（衰减）和 Size（大小），并添加了两个额外参数：</p>
<ol>
<li>Angle（角度）光线的光圈角度。</li>
<li>Angle Attenuation（角度衰减）锥形衰减，有助于柔化锥形边界。</li>
</ol>
<p>聚光灯阴影贴图<br>光斑具有与阴影贴图全向光源相同的参数。<br>与全向光源相比，渲染点阴影贴图的速度要快得多，因为只需要渲染一个阴影纹理（而不是渲染 6 个面，或在双抛物面模式下渲染 2 个面）。<br>启用阴影功能的光线可以使用投影。投影纹理会将灯光的颜色乘以纹理上给定点的颜色。因此，一旦分配了投影纹理，灯光通常会显得更暗；你可以增加 Energy 来弥补这一点。<br>与全向光投影不同，聚光灯投影纹理不需要遵循特殊格式就能看起来正确无误。它的映射方式类似于贴花。<br>通过下面的投影纹理，可以得到以下结果：</p>
<blockquote>
<p>广角聚光灯的阴影质量会低于窄角聚光，因为阴影贴图会分布在更大的表面上。角度大于 89 度时，聚光阴影将完全停止工作。如果你需要更宽的灯光阴影，请使用全向光。</p>
</blockquote>
<p>阴影图集<br>与具有自己的阴影纹理的平行光不同，全向光和聚光被分配了阴影图集的槽位。该图集可以在高级项目设置（ 渲染 &gt; 灯光和阴影 &gt; 位置阴影 ）中进行配置。<br>这个分辨率适用于整个阴影图集。该图集分为四个象限：<br>每个象限可以细分，分配任意数量的阴影贴图。以下是默认细分方式：<br>阴影图集分配空间如下：<br>最大阴影贴图尺寸（未使用细分时）代表屏幕尺寸（或更大）的灯光。<br>细分（较小的贴图）表示距离视图较远并且比例较小的灯光的阴影。<br>每一帧，以下过程被应用于所有光:<br>检查灯光是否在正确大小的插槽上. 如果没有，重新渲染它并将其移动到更大&#x2F;更小的插槽.<br>检查影响阴影贴图的任何对象是否已更改. 如果是的话，重新渲染光线.<br>如果上述情况均未发生，则不执行任何操作，阴影保持不变.<br>如果一个象限中的槽位满了，光线会被推回到更小的槽位中，取决于大小和距离。如果所有象限中的所有槽位都已满，则某些灯光即使启用了阴影，也将无法渲染阴影。<br>默认的阴影分配策略最多可以渲染 88 盏灯，并在相机锥体中启用阴影（4 + 4 + 16 + 64）：<br>第一象限也是最精细的象限，可以存储 4 个阴影。<br>第二象限可存储 4 个其他阴影。<br>第三象限可存储 16 个阴影，但细节较少。<br>第四象限也是细节最少的象限，可存储 64 个阴影，但细节更少。<br>每个象限使用较多的阴影数量可以支持启用阴影的更多灯光，同时还能提高性能（因为阴影将以较低的分辨率为每个灯光渲染）。不过，增加每个象限的阴影数量的代价是降低阴影质量。<br>在某些情况下，你可能想要使用不同的分配策略。例如，在自上而下看的游戏中，所有灯光的大小都大致相同，你可能希望将所有象限设置为具有相同的细分，以便所有灯光都具有相似质量级别的阴影。</p>
<p>平衡性能与质量<br>阴影渲染是 3D 渲染性能方面的重要议题。做出正确的选择非常重要，这样才能避免制造出瓶颈。<br>平行光的阴影质量设置可以在运行时通过调用合适的 RenderingServer 方法进行更改。<br>位置光（全向光&#x2F;聚光）的阴影质量设置可以在运行时通过根 Viewport 进行更改。</p>
<p>阴影贴图大小<br>高阴影分辨率会带来更清晰的阴影，但性能会大幅下降。还应注意，更清晰的阴影并不总是更逼真。在大多数情况下，应将其保持为默认值 4096 或针对低端 GPU 降低至 2048。<br>如果在减小阴影贴图大小后，位置阴影变得过于模糊，可以通过调整 shadow atlas 象限以包含较少的阴影来解决。这样就能以更高的分辨率渲染每个阴影。</p>
<p>阴影过滤模式<br>这里可以选择多种阴影贴图质量设置。默认的 Soft Low 在性能和质量之间取得了很好的平衡，适用于有细节纹理的场景，因为纹理细节有助于使颜色抖动的纹路不那么明显。<br>不过，在纹理细节较少的项目中，颜色抖动的纹路可能会更加明显。要隐藏这种纹路，可以启用 时间抗锯齿（TAA）、AMD FidelityFX Super Resolution 2.2 （FSR2）、快速近似抗锯齿（FXAA） 或将阴影滤镜质量提高到 Soft Medium 或更高。<br>Soft Very Low 设置会自动减少阴影模糊，使低采样数产生的伪影不那么明显。相反，Soft High 和 Soft Ultra 设置会自动增加阴影模糊，以更好地利用增加的样本数。</p>
<p>16 位与 32 位<br>默认情况下，Godot 使用 16 位深度纹理进行阴影贴图渲染。在大多数情况下，我们都建议使用这种方式，因为它的性能更好，而且质量也不会有明显差异。<br>如果禁用 16 Bits，则将使用 32 位色深的纹理。这样做可以减少大型场景和启用阴影的大型灯光中的伪影。不过，这种差异通常几乎不明显，但却会带来显著的性能损失。</p>
<p>灯光&#x2F;阴影的距离淡出<br>OmniLight3D 和 SpotLight3D 提供了一些能够隐藏远距离灯光的属性。如果是在大型场景中，并且存在几十盏灯，就能够显著提升性能。<br>Enabled：（启用）控制是否启用距离淡入淡出（ LOD 的一种形式）。 光线将在 Begin + Length 内淡出，之后它将被剔除并且根本不会发送到着色器。 使用它可以减少场景中活动灯光的数量，从而提高性能。<br>Begin：（开始）光线开始消失时距相机的距离（以 3D 单位表示）。<br>Shadow：（阴影）阴影开始消失时距相机的距离（以 3D 单位表示）。 与光线相比，这可用于更快地淡出阴影，从而进一步提高性能。 仅当为灯光启用阴影时才可用。<br>Length： （长度）光线和阴影淡出的距离（以 3D 单位表示）。 光线在这段距离内慢慢变得更加透明，最后完全不可见。 值越高，淡出过渡越平滑，这样的配置在相机快速移动时更合适。</p>
<p>PCSS 建议<br>百分比接近软阴影 （Percentage-closer soft shadows，PCSS） 会提供更真实的阴影贴图外观，半影（ penumbra ）大小根据光源（caster）与接收阴影的表面之间的距离而变化。 这会带来很高的性能成本，特别是对于平行光而言。<br>为了避免性能问题，建议：<br>仅在给定时间里使用少量启用了 PCSS 阴影的灯光。 这种效果通常在大而明亮的灯光下最为明显。 较微弱的辅助光源通常不会从使用 PCSS 阴影中获益。<br>为用户提供禁用 PCSS 阴影的设置。 在平行光上，这可以通过在脚本中将 DirectionalLight3D 的 light_angular_distance 属性设置为 0.0 来完成。 对于位置光源，这可以通过在脚本中将 OmniLight3D 或 SpotLight3D 的 light_size 属性设置为 0.0 来完成。</p>
<p>投影器过滤模式<br>投影的渲染方式也会对性能产生影响。 渲染&gt; 纹理 &gt; 光投影器 &gt; 过滤 高级项目设置允许你控制投影纹理如何过滤。 Nearest&#x2F;Linear 不使用 mipmap，这使得渲染速度更快。 然而，投影在远处看起来会有颗粒感。 Nearest&#x2F;Linear Mipmaps 在远处看起来会更平滑，但从倾斜角度观看时投影看起来会模糊。 这可以通过使用 Nearest&#x2F;Linear Mipmaps Anisotropic 来解决，这是最高质量的模式，但也是消耗最高的。<br>如果你的项目具有像素艺术风格，请考虑将过滤器设置为 Nearest 的值之一，以便投影使用最近邻过滤（nearest-neighbor filtering）。 否则，请继续使用 Linear 。</p>
<h4 id="使用贴花"><a href="#使用贴花" class="headerlink" title="使用贴花"></a>使用贴花</h4><blockquote>
<p>贴花仅在 Forward 和 Forward Mobile 渲染器中受支持，在兼容性渲染器中则不受支持。<br>如果使用兼容性渲染器，请考虑使用 Sprite3D 作为将贴花投影到（大部分）平坦表面上。<br>贴花是应用于 3D 不透明或透明表面的投影纹理。<br>该投影是实时生成的，不依赖于网格生成。 这允许你在每一帧移动贴花，即使在复杂的网格上应用时，也只会对性能产生很小的影响。<br>虽然贴花无法将实际的几何细节添加到投影表面上，但贴花仍然可以利用基于物理的渲染来提供与完整的 PBR 材质类似的属性。</p>
</blockquote>
<p>使用案例:</p>
<ol>
<li>静态装饰</li>
<li>动态游戏元素</li>
<li>片面阴影</li>
</ol>
<p>在编辑器中创建贴花<br>在 3D 编辑器中创建贴花节点。<br>在检查器中，展开 Textures 部分并在 Textures &gt; Albedo 中加载纹理。<br>将贴花节点移向对象，然后旋转它以使贴花可见（并且方向正确）。 如果贴花看起来是镜像的，请尝试将其旋转 180 度。 你可以通过将 Parameters &gt; Normal Fade 增加到 0.5 来仔细检查其方向是否正确。 这将防止贴花投影到不面向贴花的表面上。<br>如果你的贴花仅影响静态对象，请将其配置为防止影响动态对象（反之亦然）。 为此，请更改贴花的 Cull Mask （剔除蒙版）属性以排除某些图层。 执行此操作后，修改动态对象的 MeshInstance3D 节点以更改其可见性层。 例如，你可以将它们从第 1 层移动到第 2 层，然后在贴花的 Cull Mask 属性中禁用第 2 层。</p>
<p>贴花节点属性:<br>Extents：（范围）贴花的大小。 Y 轴决定贴花投影的长度。 保持投影长度尽可能短，以增加剔除机会，从而提高性能。</p>
<ul>
<li>纹理<ul>
<li>Albedo：（反照率）用于贴花的反照率（漫反射&#x2F;颜色）贴图。<br>  在大多数情况下，这是你要首先设置的纹理。 如果使用法线或 ORM 贴图，则 必须 设置反照率贴图以提供 Alpha 通道。<br>  该 Alpha 通道将用作遮罩，以确定法线&#x2F;ORM 贴图对底层表面的影响程度。</li>
<li>Normal：（法线）用于贴花的法线贴图。 这可用于通过修改光对其的反应方式来增加贴花上的感知细节。 该纹理的影响会乘以反照率纹理的 Alpha 通道（但不是 Albedo Mix ）。</li>
<li>ORM：用于贴花的遮挡（Occlusion）&#x2F;粗糙度（Roughness）&#x2F;金属贴图（Metallic map）。 这是用于存储 PBR 材质贴图的优化格式。 环境光遮挡贴图存储在红色通道中，粗糙度贴图存储在绿色通道中，金属贴图存储在蓝色通道中。 该纹理的影响会乘以反照率纹理的 Alpha 通道（但不是 Albedo Mix ）。</li>
<li>Emission：（自发光）用于贴花的自发光纹理。与 Albedo 不同，此纹理看起来会在黑暗中发光。</li>
</ul>
</li>
<li>参数<ul>
<li>Emission Energy：（自发光能量）自发光纹理的亮度。</li>
<li>Modulate：（调制）将反射率和自发光贴图的颜色相乘。通过这种方式对贴花进行着色（例如，对于绘画贴花）或通过随机化每个贴花的调制来增加多样性。</li>
<li>Albedo Mix：（反照率混合）反照率纹理的不透明度。与使用具有更透明 alpha 通道的反照率纹理不同，将该值降低到 1.0 以下 不会 减少法线&#x2F;ORM 纹理对下表面的影响。在创建仅普通&#x2F;ORM 贴花（如足迹或湿水坑）时，将此值设置为 0.0。</li>
<li>Normal Fade：（法线衰减）当贴花的 AABB (Axis-Aligned Bounding Box, 轴对齐边界框)<code>与目标表面之间的角度变得过大时，贴花将会淡出。值为 ``0.0</code> 时，不管角度如何都会投影出贴花，而值为 0.999 时，贴花将仅限于几乎垂直的表面。由于额外的法线角度计算，将 Normal Fade 设置为大于 0.0 的值会带来一些性能损耗。</li>
</ul>
</li>
<li>垂直淡化（Vertical Fade）<ul>
<li>Upper Fade：（上部淡化）随着表面远离 AABB 中心（朝向贴花的投影角），贴花将逐渐淡出的曲线。 只有正值才有效。</li>
<li>Lower Fade：（下部淡化）随着表面远离 AABB 中心（远离贴花的投影角），贴花将逐渐淡出的曲线。 只有正值才有效。</li>
</ul>
</li>
<li>距离淡出<ul>
<li>Enabled（启用）：控制是否启用距离淡出（LOD 的一种形式）。 贴花将在 Begin + Length 内淡出，之后它将被剔除并且根本不会发送到着色器。 使用它可以减少场景中活动贴花的数量，从而提高性能。</li>
<li>Begin：（开始）贴花开始淡出时距相机的距离（以 3D 单位表示）。</li>
<li>Length：（长度）贴花淡出的距离（以 3D 单位表示）。 贴花在这段距离内逐渐变得透明，最后完全不可见。 值越高，淡出过渡越平滑，这在相机快速移动时更适合。</li>
</ul>
</li>
<li>Cull Mask（剔除遮罩）<ul>
<li>Cull Mask：（剔除遮罩）指定此贴花将投影到哪些 VisualInstance3D 图层。 默认情况下，贴花会影响所有图层。 使用它可以指定哪些类型的对象接收贴花，哪些类型不接收贴花。这个功能特别有用，你可以确保动态对象不会意外收到针对其下方地形的贴花。</li>
</ul>
</li>
</ul>
<p>贴花的渲染顺序<br>默认情况下，贴花的渲染顺序是基于他们的 AABB 和相机的距离排序的。<br>距离相机更近的AABB会优先被渲染，这意味着如果有些贴花处于相同的位置，那贴花的渲染顺序有时会随相机位置的变化而变化。<br>为解决贴花重叠导致的闪烁问题，你可以调整贴花 Node 检查器下的 VisualInstance3D 中的 Sorting Offset 属性。这个 offset 不是一个严格的优先级排序，而是一个<em>准则</em>，虽然渲染器会依据该准则决定渲染顺序，但贴花排序方式仍会受到 AABB 大小的影响。因此，offset 值更高的贴花<em>总是</em>会被绘制在 offset 值更低的贴花上。<br>如果你想让某个贴花总是渲染在其他贴花上，你需要将该贴花的<strong>Sorting Offset</strong>属性设置成正值，该值要大于可能与其重叠的其他最大贴花的AABB长度。相反，如果想让该贴花绘制在其他贴花后，将<strong>Sorting Offset</strong>设置为负值即可。</p>
<p>调整性能和质量<br>贴花渲染性能主要取决于其屏幕覆盖范围及其数量。<br>一般来说，覆盖大部分屏幕的一些大贴花的渲染消耗，会比散布在各处的许多小贴花的渲染消耗更高。<br>要提高渲染性能，你可以如上所述启用 Distance Fade 属性。<br>这将使远处的贴花在远离相机时淡出（并且可能对最终场景渲染几乎没有影响）。 使用节点组，你还可以根据用户配置防止生成非必要的装饰贴花。<br>贴花的渲染方式也会对性能产生影响。 渲染 &gt; 纹理 &gt; 贴花 &gt; 过滤 高级项目设置可让你控制如何过滤贴花纹理。 Nearest&#x2F;Linear 不使用 mipmap。 然而，贴花在远处看起来会有颗粒感。 Nearest&#x2F;Linear Mipmaps 在远处看起来会更平滑，但从倾斜角度观看时贴花会看起来模糊。 这可以通过使用 Nearest&#x2F;Linear Mipmaps Anisotropic 来解决，它提供最高的质量，但渲染速度也较慢。<br>如果你的项目具有像素艺术风格，请考虑将过滤设置为 Nearest 值之一（即具有 Nearest 属性的任意一个过滤），以便贴花使用最近邻过滤（nearest-neighbor filtering）。 否则，请继续使用 Linear 。</p>
<p>限制<br>贴图不能影响除上面列出的材质特性之外的材质特性，例如高度（用于视差贴图）。<br>出于性能方面的考虑，贴花使用的是完全固定的渲染逻辑，也就是说贴花无法使用自定义着色器。<br>然而，投影面上的自定义着色器能够读取被贴花覆盖的信息，例如表面的粗糙度和金属性。<br>使用 Forward+ 渲染器时，Godot 使用集群方法进行贴花渲染。可以添加任意数量的贴花（只要性能允许）。<br>但是，当前相机视图中可以存在的集群元素的默认上限仍为 512 个。<br>集群元素是指全向灯、聚光灯、贴花或反射探针。可以通过调整渲染 &gt; 限制 &gt; 集群构建器中的最大集群元素数高级项目设置来增加该上限。<br>在使用移动渲染器时，每个单独的 Mesh 资源 上只能应用 8 个贴花。如果有更多贴花影响单个网格，并非所有贴花都会在该 Mesh 上渲染。</p>
<h4 id="物理灯光和相机单位"><a href="#物理灯光和相机单位" class="headerlink" title="物理灯光和相机单位"></a>物理灯光和相机单位</h4><p>为什么使用物理灯光和相机单位？<br>Godot 对许多适用于光的物理属性（如颜色、能量、相机视野和曝光）使用任意单位（arbitrary units）。<br>默认情况下，这些属性使用任意单位，因为使用精确的物理单位会带来一些权衡，这对于许多游戏来说是不值得的。<br>由于 Godot 在默认情况下注重易用性，因此默认情况下禁用物理光单元。</p>
<p>物理单位的优点<br>如果你的目标是在项目中实现照片级真实感，那么使用现实世界的单位作为基础可以帮助你更轻松地进行调整。 有关现实世界材质、灯光和场景亮度的参考资料可以在 Physically Based 等网站上找到。<br>当从其他使用物理光单位（如 Blender）的 3D 软件移植场景时，在 Godot 中使用现实世界单位也会很有用。</p>
<p>物理单位的缺点<br>使用物理光单位的最大缺点是你必须密切注意在给定时间使用的动态范围。 将非常高的光强度与非常低的光强度混合时，可能会遇到浮点精度错误。<br>实际上，这意味着你必须手动管理曝光设置，以确保场景不会过度曝光或曝光不足。 自动曝光可以帮助你平衡场景中的光线，使其在正常范围内，但它无法恢复因动态范围过高而损失的精度。<br>使用物理光和相机单位不会自动使你的项目看起来 更好 。 有时，远离现实主义的表现实际上可以使场景在人眼看来更好。 此外，与非物理单位相比，使用物理单位需要更严格的要求。 只有正确设置物理单位以匹配现实世界的参考，才能获得使用物理单位的大多数好处。</p>
<p>备注<br>物理光单位仅在 3D 渲染中可用，在 2D 渲染中不可用。</p>
<p>设置物理灯光单元<br>物理光单位可以与物理相机单位分开启用。<br>要正确启用物理光单位，需要 4 个步骤：</p>
<ol>
<li>使用项目设置。</li>
<li>配置运行。</li>
<li>配置环境。</li>
<li>配置 Light3D 节点。</li>
</ol>
<p>由于物理光和相机单位仅需要少量计算来处理单位转换，因此启用它们不会对 CPU 产生任何明显的性能影响。 然而，在 GPU 方面，物理相机单元目前会强制使用景深。 这对性能有中等影响。 为了减轻这种性能影响，可以在高级项目设置中降低景深质量。</p>
<p>启用项目设置<br>打开项目设置，启用 高级设置 开关，然后启用 渲染&gt;灯光与阴影&gt;使用物理光线单位 。 重新启动编辑器。</p>
<p>配置相机<br>警告<br>当物理光单位启用时，如果你的场景中有一个 WorldEnvironment 节点（即编辑器环境被禁用），你 必须 将一个 CameraAttributes 资源分配给 WorldEnvironment 节点。 否则，如果你有可见的 DirectionalLight3D 节点，3D 编辑器视口将显得极其明亮。</p>
<p>在 Camera3D 节点上，你可以将 CameraAttributes 资源添加到其 Attributes 属性。 该资源用于控制相机的景深和曝光。 使用 CameraAttributesPhysical 时，其焦距属性也用于调整相机的视野（field of view）。<br>启用物理光单位后，CameraAttributesPhysical 的 Exposure 部分中将提供以下附加属性：<br>Aperture： （光圈）相机光圈的大小，以光圈值（f-stop）为单位测量。 光圈值是相机焦距与光圈直径之间的无单位比率。 高光圈设置将导致较小的光圈，从而导致图像更暗和焦点更清晰。 低光圈会导致大光圈，从而让更多的光线进入，从而产生更亮、聚焦度更低的图像。<br>Shutter Speed： （快门速度）快门打开和关闭的时间，以 倒数秒 (1&#x2F;N) 为单位测量。 较低的值将允许更多的光线进入，从而导致图像更亮，而较高的值将允许更少的光线进入，从而导致图像更暗。 当使用脚本获取或设置此属性时，单位为秒，而不是秒的倒数。<br>Sensitivity： （灵敏度）相机传感器的灵敏度，以 ISO 为单位测量。 灵敏度越高，图像越亮。 当启用自动曝光时，这可以用作曝光补偿的方法。 该值加倍将使曝光值（以 EV100 测量）增加 1 级。<br>Multiplier： （乘数） 非物理 曝光乘数。 较高的值将增加场景的亮度。 这可用于后期处理调整或制作动画目的。<br>默认 Aperture 值的16 光圈值适合白天户外使用（即与默认 DirectionalLight3D 一起使用）。 对于室内照明情况，2 到 4 之间的值更合适。<br>摄影和电影制作中使用的典型快门速度为 1&#x2F;50（0.02 秒）。 夜间摄影一般使用1&#x2F;10（0.1秒）左右的快门，而运动摄影则使用1&#x2F;250（0.004秒）至1&#x2F;1000（0.001秒）之间的快门速度以减少运动模糊。<br>在现实生活中，白天户外摄影根据天气情况，感光度通常设置在 50 ISO 到 400 ISO 之间。 较高的值则用于室内或夜间摄影。</p>
<p>备注<br>与现实生活中的相机不同，Godot 中不会模拟提高 ISO 感光度或降低快门速度（例如可见颗粒或灯光尾迹）后产生的不利影响。<br>请参阅 设置物理相机单位 以了解 CameraAttributesPhysical 属性的描述，这些属性在 不 使用物理光单位时也可用。</p>
<p>配置环境<br>警告<br>默认配置是针对白天户外场景设计的。 夜间和室内场景需要调整 DirectionalLight3D 和 WorldEnvironment 背景强度才能看起来正确。 否则，位置光源（即点光源）在默认强度下几乎不可见。<br>如果你尚未将 WorldEnvironment 和 Camera3D 节点添加到当前场景，请立即单击 3D 编辑器视口顶部的 3 个垂直点来添加。 单击 将太阳添加到场景 ，再次打开对话框，然后单击 将环境添加到场景 。<br>启用物理光单位后，可以在 Environment 资源中编辑一个新属性：<br>Background Intensity：（背景强度）背景天空的强度，单位为尼特（坎德拉每平方米）。 如果环境光和反射光各自的模式设置为 Background ，这也会影响它们。 如果设置了自定义 Background Energy ，则该能量将乘以强度。</p>
<p>配置灯光节点<br>在启用物理光单位后，Light3D 节点中有 2 个新属性可用：<br>Intensity：（强度）光的强度，单位为勒克斯(DirectionalLight3D) 或流明（OmniLight3D&#x2F;SpotLight3D） 。 如果设置了自定义 Energy ，则该能量将乘以强度。<br>Temperature： （色温）光的 色温 以开尔文（Kelvin）为单位定义。 如果设置了自定义 Color ，则该颜色将乘以色温。</p>
<p>OmniLight3D&#x2F;SpotLight3D 强度<br>流明是光通量的度量，是光源每单位时间发出的可见光总量。<br>对于 SpotLight3D，我们假设可见锥体外部的区域被完美的光吸收材料包围。 因此，锥体区域的表观亮度 不会 随着锥体尺寸的增大和减小而改变。<br>典型的家用灯泡的亮度范围约为 600 流明至 1200 流明。 一支蜡烛的亮度约为 13 流明，而一盏路灯的亮度约为 60000 流明。</p>
<p>DirectionalLight3D 强度<br>勒克斯是单位面积光通量的度量，等于每平方米一流明。 勒克斯是在给定时间内照射到表面的光量的度量。<br>使用 DirectionalLight3D 情况下，在晴朗的晴天，阳光直射下的表面可能会接收到大约 100000 勒克斯。 家中的一个典型房间可能接收到大约 50 勒克斯的亮度，而月光照射下的地面可能接收到大约 0.1 勒克斯的亮度。</p>
<p>色温<br>6500 开尔文是白色。 较高的值会导致较冷（偏蓝）的颜色，而较低的值会导致较暖（偏橙色）的颜色。<br>阴天的太阳的色温约为 6500 开尔文。 晴天时，太阳的色温在 5500 至 6000 开尔文之间。 在晴朗的日子里，当日出或日落时，太阳的色温约为 1850 开尔文。</p>
<p>色温图，从 1,000 开尔文（左）到 12,500 开尔文（右）<br>Energy 和 Color 等其他 Light3D 属性在出于制作动画目的以及偶尔需要创建具有非真实属性的灯光时仍可编辑。</p>
<p>设置物理相机单位<br>物理相机单位可以与物理光单位分开启用。<br>在将 CameraAttributesPhysical 资源添加到 Camera3D 节点的 Camera Attributes 属性后，FOV 等属性将不再可编辑。相反，现在这些属性由 CameraAttributesPhysical 的属性来控制，如焦距和光圈。<br>CameraAttributesPhysical 在其 Frustum（截锥体）部分提供以下属性：<br>Focus Distance：（焦距距离）相机到将处于焦点的物体的距离，以米为单位测量。内部将被限制为至少比 Focal Length 大 1 毫米。<br>Focal Length：（焦距）相机镜头与相机光圈之间的距离，以毫米为单位测量。控制视野和景深。较大的焦距将导致较小的视野和较窄的景深，意味着较少的物体会处于焦点。较小的焦距将导致较宽的视野和较大的景深，这意味着更多的物体会处于焦点。此属性会覆盖相机的 FOV 和 Keep Aspect 属性，使它们在检视器中为只读。<br>Near&#x2F;Far：以米为单位的近裁剪和远裁剪距离。这些与 Camera3D 具有同名属性的行为相同。较小的 Near 值允许相机显示非常近的物体，但可能会在远处出现精度（Z 冲突）问题。较大的 Far 值允许相机看到更远的距离，但可能会导致远处出现精度（Z 冲突）问题。<br>默认焦距 35 毫米对应广角镜头。与默认的 75 度 “实用 “垂直视场角相比，它仍然会导致视场角明显变窄。这是因为在电影制作和摄影等非游戏使用情况下，更倾向于使用较窄的视场角，以获得更具电影感的外观。</p>
<p>在电影制作和摄影中常用的焦距数值有：<br>鱼眼（超广角）：低于 15 毫米。几乎看不到景深。<br>广角：介于 15 毫米到 50 毫米之间。景深减小。<br>标准：介于 50 毫米到 100 毫米之间。标准景深。<br>长焦：大于 100 毫米。增加景深。</p>
<p>就像使用 保持高度（Keep Height）纵横比模式时一样，有效视场取决于视口的纵横比，较宽的纵横比将自动导致更宽的水平视场。</p>
<p>在Auto Exposure（自动曝光）部分，还可以根据相机的平均亮度级别启用自动曝光调节，具有以下属性：<br>最小灵敏度：相机可以达到的最暗亮度，以 EV100 为单位测量。<br>最大灵敏度：相机可以达到的最亮亮度，以 EV100 为单位测量。<br>速度：自动曝光效果的速度。影响相机执行自动曝光所需的时间。较高的值可以实现更快的过渡，但根据场景的不同，得到的调整可能会显得分散注意力。<br>比例：自动曝光效果的比例。影响自动曝光的强度。</p>
<p>EV100 是在 ISO 100 感光度下测量的曝光值（EV）。请参考此表获取在实际生活中常见的 EV100 值。</p>
<h4 id="粒子系统（3D）"><a href="#粒子系统（3D）" class="headerlink" title="粒子系统（3D）"></a>粒子系统（3D）</h4><p>在Godot中每个粒子系统由两个主要部分组成：粒子和发射器。<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/particle_nodes.webp"><br>有两种类型的三维粒子系统：</p>
<ol>
<li><code>GPUParticles3D</code><br>CPU 粒子系统相对不灵活，但适用于更广泛的硬件，为旧设备和手机提供更好的支持。<br>性能不如 GPU 粒子系统，并且无法渲染出尽可能多的单个粒子。此外，CPU 粒子系统目前不具备 GPU 粒子控制的所有可用选项。</li>
<li><code>CPUParticles3D</code><br>GPU粒子系统在GPU上运行，并且可以在现代硬件上渲染成十几万个粒子。你可以为其编写自定义粒子着色器，使其非常灵活。<br>还可以通过使用吸引子节点和碰撞节点，使它们与环境进行交互。</li>
</ol>
<p>有三种粒子吸引器节点：<br><code>GPUParticlesAttractorBox3D</code>、<code>GPUParticlesAttractorSphere3D</code> 和 <code>GPUParticlesAttractorVectorField3D</code>。<br>吸引器节点对其作用范围内的所有粒子施加力，并根据该力的方向将它们拉近或推开。</p>
<p>有几种粒子碰撞节点：<br><code>GPUParticlesCollisionBox3D</code> 和 <code>GPUParticlesCollisionSphere3D</code> 是较简单的节点。<br>用来创建基本形状，以便粒子与其碰撞。另外两个节点提供了更复杂的碰撞行为:<br><code>GPUParticlesCollisionSDF3D</code>室内场景与粒子发生碰撞，无需手动创建所有单独的盒子和球体碰撞器时。<br><code>GPUParticlesCollisionHeightField3D</code> 粒子与大型室外场景发生碰撞，会创建一个包含世界和其中对象的高度图，并将其用于大规模粒子碰撞。</p>
<p>创建 3D 粒子系统<br>添加 <code>GPUParticles3D</code> 节点设置两个参数:</p>
<ol>
<li><code>Process Material</code> 材质<br>ParticleProcessMaterial 是一种特殊的材质。<br>不是用于绘制对象，是在 GPU 上更新粒子数据和行为，而不是 CPU，这可以带来巨大的性能提升。<br>单击新添加的材质会显示一个长长的属性列表，可以设置这些属性来控制粒子的行为。</li>
<li><code>Draw Pass</code> 绘制通道<br>选择新建 QuadMesh 并将其 Size 的 x 和 y 设为 0.1<br>每个粒子系统最多可以使用 4 个绘制通道，每个通道可以渲染一个不同的网格，并使用自己独特的材质。<br>所有绘制通道都使用由处理材质计算的数据，这是一种用于组合复杂效果的高效方法：一次计算粒子的行为，然后将其提供给多个渲染通道。</li>
</ol>
<p>要在不支持现代图形 API 的较旧设备上发布游戏时，可能有必要将 GPU 粒子转换为 CPU 粒子。<br>在转换过程中失去的一些显著特性包括：多重绘制通道，湍流，子发射器，尾迹，吸引器，碰撞。<br>还会丢失以下属性：<br>数量比（Amount Ratio）<br>插值至结尾（Interp to End）<br>阻尼作为摩擦（Damping as Friction）<br>发射形状偏移（Emission Shape Offset）<br>发射形状缩放（Emission Shape Scale）<br>继承速度比（Inherit Velocity Ratio）<br>速度轴心（Velocity Pivot）<br>方向速度（Directional Velocity）<br>径向速度（Radial Velocity）<br>速度限制（Velocity Limit）<br>随速度缩放（Scale Over Velocity）</p>
<p>3D 粒子系统属性</p>
<ol>
<li>发射器属性<ul>
<li>Emitting 用于激活和停用粒子系统。</li>
<li>Amount 属性控制着在任何时间下可见粒子的最大数量。</li>
<li>Amount Ratio 属性是粒子与要射出的粒子数量的比例。<br>  小于 1.0，则生命周期内发射的粒子数量将为 Ammount * Amount Ratio。<br>  对于制作发射粒子的数量随时间变化的效果来说这个属性很有用。</li>
<li>Sub Emitter<br>  可以将另一个粒子节点设置为子发射器，它将作为每个粒子的子节点生成。<br>  有关如何将子发射器添加到粒子系统的详细说明，请参阅本手册中的子发射器部分。</li>
</ul>
</li>
<li>时间属性(Time)<ul>
<li>Lifetime 属性控制每个粒子存在时间长短，秒为单位。<br>  许多粒子属性都可以在粒子生命周期内设置而变化，从一个值平滑过渡到另一个值。<br>  Lifetime 和 Amount 是相联的，决定粒子发射速率：每秒粒子数 &#x3D; Amount &#x2F; Lifetime</li>
<li>Interp to End 属性会使节点中的所有粒子在其生命周期结束时进行插值。</li>
<li>One Shot 将会发射 amount 数量的粒子，然后自行禁用，会仅运行一次。<br>  一次性粒子非常适合用于单个事件做出反应的特效，例如，物品拾取或子弹击中墙壁时迸发出的碎片。</li>
<li>Preprocess 如果值为 1 ，则粒子系统开始运行时，将看起来已经运行了一秒钟。用于跳过 “装载” 时间。</li>
<li>Speed Scale 属性来减慢或加快粒子系统的移动速度速度。</li>
<li>Explosiveness 属性控制粒子是顺序发射还是同时发射。值为 0 表示粒子一个接一个地发射。值为 1 表示所有 amount 粒子同时发射，从而使效果看起来更具爆炸性。</li>
<li>Randomness 属性为粒子发射时间添加随机性。当 Explosiveness 设置为 1 时，该属性无效。</li>
<li>Fixed FPS 属性限制了粒子系统的处理频率，包括属性更新以及碰撞和吸引器。这可以有效提高性能，特别是在大量使用粒子碰撞的场景中。</li>
<li>Interpolate 属性会在更新之间混合粒子属性，因此即使粒子系统以 10 FPS运行，看起来也像是 60 FPS运行一样平滑。<blockquote>
<p>使用 粒子碰撞 时，如果粒子移动速度快且碰撞器较薄，则可能会发生隧道效应。这可以通过增加固定 FPS（以性能为代价）来解决。</p>
</blockquote>
</li>
</ul>
</li>
<li>碰撞属性(Collision)<ul>
<li>Base Size 属性定义了每个粒子的默认碰撞大小，用于检查粒子当前是否与环境发生碰撞。<br>  通常希望这个大小与粒子的大小大致相同。对于非常小且移动非常快的粒子，增加此值可以防止其穿过碰撞几何体。</li>
</ul>
</li>
</ol>
<blockquote>
<p>设置粒子碰撞需要按照《3D粒子碰撞》中描述的进一步步骤进行。</p>
<ol start="4">
<li>绘制属性(Drawing)<ul>
<li>Visibility AABB 属性定义了一个围绕粒子系统原点的盒子。<br>  只要这个盒子的任意部分在相机的视野内，粒子系统就是可见的，一旦离开相机视野，粒子系统将停止渲染，可以尽可能使盒子较小来提高性能。</li>
<li>Local Coords 所有粒子计算都使用局部坐标系来确定诸如上下、重力和运动方向等。<br>  例如，上下会跟随粒子系统或其父节点而旋转。当未选中该属性时，这些计算将使用全局世界空间：在世界空间中，向下始终为 -Y ，不跟随粒子系统旋转。</li>
<li>Draw Order 属性控制着单个粒子绘制时的顺序。<ul>
<li>Index 代表以发射顺序绘制：即后生成的粒子会绘制在先生成的粒子的顶层。</li>
<li>Lifetime 代表以剩余生命周期顺序绘制。Reverse Lifetime 则是反转了 Lifetime 的绘制顺序。</li>
<li>View Depth 代表以与摄像机的距离顺序绘制：距离摄像机更近的粒子绘制在更远的粒子顶层。</li>
</ul>
</li>
<li>Transform Align 属性控制粒子的默认旋转。<ul>
<li>Disabled 意味着它们不以任何特定的方式对齐，相反，它们的旋转由处理材质设置的值决定。</li>
<li>Z-Billboard 表示粒子将始终面向相机，类似于 Standard Material 的 Billboard 属性。</li>
<li>Y to Velocity 表示每个粒子的 Y 轴与其移动方向对齐，这对于子弹或箭矢之类的物体很有帮助，因为你希望粒子一直指向“前方”。</li>
<li>Z-Billboard + Y to Velocity 结合了前两种模式。每个粒子的 Z 轴将指向相机，而Y 轴与速度对齐。</li>
</ul>
</li>
</ul>
</li>
<li>尾迹属性(Trail)<ul>
<li>Enabled 属性控制粒子是否渲染为尾迹。</li>
<li>Length Secs 属性控制尾迹应该被发射多长。该持续时间越长，尾迹就会越长。</li>
</ul>
</li>
<li>处理材质属性(Process Material)<ul>
<li>Lifetime Randomness 属性控制应用于每个粒子生命周期的随机性程度。</li>
<li>粒子标志(Particle Flags)<ul>
<li>Align Y 属性将每个粒子的 Y 轴与其速度对齐，与 <code>Transform Align</code> 属性设置为 Y to Velocity 相同。</li>
<li>Rotate Y 属性与 Angle 和 Angular Velocity 组中的属性配合使用，以控制粒子旋转。如果要对粒子应用任何旋转，则必须启用 Rotate Y。<br>  例外情况是使用Standard Material 的任何粒子，其中 Billboard 属性设置为 Particle Billboard。没启用 Rotate Y，粒子也会旋转。</li>
<li>Disable Z 属性时，粒子将不会沿 Z 轴移动。将使用局部 Z 轴还是世界 Z 轴由 局部坐标 属性确定。</li>
<li>Daming as Friction 属性将阻尼行为从恒定减速度更改为基于速度的减速度。</li>
</ul>
</li>
<li>出生(Spawn)<ul>
<li>位置(Position)<ul>
<li>发射形状(Emission Shape) 粒子可以从空间中的单个点发射，也可以以填充形状的方式发射。</li>
</ul>
</li>
<li>角度(Angle)<ul>
<li>Angle 属性控制粒子的起始旋转。必须启用以下两个属性之一：Rotate Y 使粒子围绕粒子系统的 Y 轴旋转。<br>  在 标准材质 中的 Billboard 属性，如果设置为 Particle Billboard ，则使粒子围绕从粒子指向相机的轴旋转。</li>
</ul>
</li>
<li>速度(Velocity)<ul>
<li>Initial Velocity Ratio 粒子初始速度的百分比。</li>
<li>Velocity Pivot 粒子的旋转轴。</li>
<li>方向(Direction) 设置速度或加速度属性后生效。</li>
<li>Spread 属性为每个粒子的方向添加了一些变化和随机性。值越高，偏离原始路径的程度就越强。</li>
<li>Flatness 属性限制沿 Y 轴的扩散。0 的值表示没有限制，1 的值将消除沿 Y 轴的所有粒子移动。粒子将完全“水平”的地展开。</li>
<li>Initial Velocity 属性控制粒子的初始速度。分为 Velocity Min 和 Velocity Max ，两者默认均设置为 0 ，这就是你最初看不到任何移动的原因。一旦你为这些属性中的任何一个设置了值 如上所述，粒子就开始移动了。方向会被这些值乘以，因此，通过设置负速度，你可以使粒子向相反方向移动。</li>
</ul>
</li>
</ul>
</li>
<li>动画速度(Animation Speed)<ul>
<li>角速度(Angular Velocity) 控制粒子的旋转速度，如上文所述 。你可以通过使用 Velocity Min 或 Velocity Max 的负数值来反转方向。像 Angle 属性一样，只有当设置了 Rotate Y 位标记或在 Standard Material 中选择了 Particle Billboard 模式时，旋转才会可见。<blockquote>
<p>Damping 属性对角速度没有影响。</p>
</blockquote>
</li>
</ul>
</li>
<li>加速度(Acceleration)<ul>
<li>重力(Gravity)<br>  接下来的几个属性分组紧密协作，控制粒子的运动和旋转。Gravity 将粒子向其所指的方向拉动，默认情况下是直接向下，强度等于地球的重力。重力影响所有粒子的运动。如果你的游戏使用物理，并且世界的重力可以在运行时更改，你可以使用这个属性来保持游戏的重力与粒子重力同步。如果未设置其他运动属性，Gravity 值 (X&#x3D;0,Y&#x3D;0,Z&#x3D;0) 意味着没有粒子将永远移动。</li>
<li>线性加速度(Linear Accel)<br>  粒子的速度是一个恒定值：一旦设置，它就不会改变，粒子将始终以相同的速度移动。你可以使用 Linear Accel 属性来改变粒子生命周期中的移动速度， 如上文所述 。正值将加快粒子速度，使其移动得更快。负值将减慢其速度，直至停止并开始向反方向移动。<br>  我们必须牢记，当我们改变加速度时，我们并不是直接改变速度，我们改变的是速度的 变化 。加速度曲线上的 0 值并不会停止粒子的运动，它会停止粒子运动的变化。在那一刻，无论它的速度是多少，它将保持那个速度继续移动，直到加速度再次改变。</li>
<li>径向加速度(Radial Accel)<br>  为所有粒子添加了类似重力的力，该力的起源位于粒子系统当前位置。负值使粒子向中心移动，就像行星对其轨道上物体的重力一样。正值使粒子远离中心。</li>
<li>切向加速度(Tangential Accel)<br>  这个属性在粒子系统XZ平面上的圆的切线方向上添加了粒子加速度，该圆的原点位于粒子系统的中心，半径是每个粒子当前位置与系统中心的距离投影到该平面上。<br>  圆的切线是与圆 “接触 ”的直线，在接触点与圆的半径成直角。粒子系统XZ平面上的圆是你从上方直接向下看粒子系统时所看到的圆。<br>  始终限制在该平面内，并且不会沿系统的Y轴移动粒子。一个粒子的位置足以定义这样一个圆，如果我们忽略向量的Y分量，到系统中心的距离就是半径。<br>  将使粒子围绕粒子系统的中心轨道运动，但半径会不断增加。从上方看，粒子将从中心向外螺旋移动。负值会反转方向。</li>
<li>阻尼(Dampin)<br>  逐渐停止所有运动。除非总加速度大于阻尼效果粒子将继续减速直到完全不动。值越大，将粒子完全停止所需的时间就越少。</li>
<li>吸引器相互作用(Attractor Interaction)<br>  如果你想让粒子系统与 particle attractors 互动，你必须勾选 Enabled 属性。当它被禁用时，粒子系统会忽略所有的粒子吸引器。</li>
</ul>
</li>
<li>显示(Display)<ul>
<li>缩放(Scale) 控制粒子的大小。你可以为 Scale Min 和 Scale Max 设置不同的值，以随机化每个粒子的大小。<br>  不允许负值，所以你无法用这个属性翻转粒子。<br>  如果你将粒子作为公告板发射，你的绘制阶段中的 Standard Material 的 Keep Size 属性必须启用，缩放才能生效。</li>
<li>颜色曲线(Color Curves) 控制粒子的初始颜色。只有在 Material 的 Vertex Color 的 Use As Albedo 属性启用后生效。<br>  这个属性与来自粒子材质自己的 Color 或 Texture 属性的颜色相乘。<ul>
<li>Color Ramp 属性在粒子的生命周期内改变粒子的颜色。会遍历定义的所有颜色范围。</li>
<li>Color Initial Ramp 属性从颜色坡道上的随机位置选择粒子的初始颜色。</li>
<li>Alpha Curve 属性控制粒子的透明度。</li>
<li>Emission Curve 颜色曲线控制粒子的初始颜色。</li>
</ul>
</li>
<li>色相变化(Hue Variation)<br>  像 Color 属性一样控制粒子的颜色，但是方式不同。它不是直接设置颜色值，而是通过改变颜色的色相来实现。无法体现颜色有多亮或有多饱和。<br>  将其设为较高的值会导致颜色变化更加剧烈，而较低的值则限制可用颜色为原始的最近邻颜色。</li>
<li>动画(Animation)<br>  控制粒子的标准材质中精灵表动画的行为。</li>
</ul>
</li>
<li>湍流(Turblence) 湍流为粒子运动添加了噪声，能够创造出生动有趣的图案。可以用来控制运动速度、噪声图案以及对粒子系统的总体影响。<br>  你可以在粒子湍流章节找到这些属性的详细解释。</li>
<li>碰撞(Collision) Mode 属性控制发射器如何以及是否与粒子碰撞节点发生碰撞。<ul>
<li>Disabled 以禁用此粒子系统的任何碰撞。</li>
<li>Hide On Contact ，粒子在碰撞时会立即消失。</li>
<li>Constant ，粒子碰撞后会反弹。你会在检查器中看到两个新属性。它们控制粒子在碰撞事件期间的行为。<br>  较高的 摩擦 值会减少沿表面的滑动。这在粒子与倾斜表面碰撞时特别有用，如果你希望它们保持在原地而不是滑到底部，比如雪花落在山上。<br>  较高的 反弹 值会使粒子在与表面碰撞时像橡胶球一样反弹。<br>  如果启用了 Use Scale 属性，碰撞基础大小 将乘以粒子的 当前缩放 。你可以使用这个属性来确保渲染大小和碰撞大小对于随机缩放或随时间变化的粒子相匹配。</li>
</ul>
</li>
<li>子发射器(Sub Emitter) Mode 属性控制子发射器如何以及何时生成。<ul>
<li>Disabled，则永远不会生成子发射器。</li>
<li>Constant ，子发射器会以恒定的速率持续生成。</li>
<li>Frequency 属性控制一秒钟内发生的次数。将模式设置为 At End ，子发射器将在父粒子生命周期结束时生成，正好在它被销毁之前。Amount At End 属性控制将生成多少个子发射器。</li>
<li>At Collision ，粒子与环境碰撞时子发射器会生成。</li>
<li>Amount At Collision 属性控制将生成多少个子发射器。</li>
<li>当启用了保持速度(Keep Velocity)属性时，新生成的子发射器一开始就具有父粒子在子发射器创建时的速度。</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
<p><img src="https://wzcwzc10.github.io/posts_img/godot/06/particle_sprite_smoke.webp" alt="8x8 动画烟雾精灵表"></p>
<ol>
<li>设置具有至少一次绘制过程的粒子系统，并为该绘制过程中的网格分配一个 Standard Material。</li>
<li>将精灵表指定给 Albedo 中的 Texture 属性</li>
<li>将材质的 Billboard 属性设置为 Particle Billboard。这样就可以用材质中的 Particles Anim 分组了。</li>
<li>将 H Frames 设置为精灵表中的列数，将 V Frames 设置为精灵表中的行数。</li>
<li>如果你希望动画持续重复，请勾选 Loop。</li>
<li>处理材质属性(Process Material)中Animation 属性的 Speed 属性控制精灵表动画的速度。<br> 将 Speed Min 和 Speed Max 都设置为 1 ，你应该能看到动画播放了。Offset 属性控制新生成的粒子动画的起始位置。<br> 默认情况下，它总是序列中的第一张图片。你可以通过改变 Offset Min 和 Offset Max 来增加一些变化，以随机化起始位置。<br>三个不同的粒子系统使用相同的烟雾精灵表<br>根据精灵表包含的图像数量以及粒子的存活时间情况，你的动画可能看起来会并不流畅。<br>粒子的存活时间、动画速度和精灵表中图像数量之间的关系是这样的：<blockquote>
<p>当动画速度为 1.0 时，动画将在粒子生命周期结束时，播放到序列中的最后一个图像。<br>如果你的精灵表包含 64 (8x8) 个图像，并且粒子的生命周期设置为 1 秒，则动画在 64 FPS （1 秒 &#x2F; 64 个图像）下将非常流畅。<br>如果将生命周期设置为 2 秒，则在 32 FPS 下仍将相当流畅。但是，如果粒子存活 8 秒，则在 8 FPS 下动画将明显卡顿。<br>为了使动画再次流畅，你需要将动画速度增加到 3 之类的速度以达到可接受的帧速率。<br>请注意，GPUParticles3D 节点的 Fixed FPS 也会影响动画播放。<br>为了动画播放流畅，建议将其设置为 0，以便在每个渲染帧上模拟粒子。<br>如果这个设置不适合你的用例，请将 Fixed FPS 设置为等于翻页动画使用的有效帧速率（请参阅上面的公式）。</p>
</blockquote>
</li>
</ol>
<p>粒子子发射器</p>
<ol>
<li>创建一个粒子系统，并将其分配给子发射器。<br>找到父级上的 Sub Emitter 属性，然后点击旁边的框，分配子发射器。<br>实例化场景中的粒子系统也可以设置为子发射器，只要在实例化场景中启用了 Editable Children 属性即可。<br>反之亦然：你可以将子发射器分配给实例化场景中的粒子系统，即使是来自其他实例化场景的粒子系统。</li>
<li>发射器模式<br>当你分配子发射器时，你不会立即看到它生成。默认情况下，发射处于禁用状态，需要先启用。<br>将 ParticleProcessMaterial 的 Sub Emitter 分组中的 Mode 属性设置为 Disabled 以外的其他属性。<br>发射器模式还决定产生多少个子发射器粒子。<br>Constant 以 Frequency 属性设置的频率生成单个粒子。<br>对于 At End 和 At Collision ，你可以直接使用 Amount At End 和 Amount At Collision 属性设置发射量。</li>
<li>限制<br>要记住的一件事是，来自子发射器的活动粒子总数始终受到子发射器粒子系统上的 Amount 属性的限制。如果你发现从子发射器生成的粒子数量不足，则可能需要增加粒子系统中的数量。当粒子系统作为子发射器生成时，某些发射器属性将被忽略。例如，Explosiveness 属性不起作用。根据发射器模式的不同，粒子要么以固定的间隔依次生成，要么一次爆炸性全部生成。</li>
</ol>
<p>3D 粒子尾迹<br>Godot 提供了几种类型的尾迹，你可以将其添加到粒子系统中。<br>在使用尾迹之前，你需要先设置几个参数：</p>
<ol>
<li>创建一个新的粒子系统并分配一个如前所述的处理材质。</li>
<li>勾选粒子系统的 Trails ，并将 Lifetime 设置为 0.8 来增加自发光持续时间。</li>
<li>在处理材质上，将 Direction 设置为 (X&#x3D;0,Y&#x3D;1.0,Z&#x3D;0) ，并将其 Initial Velocity 设置为 10.0。</li>
<li>唯一仍然缺少的是绘制阶段的网格。你在此处设置的网格类型控制你最终将获得哪种类型的粒子尾迹。</li>
</ol>
<p>带状尾迹<br>最简单的粒子尾迹类型是带状尾迹。</p>
<ol>
<li>导航到 Draw Passes 部分，然后从 Pass 1 选项中选择 新建RibbonTrailMesh。</li>
<li>为 Material 属性分配一个新的 Standard Material，并在 Transform 属性中启用 Use Particle Trails。</li>
<li>带状网格 Shape 参数有两个选项。Cross 会创建两个垂直的四边形，使粒子尾迹更加三维。<br> 只有当你不在 Particle Billboard 模式下绘制尾迹时，这才有意义，并且在从不同角度查看粒子时会有所帮助。<br> Flat 选项将网格限制为单个四边形，最适合公告板粒子。</li>
<li>Size 参数控制尾迹的宽度。用它来使尾迹更宽或更窄。</li>
<li>Sections、Section Length 和 Section Segments 共同用于控制粒子尾迹的平滑程度。当粒子尾迹不沿直线行进时，它所具有的节越多，它在弯曲和旋转时看起来就越平滑。Section Length 控制每个节的长度。将该值乘以节数即可知道该尾迹的总长度。</li>
<li>Section Segments 参数进一步将每个部分细分为段。不过，它对尾迹部分的平滑度没有影响。相反，它控制粒子尾迹整体形状的平滑度。Curve 属性定义此形状。点击“曲线”旁边的框，然后指定或创建新曲线。尾迹的形状将与曲线一样，曲线的值在尾迹的头部为 1.0 ，曲线的值在尾部为 1.0。<br>由不同曲线形成的粒子尾迹。尾迹从左向右移动。<br>根据曲线的复杂程度，当部分数较少时，粒子尾迹的形状看起来不会非常平滑。这就是 Section Segments 属性的用武之地。增加节段的数量会在尾迹的两侧添加更多折点，以便它可以更紧密地跟随曲线。<br>颗粒尾迹形状平滑度：每节 1 段（顶部），每节 12 段（底部）<br>管状尾迹<br>管状尾迹与带状尾迹共享许多属性。它们之间的最大区别在于管状轨迹发出圆柱形网格而不是四边形。<br>管状尾迹发出圆柱形粒子<br>要创建管状尾迹，请导航到 Draw Passes 部分，然后从 Pass 1 选项中选择 New TubeTrailMesh。一个 TubeTrailMesh 是一个圆柱体，它被分成几个部分，然后沿着这些部分拉伸和重复。为 Material 属性分配一个新的 Standard Material，并在 Transform 属性分组中启用 Use Particle Trails。粒子现在应该以长圆柱形轨迹发射。<br>关键管状网格参数<br>Radius 和 Radial Steps 属性之于管状尾迹，就像 Size 之于带状尾迹一样。Radius 定义管的半径，并增加或减少其整体尺寸。Radial Steps 控制管圆周周围的边数。较高的值会提高管盖部的分辨率。<br>Sections 和 Section Length 对于管状尾迹和带状尾迹的工作方式相同。它们控制管道轨迹在弯曲和扭曲而不是沿直线移动时看起来有多平滑。增加节的数量将使其看起来更平滑。更改 Section Length 属性可更改每个节的长度以及轨迹的总长度。Section Rings 是带状尾迹的 Section Segments 属性的管状尾迹等效项。它细分了小节，并为管添加了更多的几何形状，以更好地适应 Curve 属性中定义的自定义形状。<br>你可以用曲线塑造管状尾迹，就像塑造带状尾迹一样。点击 Curve 属性旁边的框，然后指定或创建新曲线。尾迹的形状与曲线相似，曲线的值在尾迹的头部为 0.0 ，曲线的值在尾迹尾部为 1.0。<br>具有自定义曲线形状的粒子管状尾迹：4 条管盖边、3 个小节、1 个截面环（左），12 条管盖边、9 个小节、3 个截面环（右）<br>你可能想要设置的一个重要属性是粒子系统的 Drawing 分组中的 Transform Align。如果保持原样，管子将无法保持体积;它们在移动时变平，因为即使它们改变方向，它们的 Y 轴也会一直指向上方。这可能会导致大量渲染伪影。将属性设置为 Y to Velocity ，每个粒子尾迹都沿其运动方向保持其 Y 轴对齐。</li>
</ol>
<p>粒子湍流<br>湍流使用噪点纹理为粒子运动添加变化和有趣的图案。<br>可以与粒子吸引器和碰撞节点结合使用，以创建看起来更加复杂的行为。</p>
<ul>
<li>Noise Strength 属性控制图案的对比度，这会影响整体湍流清晰度。<br>  较低的值会创建一个更柔和的模式，其中单个粒子移动路径不会与另一个移动路径明显分开。将此值设置为更高的数字以使这个模式下更加清晰。</li>
<li>Noise Scale 属性控制模式的频率。它基本上改变了噪点纹理的UV标度，其中较小的值会产生更精细的细节，但重复的图案会更快地变得明显。较大的值会导致整体湍流模式较弱，但在重复开始成为问题之前，粒子系统可以覆盖更大的区域。</li>
<li>Noise Speed 属性采用向量并控制噪点平移速度和方向。这允许你随时间移动噪点图案，从而为粒子系统添加另一层移动变化。</li>
<li>Noise Speed Random 属性为噪点平移速度增加了一些随机性。这有助于打破可预见的模式，尤其是在较高的平移速度下，当重复变得明显时。</li>
<li>用 Influence Min 设置最小值，使用 Influence Max 设置最大值。<br>  当粒子生成时，影响是从这个范围内随机选择的。你还可以使用 Influence Over Life 属性设置一条曲线，每个粒子的生命周期内依照该曲线修改影响值。<br>  这三个属性共同控制着湍流对粒子系统的影响强度 as described before 。</li>
<li>使用 Initial Displacement Min 设置下限，使用 Initial Displacement Max 设置上限。当粒子生成时，从该范围内随机选择位移量并乘以随机方向。</li>
</ul>
<p>3D 粒子吸引子<br>吸引器有三种类型：</p>
<ol>
<li>GPUParticlesAttractorBox3D 盒型吸引器</li>
<li>GPUParticlesAttractorSphere3D 球型吸引器</li>
<li>GPUParticlesAttractorVectorField3D 向量场吸引器<br>在 ParticleProcessMaterial 上启用 Attractor Interaction 属性。对每个需要对吸引器做出反应的粒子系统执行该操作。<br>检查器中的 GPUParticlesAttractor3D 属性:</li>
</ol>
<ul>
<li>强度（Strength）控制吸引器的强度。正值将粒子拉近吸引器中心，而负值则将它们推开。</li>
<li>衰减（Attenuation）控制着吸引器影响区域内的强度衰减。每个粒子吸引器都有一个边界。它的强度在边界的边界处最弱，在中心处最强。边界外的粒子完全不受吸引器的影响。衰减曲线控制强度在这段距离上的减弱方式。直线表示强度与距离成正比：如果粒子位于边界和中心的中间，则吸引器的强度将是中心强度的一半。不同的曲线形状会改变粒子向吸引器加速的速度。</li>
<li>(Directionality) 属性可改变粒子被拉动的方向。值为 0.0 时，没有方向性，这意味着粒子被拉向吸引器的中心。值为 1.0 时，吸引器是完全定向的，这意味着粒子将沿着吸引器的局部 -Z 轴被拉动。你可以通过旋转吸引器来更改全局方向。如果 Strength 为负，则粒子将沿着 +Z 轴被拉动。<br>无方向性（左）与全方向性（右）。注意粒子如何沿着吸引子的局部Z轴运动。</li>
<li>Cull Mask 属性根据每个系统的 visibility layer 控制哪些粒子系统会受到吸引器的影响。仅当在吸引器的剔除遮罩中启用了至少一个系统的可见性层时，粒子系统才会受到吸引器的影响。</li>
</ul>
<p>3D粒子碰撞<br>粒子碰撞节点共有四种：</p>
<ol>
<li>GPUParticlesCollisionBox3D</li>
<li>GPUParticlesCollisionSphere3D</li>
<li>GPUParticlesCollisionSDF3D</li>
<li>GPUParticlesCollisionHeightField3D<br>通用属性<br>位于检查器的 GPUParticlesCollision3D 区域中。<br>Cull Mask 属性根据每个系统的 visibility layers 控制哪些粒子系统会受到碰撞节点的影响。<br>仅当碰撞器的剔除遮罩中至少启用了一个系统的可见性层时，粒子系统才会与碰撞节点发生碰撞。</li>
</ol>
<ul>
<li>盒型碰撞</li>
<li>球型碰撞</li>
<li>高度场碰撞</li>
<li>带符号距离场（SDF）碰撞<br>故障排除<br>为了使粒子碰撞起作用，粒子的可见性 AABB 必须与碰撞器的 AABB 重叠。如果尽管设置了碰撞器，但碰撞似乎不起作用，请通过选择 GPUParticles3D 节点并在 3D 编辑器视口顶部选择 GPUParticles3D &gt; 生成可见性 AABB… 来生成更新后的可见性 AABB。<br>如果粒子移动得很快而碰撞体很薄，有两种解决方案:</li>
</ul>
<ol>
<li>让碰撞体变得更厚。例如，如果粒子不能穿过一个坚实的地面，你可以让代表地面的碰撞体比其实际的视觉表现更厚。<br>高度图碰撞体（heightfield collider）在设计上自动处理这种情况，因为高度图无法表示“房间之上还有房间”的碰撞情况。</li>
<li>增大 GPUParticles3D 节点中 Fixed FPS 的值，以增加粒子碰撞检测的频率。这会产生性能影响，所以应避免设置过大的值。</li>
</ol>
<p>复杂发射形状<br>Godot 提供了一种根据任意复杂形状发射粒子的方法。<br>这些形状由场景中的网格生成，并作为纹理存储在粒子处理材质中。<br>这是一种用途非常广泛的工作流程，用户可以将粒子系统用于传统用法之外的用途，如树叶或复杂的全息效果。</p>
<ol>
<li>创建一个粒子系统。添加一个网格实例作为粒子发射点的源。</li>
<li>选中粒子系统后，导航到视口菜单并选择 GPUParticles3D 条目。从那里，选择从节点创建发射点。</li>
<li>此时会弹出一个对话窗口，要求你选择一个节点作为发射源。选择场景中的一个网格实例并确认选择。下一个对话窗口将处理点的数量以及如何生成这些点。</li>
<li>发射点 Emission Points 控制将要生成的点的总数。粒子将从这些点中生成，因此在这里输入的内容取决于源网格的大小（需要覆盖的面积）和所需的粒子密度。<br>Emission Source 为点的生成方式提供了 3 种不同的选项：</li>
<li>如果只想在网格表面上分布发射点，请选择 表面点（Surface Points）。</li>
<li>如果还想生成有关曲面法线的信息，并使粒子沿法线指向的方向移动，请选择此选项 Surface Points + Normal (Directed) 。</li>
<li>最后一个选项“ 体积”（Volume）在网格体内部的任何地方创建发射点，而不仅仅是在其表面上。<br>发射点存储在粒子系统的本地坐标系中，因此你可以移动粒子节点，发射点也会跟着移动。<br>当你想在多个不同的地方使用同一个粒子系统时，这可能会很有用。另一方面，当你移动粒子系统或源网格时，可能需要重新生成发射点。</li>
</ol>
<p>发射形状纹理<br>可用的发射形状纹理<br>复杂粒子发射形状的所有数据都存储在一组纹理中。具体数量取决于所使用的发射形状类型。如果将粒子处理材质上发射形状（Emission Shape）组中的形状（Shape）属性设置为点（Points），则可以访问 2 个纹理属性，即点纹理（Point Texture）和颜色纹理（Color Texture）。将其设置为定向点（Directed Points），则还有第三个属性，称为法线纹理（Normal Texture）。<br>点纹理<code>Point Texture</code>属性涵盖了上一步可能生成的所有发射点。每个粒子生成时都会随机选择一个点。如果存在法线纹理<code>Normal Texture</code>属性，它会在点位置提供一个方向向量。如果还设置了颜色纹理<code>Color Texture</code> 属性，它会在点位置进行采样，调和处理材质上设置的其他颜色，为粒子提供颜色。<br>你还可以通过调用点计数<code>Point Count</code>属性，在创建发射形状后随时更改发射点的数量。这包括在游戏运行时动态更改点数量。</p>
<h4 id="高动态范围光照"><a href="#高动态范围光照" class="headerlink" title="高动态范围光照"></a>高动态范围光照</h4><p>那么，所有”HDR”业务在什么时候发挥作用？要理解答案，我们需要查看显示器的行为.<br>你的显示器输出线性光比率从某个最大强度到某个最小强度.<br>现代游戏引擎在各自的场景中对线性光值进行复杂的数学计算. 这将会有什么问题呢？<br>根据显示器类型的不同，显示的强度范围有限.<br>然而，游戏引擎渲染的强度值范围没有限制.<br>虽然 “最大强度” 对sRGB显示器来说有一定的意义，但在游戏引擎中却没有任何影响；每帧渲染时可能产生无限宽的强度值范围.</p>
<p>这意味着场景光强，也称为场景对应（scene-referred）的光照比率，需要进行转换和映射以适应所选显示器的特定输出范围。<br>这就类似通过虚拟摄像机拍摄我们的游戏引擎场景，在这里，我们的虚拟摄像机将对场景数据应用特定的摄像机渲染变换，其输出将以特定的显示类型显示。</p>
<blockquote>
<p>Godot目前尚不支持高动态范围 输出. 它只能在HDR中执行照明，并将结果映射为低动态范围的图像.<br>对于高级用户来说，仍然可以得到一个非色调映射的视图图像与完整的HDR数据，然后可以保存到一个OpenEXR文件.</p>
</blockquote>
<p>计算机显示器<br>几乎所有显示器都需要对发送给它们的代码值进行非线性编码.<br>显示器又利用其独特的传输特性，将代码值 “解码” 为输出的线性光比，并在每个红色，绿色和蓝色发射点的独特颜色的光中投射出这些比值.<br>对于大多数计算机显示器来说，显示器的规格是根据 IEC 61966-2-1，即 1996 年的 sRGB 规格，进行概述的。该规范概述了 sRGB 显示器的性能，包括 LED 像素中的灯光颜色以及输入（OETF）和输出（EOTF）的传输特性。<br>并非所有显示器都使用与计算机显示器相同的OETF和EOTF. 例如，电视广播显示器使用BT.1886 EOTF. 然而,Godot目前只支持sRGB显示器.<br>sRGB标准是围绕着常见的桌面计算CRT显示器的电流与光输出之间的非线性关系而制定的.<br>场景参考模型的数学要求我们将场景乘以不同的值，以调整不同光照范围的强度和曝光.<br>显示器简单的传递函数不能恰当地渲染游戏从引擎场景中输出的更大动态范围. 这需要一种更复杂的编码方法.</p>
<p>场景线性和资源管道<br>在场景线性 sRGB 中工作并不像按一下开关那样简单。首先，导入的图像资产必须在导入时转换为线性光比例。即使将其线性化，这些资产也可能并不完全适合用作纹理，具体取决于它们的生成方式。<br>有两种方法可以做到这一点:</p>
<ol>
<li>用于在图像导入时显示线性比率的sRGB传递函数<br>这是最简单的使用sRGB资源的方法，但不是最理想的. 这样做的一个问题是质量的损失. 每通道使用8位来表示线性光比率，不足以正确量化这些值. 这些纹理以后也可能会被压缩，可能会加剧这个问题.</li>
<li>硬件sRGB传输函数显示线性转换<br>GPU 会在使用浮点读取纹素后进行转换。这在 PC 和游戏主机上很好用，但大多数移动设备不支持，或者它们不支持压缩的纹理格式（例如 iOS）。</li>
</ol>
<p>场景线性到显示参考的非线性<br>完成所有渲染后，场景线性渲染需要转换为适当的输出，例如sRGB显示.<br>为此，请在当前的: Environment 中启用 sRGB 转换(更多内容见下文).<br>请记住，sRGB -&gt; 显示线性和显示线性 -&gt; sRGB 转换必须始终同时启用。<br>如果未启用其中之一，将导致可怕的视觉效果，仅适用于前卫的实验性独立游戏。</p>
<p>HDR的参数<br>HDR可以在 Environment 资源中找到.<br>这些在大多数情况下都可以在 WorldEnvironment 节点中找到或在相机中设置. 更多信息请参阅 环境和后期处理.</p>
<h4 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h4><p>全局光照由以下几个关键概念组成：</p>
<ol>
<li>间接漫反射光照<br>种光照不会因为相机的角度而改变。间接漫反射光照有两个主要来源：</li>
</ol>
<ul>
<li>光<em>弹跳</em>在表面上。这种反射光照会与材质的反照率颜色相乘。<br>  然后，反射的照明可以被其他表面反射，由于光衰减，影响会减小。在现实生活中，光线会反射无数次。<br>  但是出于性能原因，无法在游戏引擎中模拟。相反，退回次数通常限制为 1 或 2（烘焙光照贴图时最多限制为 16）。<br>  更多的反弹将导致阴影区域更真实的光线衰减，而代价是导致性能较低或烘烤时间更长。</li>
<li>自发光材质还可以发出可以在表面上反弹的光。这充当 区域照明 的一种形式。<br>  与使用 OmniLight3D 或 SpotLight3D 节点发光不同，确定大小的区域将使用自己的表面发光。<br>直接漫反射光照已经由灯光节点本身处理，这意味着全局光照算法只尝试表示间接光照。<br>不同的全局光照技术提供不同级别的精度来表示间接漫反射光照。有关详细信息请参阅本页底部的比较表。<br>为较小的对象提供更精确的环境光遮蔽，屏幕空间环境光遮蔽（SSAO）可以在环境设置中启用。SSAO 具有较大的性能开销，因此在针对低端硬件时请确保禁用它。</li>
</ul>
<ol start="2">
<li>镜面反射光效果<br>镜面反射照明也被称为反射 。这是根据摄像机角度而变化强度的照明。这种镜面照明可以是 直接 或 间接 。<br>大多数全局光照技术都提供了一种渲染镜面反射光照的方法。然而，不同技术渲染镜面反射光照的精度差异很大。有关详细信息，请参阅本页底部的比较表。<br>为了给较小的对象提供更准确的反射，可以在环境设置中启用屏幕空间反射（SSR）。SSR 的性能开销很大（甚至比 SSAO 更高），因此在针对低端硬件时一定要禁用它。</li>
</ol>
<p>&lt;—正在施工—&gt;</p>
<h4 id="环境和后期处理"><a href="#环境和后期处理" class="headerlink" title="环境和后期处理"></a>环境和后期处理</h4><h4 id="体积雾和雾体积"><a href="#体积雾和雾体积" class="headerlink" title="体积雾和雾体积"></a>体积雾和雾体积</h4><h4 id="3D-抗锯齿"><a href="#3D-抗锯齿" class="headerlink" title="3D 抗锯齿"></a>3D 抗锯齿</h4><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="使用-MultiMeshInstance3D"><a href="#使用-MultiMeshInstance3D" class="headerlink" title="使用 MultiMeshInstance3D"></a>使用 MultiMeshInstance3D</h4><p>在正常情况下，使用一个 MeshInstance3D 节点来显示 3D网 格，比如主角的人体模型，但在某些情况下，你希望在一个场景中创建同一个网格的多个实例。<br>你可以多次复制同一个节点，并手动调整变换。这可能是一个乏味的过程，而且结果可能看起来很机械。<br>此外，这种方式也不利于快速迭代。MultiMeshInstance3D 是此问题的可能解决方案之一。<br>MultiMeshInstance3D，顾名思义，是在特定网格的表面上创建 MeshInstance 的多个副本。一个示例是树形网格用随机比例和方向的树填充地形网格。<br>设置节点<br>基本设置需要三个节点：MultiMeshInstance3D 节点和两个MeshInstance3D 节点。<br>一个节点用作目标，即要在其上放置多个网格的表面网格。 在树的示例中，这就是地形。<br>另一个节点是作为源节点，也就是你想复制的网格。在树的情况下，这将是树本身。<br>在我们的示例中，将使用 Node3D 作为场景的根节点。场景树看起来像这样:<br>现在你已准备好了一切。选择 MultiMeshInstance3D 节点并查看工具栏，你应该在视图旁边看到一个名为 MultiMesh 的额外按钮。<br>单击它并在下拉菜单中选择填充表面。将弹出一个名为填充MultiMesh的新窗口。</p>
<p>MultiMesh 设置<br>以下是选项说明。<br>目标表面<br>用来放置源网格副本的目标表面的网格。<br>源网格<br>要在目标曲面上复制的网格。<br>网格向上轴<br>轴用作源网格的上轴。<br>随机旋转<br>随机地围绕源网格的向上轴旋转。<br>随机砖块<br>随机化源网格的整体旋转。<br>随机缩放<br>随机化源网格的比例。<br>缩放（Scale）<br>将放置在目标曲面上的源网格的比例。<br>数量<br>放置在目标曲面上的网格实例数量。<br>选择目标曲面。在树的情况下，这应该是地形节点。源网格应该是树节点。根据你的喜好调整其他参数。按 Populate ，源网格的多个副本将放在目标网格上。 如果对结果满意，可以删除用作源网格的网格实例。<br>最终结果应如下所示:<br>要更改结果，请使用不同的参数重复相同的步骤.</p>
<h4 id="网格的细节级别（LOD）"><a href="#网格的细节级别（LOD）" class="headerlink" title="网格的细节级别（LOD）"></a>网格的细节级别（LOD）</h4><p>与 遮挡剔除 一样，细节级别（LOD）是优化 3D 项目渲染性能的最重要方法之一。<br>Godot 提供了一种方法，可以在导入时自动生成细节较少的网格供 LOD 使用，然后在需要时自动使用这些 LOD 网格。<br>这对用户完全透明。meshoptimizer 库用于幕后的 LOD 网格生成。<br>网格 LOD 适用于任何绘制 3D 网格的节点。这包括 MeshInstance3D、MultiMeshInstance3D、GPUParticles3D 和 CPUParticles3D。</p>
<blockquote>
<p>如果你需要使用艺术家创建的网格手动配置细节层次，请使用 可见范围（HLOD） 而不是自动网格 LOD。</p>
</blockquote>
<p>生成网格 LOD<br>默认情况下，导入的 3D 场景（glTF、.blend、Collada、FBX）会自动生成网格 LOD。<br>生成 LOD 网格后，将在渲染场景时自动使用它们。你无需手动配置任何内容。<br>然而，对于导入的 3D 网格（OBJ），网格LOD生成 不会 自动启动。<br>这是因为 OBJ 文件默认情况下不作为完整的 3D 场景导入，而仅作为单独的网格资源加载到MeshInstance3D 节点（或 GPUParticle3D，CPUParticles3D…）。<br>为了使OBJ文件具有为其生成的网格LOD，在文件系统面板中选择它，去到导入面板，将其 导入为 选项更改为 场景 ，然后单击 重新导入 ：</p>
<p>这需要在单击 重新导入 后重新启动编辑器。</p>
<h4 id="可见范围（HLOD）"><a href="#可见范围（HLOD）" class="headerlink" title="可见范围（HLOD）"></a>可见范围（HLOD）</h4><h4 id="遮挡剔除"><a href="#遮挡剔除" class="headerlink" title="遮挡剔除"></a>遮挡剔除</h4><h4 id="分辨率缩放"><a href="#分辨率缩放" class="headerlink" title="分辨率缩放"></a>分辨率缩放</h4><h4 id="可变速率着色"><a href="#可变速率着色" class="headerlink" title="可变速率着色"></a>可变速率着色</h4><h3 id="工具-2"><a href="#工具-2" class="headerlink" title="工具"></a>工具</h3><h4 id="使用-CSG-设计关卡原型"><a href="#使用-CSG-设计关卡原型" class="headerlink" title="使用 CSG 设计关卡原型"></a>使用 CSG 设计关卡原型</h4><h4 id="使用-GridMap"><a href="#使用-GridMap" class="headerlink" title="使用 GridMap"></a>使用 GridMap</h4><h4 id="带弹簧臂的第三人称相机"><a href="#带弹簧臂的第三人称相机" class="headerlink" title="带弹簧臂的第三人称相机"></a>带弹簧臂的第三人称相机</h4><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="动画功能介绍"><a href="#动画功能介绍" class="headerlink" title="动画功能介绍"></a>动画功能介绍</h3><p>AnimationPlayer 节点创建动画,动画数据容器。<br>一个AnimationPlayer节点可以保存多个动画，这些动画可以自动相互过渡。<br>动画面板由四部分组成：</p>
<ol>
<li>动画控件(即添加，加载，保存和删除动画)</li>
<li>轨道列表</li>
<li>带有关键帧的时间轴</li>
<li>时间轴和轨道控件<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/animation_animation_panel_overview.webp"></li>
</ol>
<p>管理动画库<br>出于复用性，动画被注册在动画库资源列表中(动画按钮)<br>如果你将动画添加到 <code>AnimationPlayer</code> 而不指定任何特定设置，则该动画将默认注册到 AnimationPlayer 具有的 [Global] 动画库中。<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/animation_library.webp"><br>如果有多个动画库并且你尝试添加动画，则会出现一个包含选项的对话框。<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/animation_library_dialog.webp"></p>
<p>属性轨道<br>动画系统不仅限于位置、旋转和缩放。可以对任何属性进行动画化。</p>
<p>轨道设置<br>每条<strong>属性轨道</strong>的末尾有设置面板，设置更新模式、插值模式和循环模式</p>
<ol>
<li><p>更新模式告诉 Godot 何时更新属性值：</p>
<ul>
<li>连续：每帧都更新属性</li>
<li>离散：仅在位于关键帧时更新属性</li>
<li>捕获：如果第一个关键帧的时间大于 0.0，就会记录该属性的当前值，并将其与第一个动画帧混合。<br> 例如，利用“捕获”模式，你可以将处于任意位置的节点移动到特定的位置。<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/animation_track_rate.webp"></li>
</ul>
</li>
<li><p>插值模式告诉 Godot 如何计算关键帧之间的帧值：</p>
<ul>
<li>临近：设置为最接近的关键帧的值</li>
<li>线性：使用线性函数计算两个关键帧之间的值</li>
<li>三次方：使用三次函数计算两个关键帧之间的值</li>
<li>线性角（仅出现在旋转属性中）：具有最短路径旋转的线性模式</li>
<li>三次角（仅出现在旋转属性中）：具有最短路径旋转的立方模式<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/animation_track_interpolation.webp"><br>利用三次插值，动画在关键帧处的速度较慢，而在关键帧之间的速度较快，从而使动作更加自然。立体插值常用于角色动画。线性插值以固定的速度进行动画变化，从而产生更加机械的效果。</li>
</ul>
</li>
<li><p>支持两种循环模式，如果将其设置为循环时，则会影响动画效果：</p>
</li>
</ol>
<ul>
<li>钳制循环插值: 第一个关键帧继承最后一个关键帧的值</li>
<li>环绕循环插值: 回归到第一个关键帧</li>
</ul>
<p>使用 RESET 轨道(默认轨道)<br>添加名为<code>RESET</code>（大写）的动画。<br>只在时间为 0 处存在一个关键帧，默认值。<br>如果 AnimationPlayer 的 Reset On Save（保存时重置）属性为 true，场景在保存时会应用重置动画的效果（相当于寻道到 0.0 时间点的效果）。<br>只有保存的文件会受到影响——编辑器中的属性轨道还是会保持原样。<br>如果要在编辑器中重置轨道，请选中 AnimationPlayer 节点，打开 动画 底部面板，然后选择动画按钮 下拉菜单中的 应用重置 。<br>在检查器中使用属性旁边的关键帧图标时，编辑器会要求你自动创建 RESET 轨道。<br>RESET 轨道也用作混合的参考值。另请参阅为了更好地混合。</p>
<p>洋葱皮（一种显示功能）<br>启用单击洋葱图标。此时，在动画对象先前位置将有透明红色副本显示出来。<br>与洋葱皮按钮相邻的下拉菜单可以用来调整洋葱皮的工作方式，包括在未来的帧中使用洋葱皮的能力。</p>
<p>动画标记 (Animation Markers)<br>动画标记可用于播放动画的特定部分。<br>向动画添加标记，右键单击时间轴上方的空间选择<strong>插入标记</strong>。<br>所有标记都需要唯一名称。还可以设置标记颜色。<br>要在两个标记之间播放动画部分<br>使用 play_section_with_markers（） 和 play_section_with_markers_backwards（） 方法。<br>预览两个标记之间的动画，请使用 Shift + Click 选择标记。选择两个时，它们之间的空格应以红色突出显示。</p>
<h3 id="动画轨道类型"><a href="#动画轨道类型" class="headerlink" title="动画轨道类型"></a>动画轨道类型</h3><p><img src="https://wzcwzc10.github.io/posts_img/godot/06/track_types.webp"><br>3D 位置、旋转、缩放轨道<br>专为从外部3D模型导入的动画而设计。</p>
<p>混合形状轨道<br>混合形状轨道针对 MeshInstance3D 中的混合形状动画进行了优化。<br>专为从外部3D模型导入的动画而设计。</p>
<p>方法调用轨道<br>允许在动画中的特定时间调用函数。<br>例如，你可以在死亡动画的结束时调用 queue_free() 来删除节点。</p>
<blockquote>
<p>为了安全起见，在编辑器中预览动画时，方法调用轨道上的事件不会被执行。<br>创建轨道时会打开一个窗口让你选择与该轨道关联的节点。<br>要更改方法调用或其参数，请单击关键帧并转到检查器面板。<br>如果展开“Args”部分，你将看到一个可编辑的参数列表。<br>要通过代码创建这样的轨道，请传递一个包含目标方法的名称和参数的字典作为 Animation.track_insert_key() 中 key 的变体。键及其预期值如下：</p>
<table>
<thead>
<tr>
<th align="left">键</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&quot;method&quot;</code></td>
<td align="left">方法的名称，类型为 String</td>
</tr>
<tr>
<td align="left"><code>&quot;args&quot;</code></td>
<td align="left">传递给该函数的所有参数，类型为 Array</td>
</tr>
</tbody></table>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个调用方法的动画轨道。</span><br><span class="line">func create_method_animation_track():</span><br><span class="line">	# 获取或创建将调用目标方法的动画。</span><br><span class="line">	var animation = $AnimationPlayer.get_animation(&quot;idle&quot;)</span><br><span class="line">	# 获取或创建目标方法的动画轨道。</span><br><span class="line">	var track_index = animation.add_track(Animation.TYPE_METHOD)</span><br><span class="line">	# 创建目标方法 jump() 所需的参数。</span><br><span class="line">	var jump_velocity = -400.0</span><br><span class="line">	var multiplier = randf_range(.8, 1.2)</span><br><span class="line">	# 获取或创建一个包含目标方法名称及其参数的字典。</span><br><span class="line">	var method_dictionary = &#123;</span><br><span class="line">		&quot;method&quot;: &quot;jump&quot;,</span><br><span class="line">		&quot;args&quot;: [jump_velocity, multiplier],</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	# 设置场景树中拥有目标方法的节点路径。</span><br><span class="line">	animation.track_set_path(track_index, &quot;.&quot;)</span><br><span class="line">	# 将字典作为关键帧插入到动画方法轨道中。</span><br><span class="line">	animation.track_insert_key(track_index, 0.6, method_dictionary, 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 目标方法，将由动画系统调用。</span><br><span class="line">func jump(jump_velocity, multiplier):</span><br><span class="line">	velocity.y = jump_velocity * multiplier</span><br></pre></td></tr></table></figure>

<p>贝塞尔曲线轨道<br>类似于属性轨道，允许使用贝塞尔曲线控制属性值。</p>
<blockquote>
<p>贝塞尔曲线轨道和属性轨道不能在 <code>AnimationPlayer</code> 和 <code>AnimationTree</code> 中混合。<br>请单击动画轨道右侧的曲线图标以打开贝塞尔曲线编辑器。<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/bezier_curve_icon.webp" alt="打开贝塞尔曲线编辑器"><br>在编辑器中，帧由实心菱形表示，空心菱形通过线控制曲线的形状连接到它们。</p>
</blockquote>
<p class="div-border" style="background-color: rgba(26, 196, 35, 0.1);border: 1px solid #1ac439ff;border-radius: 0.4rem;">
<mark class="hl-label green">小技巧</mark><br>
为了在手动处理曲线时获得更好的精度，你可能需要更改编辑器的缩放级别。<br>
编辑器右下角的滑块可用于放大和缩小时间轴。<br>
也可以使用 Ctrl + Shift + 鼠标滚轮 来执行该操作。使用 Ctrl + Alt + 鼠标滚轮 将放大和缩小 Y 轴。
</p>

<p>右键曲线可以选择手柄模式：</p>
<ul>
<li>自由：允许操纵器定向到任何方向，而不影响另一个操纵器的位置。</li>
<li>线性：不允许操纵器旋转，绘制线性图形。</li>
<li>平衡：使操纵器一起旋转，但关键帧和操纵器之间的距离不镜像。</li>
<li>镜像：使一个操纵器的位置完美镜像另一个操纵器，包括它们到关键帧的距离。</li>
</ul>
<p>音频播放轨道<br>创建音频播放轨道场景必须具有 AudioStreamPlayer、AudioStreamPlayer2D 或 AudioStreamPlayer3D 节点之一。<br>混合模式允许你选择在 AnimationTree 中混合时是否调整音频音量。</p>
<p>动画播放轨道</p>
<blockquote>
<p>如果在场景中实例化了包含动画播放器的场景，则需要在场景树中启用“子节点可编辑”。<br>对场景中其他动画播放器节点进行排序。<br>比如你可以用它为过场动画中的多个角色制作动画。<br>而后选择要与轨道关联的动画播放器。<br>选中你刚创建的帧，以在检查器面板中选择动画。<br>如果动画已经在播放，并且你想提前停止它，可以创建一个帧并将其在检查器中设置为 [STOP] 。</p>
</blockquote>
<h3 id="剪纸动画"><a href="#剪纸动画" class="headerlink" title="剪纸动画"></a>剪纸动画</h3><p>用于剪纸动画的绑定工具，而且是工作流的理想选择：</p>
<ul>
<li>动画系统与引擎完全集成：这意味着动画可以控制的不仅仅是物体的运动。<br>  纹理、精灵大小、轴心、不透明度、颜色调制等都可以进行动画和混合。</li>
<li>混合动画风格 ：<code>AnimatedSprite2D</code> 允许将传统赛璐璐动画与剪纸动画一起使用。<br>  在赛璐璐动画中，不同的动画帧使用完全不同的绘图，而不是相同的片段位置不同。<br>  在其他基于剪纸的动画中，赛璐璐动画可以选择性地用于复杂的部件，例如手、脚、改变面部表情等。</li>
<li>自定义形状元素 : 可以用 <code>Polygon2</code>D 创建自定义形状，允许UV动画，变形等.</li>
<li>粒子系统 : 剪纸式动画配件可以与粒子系统相结合，这对魔法效果，喷气背包等很有用.</li>
<li>自定义碰撞器：在骨架的不同部位设置碰撞器和影响区域，非常适合 Boss 和格斗游戏。</li>
<li>动画树 : 允许在几个动画之间进行复杂的组合和混合，与3D动画的工作方式相同.</li>
</ul>
<ol>
<li>创建模型<br>创建一个空的Node2D作为场景的根<br>模型的第一个节点是臀部，接下来是躯干作为臀部的子级。<br>可以按 E 进入旋转模式，退出旋转模式按 ESC。<br>旋转轴心错误，需要调整，有三种方式：</li>
</ol>
<ul>
<li>可以通过更改 Sprite2D 中的 offset 属性来调整轴心</li>
<li>可以将鼠标悬停在所需的轴心点上时，按 V 移动所选 Sprite2D 的轴心。</li>
<li>上方工具栏也有类似的功能。<br>继续添加身体部件，左臂有些问题. 在二维中，子节点出现在父节点的前面:我们希望左臂出现在臀部和躯干的后面.<br>我们用 RemoteTransform2D 节点来解决这个问题.<blockquote>
<p>还可以通过调整从二维节点继承的任何节点的Z属性，来修复深度排序问题.<br>RemoteTransform2D 节点<br>可以对层次结构中其他地方的节点进行变换.<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/tuto_cutout9.png"></p>
</blockquote>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://tieba.baidu.com/p/8825999718">网络相关讨论</a></p>
<ol start="2">
<li>完成骨架<br>通过选择节点并旋转可以有效地为前向运动学(FK)设置动画.<br>对于简单的物体和装配来说已经足够了，但仍然有限制:</li>
</ol>
<ul>
<li>在复杂的装配中，在主视口中选择精灵会变得很困难. 场景树最终被替代，用来选择部件，这可能会比较慢.</li>
<li>反向动力学（Inverse Kinematics、IK）对于手脚等肢体的运动非常有用，目前我们的绑定还无法使用。<br>为了解决这些问题，我们将会使用 Godot 的骨架。</li>
</ul>
<p>骨架</p>
<mark class="hl-label red">有问题</mark>

<p>IK 链<br>IK 是反向动力学（Inverse Kinematics）的缩写，给手部、足部以及其它需绑定肢体的动画带来便利。</p>
<mark class="hl-label red">有问题</mark>

<p>动画提示<br>下一节将是创建剪纸动画的技巧集合。<br>设置关键帧和排除属性<br>当动画编辑器窗口打开时，特殊的上下文元素会出现在顶部工具栏中:<br>按键按钮在当前游戏开始位置为选定的对象或骨骼插入位置，旋转和缩放关键帧.<br>通过切换关键帧按钮左边的 “位置” ，”旋转” 和 “缩放” 按钮，可以修改其功能，允许你指定将为三个属性中的哪一个创建关键帧.<br>下面是一个例子，说明如何使用其的: 假设你有一个节点，其中已经有两个关键帧只对其缩放进行动画. 你想在同一个节点重叠添加旋转移动. 旋转运动应该在不同的时间开始和结束，与已经设置的缩放变化不同. 在添加新关键帧时，可以使用切换按钮，只添加旋转信息. 这样，你就可以避免添加不需要的缩放关键帧，破坏现有的缩放动画.</p>
<p>创建放松姿势<br>将放松姿势视为默认姿势，当游戏中没有其他姿势处于活动状态时，应该将其设置为剪纸绑定。创造一个放松姿势如下：</p>
<ol>
<li>确保钻机部件以看起来像“静止”的排列方式放置。</li>
<li>创建一个新动画，重命名为 “rest”.</li>
<li>选择装配中的所有节点(应该可以框选).</li>
<li>确保工具栏中的“loc”、“rot”和“scl”切换按钮均处于活动状态。</li>
<li>按按键。将为存储其当前排列的所有选定零件插入键。现在，在游戏中必要时，可以通过播放你创建的“休息”动画来调用此姿势。</li>
</ol>
<p>只修改旋转<br>当制作剪纸动画绑定时，通常只需要改变节点的旋转. 很少使用位置和比例.<br>因此，在插入键时，你可能会发现在大多数时间里只有 “rot” 切换键处于激活状态，会很方便:<br>这将避免为坐标和缩放创建不必要的动画轨道.</p>
<p>关键帧 IK 链<br>编辑IK链时，不需要选择整个链来添加关键帧. 选择链的端点并插入关键帧将自动为链的所有其他部分插入关键帧.</p>
<p>视觉上移动父级后面的精灵<br>有时，在动画过程中，需要让节点相对于其父节点更改其可视深度.<br>想象一个面对镜头的角色，他从背后拿出一个东西放在面前.<br>在这个动画过程中，整个手臂和他手中的物体都需要改变相对于角色身体的视觉深度.</p>
<p>为了帮助解决这个问题，在所有 Node2D 的派生节点上都有一个可制作关键帧的“Behind Parent”（在父级之后）属性。<br>规划绑定时，请考虑它需要执行的动作，并考虑如何使用“Behind Parent”和&#x2F;或 RemoteTransform2D 节点。它们提供重叠的功能。</p>
<p>为多个关键帧设置缓动曲线<br>要将同一缓动曲线同时应用于多个关键帧:<br>选择相关的关键帧.<br>点击动画面板右下角的铅笔图标. 这将打开过渡编辑器.<br>在过渡编辑器中，点击所需曲线进行应用.</p>
<h3 id="2D-骨架"><a href="#2D-骨架" class="headerlink" title="2D 骨架"></a>2D 骨架</h3><p>在 3D 工作中，骨骼变形是角色和生物的常见功能。<br>而对于 2D，由于这种功能并不常用，因此很难找到针对这种功能的主流软件。<br>一种选择是在 Spine 或 Dragonbones 等第三方软件中创建动画。内置也支持此功能。</p>
<p>为什么要在 Godot 中直接处理骨骼动画？答案是这样做有很多好处：</p>
<ul>
<li>能更好地与引擎集成，从而减少使用外部工具导入和编辑的麻烦.</li>
<li>能够控制粒子系统，着色器，声音，调用脚本，颜色，透明度等动画.</li>
<li>Godot内置的骨骼系统非常高效，并且是为性能而设计的.<br>接下来的教程将讲解 2D 骨架变形。<br>教程素材：<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/gBot_pieces.png"></li>
</ul>
<p>场景树结构：<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/skel2d9.png"></p>
<p>Polygon2D 节点设置如下：<br>教程素材选择并指定纹理：<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/skel2d2.png"></p>
<p>转到点模式，选择铅笔，在需要的区域绘制一个多边形<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/2025-09-09.png"></p>
<p class="div-border" style="background-color: rgba(26, 196, 35, 0.1);border: 1px solid #1ac439ff;border-radius: 0.4rem;">
<mark class="hl-label green">小技巧-复制多边形</mark><br>
复制Polygon2D节点改名字.<br>
进入 "UV" 对话框，移动多边形.
</p>

<p>创建骨架<br>创建一个 Skeleton2D 节点作为根节点的子项作为骨架的基础:<br>创建一个 Bone2D 节点作为骨架的子项。把它放在臀部（通常从这里开始建立骨架）。<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/skel2d13.png"><br>所有的骨骼都显示关于缺少放松姿势的警告。<br>放松姿势是骨骼的默认姿势，你可以随时恢复到这个姿势（这对于动画制作非常方便）。<br>设置放松姿势，点击场景树中的 skeleton 节点，然后在工具栏中点击 Skeleton2D 按钮选择<strong>覆盖放松姿势</strong>。</p>
<p>多边形的变形</p>
<ol>
<li>选择之前创建的多边形，并将骨架节点分配 Skeleton 属性。</li>
<li>打开多边形编辑器，进入骨骼部分。</li>
<li>点击同步骨骼到多边形。<ul>
<li>此步骤仅需手动执行一次（除非你通过添加&#x2F;删除&#x2F;重命名骨骼来修改骨架）。</li>
<li>它确保你的绑定信息保存在多边形中，即使骨架节点意外丢失或被修改。按“同步骨骼到多边形”按钮来同步列表。</li>
</ul>
</li>
<li>白色点完全受到权重影响，而黑色点完全不受影响。<ul>
<li>如果在多根骨骼上，绘制了相同的白色点，那么权重的影响将平均分配在这些骨骼之间。</li>
<li>所以通常不需要过多使用中间色调，除非你想仔细打磨弯曲效果。</li>
</ul>
</li>
<li>绘制完权重后，制作骨骼的动画（不是多边形的动画！）会具有修改和弯曲多边形的预期效果。</li>
</ol>
<p>但这并不完美。尝试调调骨骼的动画，弯曲的多边形往往会产生意想不到的结果：形变扭曲。<br>这是因为Godot在绘制多边形时，产生了内部三角形来连接这些点. 它们并不总是按你所期望的方式弯曲.<br>如果要解决这个问题，你需要在几何图形中设置提示，以明确希望它如何变形.</p>
<p>内部顶点<br>再次打开每根骨骼的 UV 菜单，进入<strong>点</strong>部分。<br>在你期望几何体弯曲的地方添加一些内部顶点：<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/hand.png"><br>现在转到 多边形 部分，重新绘制细节更丰富的多边形.<br>这样，当多边形弯曲时，你需要确保它们变形的可能性最小，慢慢尝试找出正确的设置.</p>
<h3 id="使用-AnimationTree"><a href="#使用-AnimationTree" class="headerlink" title="使用 AnimationTree"></a>使用 AnimationTree</h3><p>在3D场景中经常使用<strong>AnimationTree</strong></p>
<ol>
<li>AnimationTree 节点不包含自己，使用 AnimationPlayer 节点中的动画. </li>
<li>当从3D交换格式导入场景时, 它们通常自带动画(要么是多个, 要么是在导入时从一个大的动画中拆分出来). </li>
<li>最后, 导入的Godot场景在 AnimationPlayer 节点中包含动画.</li>
</ol>
<p>很少在Godot中直接使用导入的场景(它们要么实例化, 要么来自继承), 你可以将 AnimationTree 节点放置在包含导入的新场景中.<br>然后, 将 AnimationTree 节点指向导入场景内创建的 AnimationPlayer 节点.<br>这是在<img src="https://github.com/godotengine/tps-demo" alt="第三人称射击游戏演示">, 中的设置, 参考下图:<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/animtree1.png"><br>为玩家创建了一个以 CharacterBody3D 为根节点的新场景。这个场景中实例化了原来的 .dae（Collada）文件，并创建 AnimationTree 节点。</p>
<p>创建树<br>可以在 AnimationTree 中使用三种主要节点类型:</p>
<ol>
<li>动画节点，从链接的 AnimationTree 中引用动画。</li>
<li>动画根节点, 用于混合子节点.</li>
<li>动画混合节点，在 AnimationNodeBlendTree 中使用，通过多个输入端口进行单图混合。<br>在 AnimationTree 中设置根节点, 如下几种类型可供选择:</li>
</ol>
<ul>
<li>AnimationNodeAnimation：从列表中选择一个动画并播放它. 这是最简单的根节点, 一般不直接用作根节点.</li>
<li>AnimationNodeBlendTree：包含许多混合类型的节点，如调配, 混合2, 混合3, 一对一等. 最常用的根节点之一.</li>
<li>AnimationNodeStateMachine：将多个根节点作为图中的子节点. 每个节点作为一个 状态 使用, 并提供多个函数在状态之间进行切换.</li>
<li>AnimationNodeBlendSpace2D：允许在二维混合空间中放置根节点. 在二维中控制混合位置以混合多个动画.</li>
<li>AnimationNodeBlendSpace1D：以上的简化版本（一维）。</li>
</ul>
<p>混合树(AnimationNodeBlendTree)<br>可包含用于混合的根节点和常规节点。节点从菜单添加到图中：<br>所有混合树默认都包含一个 Output（输出）节点，为了让动画播放，必须有个东西与其相连。<br>以下是可用节点的简短描述:</p>
<ol>
<li>混合2&#x2F;混合3(add2&#x2F;add3) 将通过用户指定输入混合值之间进行混合:<br> 对于更复杂的混合, 建议使用混合空间.<br> 混合也可以使用过滤器, 也就是说, 你可以单独控制通过混合功能的轨道. 这对于动画的层叠非常有用.</li>
<li>OneShot 此节点将执行子动画, 并在完成后返回. 可以用于定制淡入淡出时间, 以及过滤器.<br> 在设置时间和改变动画播放后，播放节点会通过将其 request 值设置为 AnimationNodeOneShot.ONE_SHOT_REQUEST_NONE&#x2F; 做到在下一个进程帧自动清除请求。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 播放连接到 &quot;shot&quot; 端口的子动画</span><br><span class="line">animation_tree.set(&quot;parameters/OneShot/request&quot;, AnimationNodeOneShot.ONE_SHOT_REQUEST_FIRE)</span><br><span class="line"># 替代表达方式（与上面效果相同）</span><br><span class="line">animation_tree[&quot;parameters/OneShot/request&quot;] = AnimationNodeOneShot.ONE_SHOT_REQUEST_FIRE</span><br><span class="line"></span><br><span class="line"># 终止连接到 &quot;shot&quot; 端口的子动画</span><br><span class="line">animation_tree.set(&quot;parameters/OneShot/request&quot;, AnimationNodeOneShot.ONE_SHOT_REQUEST_ABORT)</span><br><span class="line"># 替代表达方式（与上面效果相同）</span><br><span class="line">animation_tree[&quot;parameters/OneShot/request&quot;] = AnimationNodeOneShot.ONE_SHOT_REQUEST_ABORT</span><br><span class="line"></span><br><span class="line"># 获取当前状态（只读）</span><br><span class="line">animation_tree.get(&quot;parameters/OneShot/active&quot;)</span><br><span class="line"># 替代表达方式（与上面效果相同）</span><br><span class="line">animation_tree[&quot;parameters/OneShot/active&quot;]</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>时间缩放(Time Seek) 用来使寻找命令发生在动画图像的任何子代上。<br>使用这个节点类型可以从 AnimationNodeBlendTree 中的开始或某个位置播放 Animation。<br>在设置时间和改变动画播放后，寻找节点通过设置其 seek_position 值为 -1.0，在下一个进程帧自动进入睡眠模式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 从头开始播放子动画</span><br><span class="line">animation_tree.set(&quot;parameters/TimeSeek/seek_request&quot;, 0.0)</span><br><span class="line"># 替代表达方式（与上面效果相同）</span><br><span class="line">animation_tree[&quot;parameters/TimeSeek/seek_request&quot;] = 0.0</span><br><span class="line"></span><br><span class="line"># 从第12秒的时间点开始播放子动画</span><br><span class="line">animation_tree.set(&quot;parameters/TimeSeek/seek_request&quot;, 12.0)</span><br><span class="line"># 替代表达方式（与上面效果相同）</span><br><span class="line">animation_tree[&quot;parameters/TimeSeek/seek_request&quot;] = 12.0</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>时间缩放(TimeScale) 允许通过 scale 参数缩放连接到 in 输入的动画速度（或使其反转）。 将 scale 设置为0会暂停动画。</li>
<li>转换(Transition) 非常简单的状态机（当你不想使用 StateMachine 节点时）。<br> 动画可以连接到输出，过渡时间可以指定。<br> 在设置请求和更改动画播放后，过渡节点会通过将其 transition_request 值设置为空字符串 (“”)，在下一个进程帧自动清除请求。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 播放连接到 &quot;state_2&quot; 端口的子动画</span><br><span class="line">animation_tree.set(&quot;parameters/Transition/transition_request&quot;, &quot;state_2&quot;)</span><br><span class="line"># 替代表达方式（与上面效果相同）</span><br><span class="line">animation_tree[&quot;parameters/Transition/transition_request&quot;] = &quot;state_2&quot;</span><br><span class="line"></span><br><span class="line"># 获取当前状态名称（只读）</span><br><span class="line">animation_tree.get(&quot;parameters/Transition/current_state&quot;)</span><br><span class="line"># 替代表达方式（与上面效果相同）</span><br><span class="line">animation_tree[&quot;parameters/Transition/current_state&quot;]</span><br><span class="line"></span><br><span class="line"># 获取当前状态索引（只读）</span><br><span class="line">animation_tree.get(&quot;parameters/Transition/current_index&quot;)</span><br><span class="line"># 替代表达方式（与上面效果相同）</span><br><span class="line">animation_tree[&quot;parameters/Transition/current_index&quot;]</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>二维混合空间(BlendSpace2D)<br>BlendSpace2D 是一个在二维空间进行高级混合的节点. 将点添加到一个二维空间, 然后可以控制位置来确定混合:<br>可以控制X和Y的范围(为方便起见, 还可以标记它们). 默认情况下, 可以在任何位置放置点(只需右键单击坐标系统或使用 添加点 按钮)将自动生成德洛内三角形.<br>也可以通过禁用 自动三角形 选项来手动绘制三角形, 虽然基本上没必要这么做:<br>最后, 可能会更改混合模式. 默认情况下, 混合是通过在最近的三角形内插点来实现的. 当处理二维动画(逐帧)时, 你可能希望切换到 离散 模式. 此外, 如果你想在离散动画之间切换时保持当前播放位置, 请使用 进位 模式. 此模式可在 混合 菜单中更改:</li>
<li>一维混合空间(BlendSpace1D) 这类似于二维混合空间, 但在一维空间中(所以不需要三角形).</li>
<li>状态机(StateMachine) 这个节点是一个状态机，根节点都是状态。<br> 根节点可以创建并通过线路连接。状态通过转换连接，它们是具有特殊性质的连接。转换是单向的，但是可以用两个来达到双向连接。<br> 有多种类型的转换：<ul>
<li>Immediate（立即）：将立即切换到下一个状态。当前状态将结束，并与新状态的开头相混合。</li>
<li>Sync（同步）：立即切换到下一个状态，但会将新状态快进并到旧状态的播放位置。</li>
<li>At End（末尾）：将等待当前状态播放结束，然后切换到下一个状态动画的开头。<br> 过渡也有一些属性。单击任何过渡，它就会显示在“检查器”面板中：</li>
<li>Switch Mode（切换模式）为过渡类型（见上文），可以在此处创建后修改。</li>
<li>Auto Advance（自动前进）当达到此状态时将自动开启转换。最适合 At End 切换模式。</li>
<li>Advance Condition（前进条件）会在条件成立时打开自动前进。这是一个可以用变量名填充的自定义文本字段。可以从代码中修改变量（稍后将对此进行详细介绍）。</li>
<li>Xfade Time（叠化时间）是在这个状态和下一个状态之间交叉渐变的时间。</li>
<li>Priority（优先级）与代码中的 travel() 函数一起使用（后述）。当从一个状态到另一个状态时，会优先使用优先级较低的过渡。</li>
<li>Disabled（禁用）允许禁用此转换（它不会在行程或自动前进期间使用）。</li>
</ul>
</li>
</ol>
<p>为了更好的混合<br>在 Godot 4.0+ 中，为了使混合结果具有确定性（结果可复现且始终一致），混合属性值必须具有特定的初始值。<br>例如，在要混合两个动画的情况下，如果一个动画具有属性轨道而另一个动画没有，则计算混合动画时，要好像后一个动画（即本来没有属性轨道的那个）具有初始值的属性轨道一样去处理。<br>当使用 Skeleton3D 骨骼的 Position&#x2F;Rotation&#x2F;Scale 3D 轨道时，初始值为 Bone Rest（骨骼放松姿势）。<br>对于其他属性而言，初始值是 0 ，并且如果轨道出现在 RESET 动画中，那么则使用它第一个关键帧的值。<br>例如，下面的 AnimationPlayer 有两个动画，但其中一个缺少 Position 的属性轨道。<br>这意味着缺少该 Position 的动画会将这些 Position 视为 Vector2(0, 0)。<br>可以通过将 Position 的 Property 轨道作为初始值添加到 RESET 动画中来解决这个问题。</p>
<blockquote>
<p>请注意，RESET 动画的存在是为了在最初加载对象时定义默认姿势。它被假定只有一帧，并且不应使用时间轴进行播放。<br>另请记住，将“插值类型”设置为“线性角”或“三次角”的“Rotation 3D 轨道”和用于 2D 旋转的“属性”轨道，将阻止从初始值旋转超过 180 度的操作作为混合动画。<br>这种限制对于 Skeleton3D 非常有用，可以防止骨骼在混合动画时穿透身体。因此，Skeleton3D 的 Bone Rest （骨骼放松姿势）值应尽可能接近可移动范围的中点。 这意味着人形模型最好以 T-pose 导入 。</p>
</blockquote>
<p>你可以看到，优先考虑从 Bone Rest 出发的最短旋转路径，而不是动画之间的最短旋转路径。<br>如果需要通过混合动画将 Skeleton3D 本身旋转 180 度以上，则可以使用 Root Motion。</p>
<p>根骨骼运动<br>处理 3D 动画时，一种流行的技术是利用根骨骼为其余部分骨骼制作运动动画。<br>这样处于动画角色的脚步就能够与下方的地板相匹配，并且还能够实现过场动画中与物体的精确交互。<br>在 Godot 中回放动画时，可以将这根骨骼选作根运动轨道。这会在视觉上取消这根骨骼的变换（在原地播放动画）。<br>这样做以后，可以通过 AnimationTree API 获取实际的变换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 获取根运动的位移增量（本次动画播放的移动量）</span><br><span class="line">animation_tree.get_root_motion_position()</span><br><span class="line">animation_tree.get_root_motion_rotation()</span><br><span class="line">animation_tree.get_root_motion_scale()</span><br><span class="line"></span><br><span class="line"># 获取实际混合后的根运动累积值（累计的总移动量）</span><br><span class="line">animation_tree.get_root_motion_position_accumulator()</span><br><span class="line">animation_tree.get_root_motion_rotation_accumulator()</span><br><span class="line">animation_tree.get_root_motion_scale_accumulator()</span><br></pre></td></tr></table></figure>
<p>可以将这些值提供给 CharacterBody3D.move_and_slide 等函数，用来控制角色的移动。<br>还有一个名为 RootMotionView 的工具节点，可以放置在场景中充当角色和动画的自定义地板（这个节点默认在游戏期间禁用）。</p>
<p>使用代码控制<br>创建树和预览之后，就只剩下一个问题：“这些东西怎么使用代码来控制？”。<br>要注意动画节点就是资源，因此他们会在所有使用他们的实例之间共享。直接修改节点中的值，将会影响到场景中所有使用这个 AnimationTree 的实例。通常是不希望这样的，不过也有一些不错的用法，比如你可以复制粘贴你的动画树的一部分，或者在不同的动画树中复用具有复杂布局的节点（例如状态机和混合树）。<br>实际的动画数据包含在 AnimationTree 节点中, 并通过属性访问. 检查 AnimationTree 节点的 “参数” 部分, 查看所有可以实时修改的参数:<br>这很方便, 因为它可以通过 AnimationPlayer 获得动画效果, 甚至是 AnimationTree 本身, 允许实现非常复杂的动画逻辑.<br>想要通过代码修改这些值, 必须获得该属性的路径. 这是很容易做到的, 把鼠标悬停在任何参数:<br>允许设置或读取它们:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animation_tree.set(&quot;parameters/eye_blend/blend_amount&quot;, 1.0)</span><br><span class="line"># 更简单的替代写法：</span><br><span class="line">animation_tree[&quot;parameters/eye_blend/blend_amount&quot;] = 1.0</span><br></pre></td></tr></table></figure>

<p>状态机行程<br><code>StateMachine</code> 实现提供了很多不错的功能，其中之一就是“行程”（Travel）的能力。<br>可以向图发出指令，让其从当前状态转到另一个状态，所有的中间状态都会被访问到。<br>这是通过 A* 算法实现的。如果当前状态和目的状态之间不存在任何可达的过渡路径集，图就会立即传送到目的状态。<br>要使用行程能力, 你应该首先从 AnimationTree 节点中检索 AnimationNodeStateMachinePlayback 对象(其被导出为一个属性).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var state_machine = animation_tree[&quot;parameters/playback&quot;]</span><br></pre></td></tr></table></figure>
<p>一旦检索到, 可以调用它提供的许多函数之一:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state_machine.travel(&quot;SomeState&quot;)</span><br></pre></td></tr></table></figure>
<p>状态机必须正在运行才能使用行程能力。确保调用 start() 或选择一个节点以在加载时自动播放。</p>
<h3 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h3><p>VideoStreamPlayer 节点支持视频的播放。<br>唯一支持的格式是 Ogg Theora（不要与 Ogg Vorbis 音频混淆）和可选的 Ogg Vorbis 音轨。<br>扩展可以带来对其他格式的支持。</p>
<p class="div-border" style="background-color: rgba(26, 196, 193, 0.1);border: 1px solid #1ac4c4ff;border-radius: 0.4rem;">
<mark class="hl-label blue">备注</mark><br>
您可能会找到带有 .ogg 或 .ogx 扩展名的视频，这些扩展名是 Ogg 容器中数据的通用扩展名。<br>
将这些文件扩展名修改为 .ogv可能可以让视频在 Godot 中导入。<br>
不过，并不是所有 .ogg 或 .ogx 扩展名的文件都是视频——有些可能只包含音频。
</p>

<p>设置 VideoStreamPlayer<br>在 Stream 属性中加载 .ogv 文件。<br>如果视频尚未采用 Ogg Theora 格式，请跳转到 推荐 Theora 编码设置。<br>在场景加载时立即播放视频，请在检查器中勾选 Autoplay。<br>可以在脚本中调用 VideoStreamPlayer 节点的 play() 开始播放。</p>
<p>处理大小变化及不同的纵横比<br>Godot 4.0 中在默认情况下，VideoStreamPlayer 会自动调整到与视频分辨率相匹配的大小。<br>你可以让它遵循普通的 Control 大小规则，启用 VideoStreamPlayer 节点的 Expand 即可。<br>要调整 VideoStreamPlayer 节点的大小随窗口大小改变的方式，通过 2D 编辑器视口顶部的布局按钮调整锚点。<br>不过，这种设置可能不足以处理所有可能的情况，例如全屏播放视频但不造成形变（需要在边界处留白）。<br>要进行精确控制，可以使用专用的 AspectRatioContainer 节点：</p>
<ol>
<li>确保不是任何其他容器节点的子节点。</li>
<li>在 2D 编辑器的顶部将布局设置为整个矩形。</li>
<li>将  Ratio（比例）设置为与视频的长宽比匹配的比例。<br> 可以在检查器里直接输入数学公式。请记住要将其中的一个操作数写成浮点形式，否则会得到整数的商。</li>
<li>配置好 AspectRatioContainer 之后，将 VideoStreamPlayer 节点调整为该 AspectRatioContainer 节点的子节点。 </li>
<li>确保禁用了该 VideoPlayer 的 Expand。 现在应该就会自动适应到全屏的大小，不产生变形。<blockquote>
<p>有关在项目中支持多种纵横比的更多技巧，请参阅 多分辨率。</p>
</blockquote>
</li>
</ol>
<p>在 3D 表面上显示视频<br>使用 VideoStreamPlayer 节点作为 SubViewport 节点的子节点，就可以在 3D 表面上显示任何 2D 节点。<br>可以使用以下步骤实现：</p>
<ol>
<li>创建一个 SubViewport 节点。将其设置为与视频大小相匹配的像素大小。</li>
<li>创建一个 VideoStreamPlayer 子节点，并为其指定一个视频的路径。请确保禁用了 Expand，需要时启用 Autoplay。</li>
<li>创建一个 MeshInstance3D 节点，将其 Mesh 属性设为 PlaneMesh 或 QuadMesh。将该网格的大小调整到与视频的长宽比一致（否则看上去就会变形）。</li>
<li>在 GeometryInstance3D 部分的 Material Override 属性中新建一个 StandardMaterial3D 资源。</li>
<li>在该 StandardMaterial3D（底部）的 Resource 部分启用 Local To Scene。这是在 Albedo Texture 属性中使用 ViewportTexture 所必须的。</li>
<li>在该 StandardMaterial3D中，将 Albedo &gt; Texture 属性设置为新建 ViewportTexture。<br> 点击编辑这个新的资源，在 Viewport Path 属性中指定指向 SubViewport 节点的路径。</li>
<li>在该 StandardMaterial3D 中启用 Albedo Texture Force sRGB，防止颜色变化。</li>
<li>如果广告板需要自发光，请将 着色模式 设置为 无阴着色 以提高渲染性能。<blockquote>
<p>更多关于设置的信息，请参阅 使用视口 和 3D GUI 演示。</p>
</blockquote>
</li>
</ol>
<p>循环视频<br>启用 Loop 属性。<br>请注意，将项目设置 视频延迟补偿 设置为非零的值可能会导致视频循环不再无缝，因为音频和视频的同步发生在每个循环开始时，会导致偶尔丢失帧。<br>将项目设置中的 视频延迟补偿 设置为 0 以避免丢帧问题。</p>
<p>视频解码条件及推荐分辨率<br>由于 GPU 在解码 Theora 视频时没有硬件加速，所以视频解码是在 CPU 上执行的。<br>现代的桌面 CPU 可以以 1440p @ 60 FPS 或更高的速度解码 Ogg Theora 格式的视频，但低端移动 CPU 处理高分辨率视频可能会比较吃力。<br>为了确保视频在各种硬件上都能够顺利解码：</p>
<ul>
<li>为桌面平台开发游戏时，建议最多编码为 1080p（最好是 30 FPS）。<br>  大多数人还在使用 1080p 或者更低分辨率的显示器，所以编码为更高分辨率的视频可能不值那些增大的文件大小和 CPU 需求。</li>
<li>为移动和 Web 平台开发游戏时，建议最多编码为 720p（最好是 30 FPS 或更低）。移动设备上 720p 和 1080p 的视频通常很难看出区别。</li>
</ul>
<p>播放限制</p>
<ol>
<li>不支持从 URL 播放视频流。</li>
<li>仅支持单声道和立体声音频输出。支持具有 4、5.1 和 7.1 音频通道的视频，但向下混合为立体声。</li>
</ol>
<p>推荐 Theora 编码设置<br>建议是（在大多数情况下）避免依赖内置的 Ogg Theora 导出器。<br>你可能想要优先使用外部程序编码视频的原因有 2 个：</p>
<ol>
<li>Blender 等程序可以渲染 Ogg Theora。然而，默认的质量预设就如今的标准而言通常是非常低的。<br> 你可能可以在软件里提高质量选项，但输出的质量可能仍然不理想（提升了文件大小）。<br> 这通常意味着那个软件只支持按照固定比特率（CBR）去进行编码，不支持可变比特率（VBR）。<br> 大多数场合应该都优先使用 VBR 编码，因为在相同的文件大小下能够提供更好的质量。</li>
<li>有些其他的程序根本无法渲染 Ogg Theora。</li>
</ol>
<p>在这种情况下，你可以将视频使用高质量格式渲染作为中介（例如高比特率 H.264 视频），然后再重新编码成 Ogg Theora。<br>理想情况下，你应该使用无损或者未压缩格式作为中介格式，最大化输出 Ogg Theora 视频的质量，不过这样做会需要大量的磁盘空间。</p>
<p>FFmpeg （CLI） 是用于此目的的流行开源工具。FFmpeg 的学习曲线很陡峭，但它是一个强大的工具。<br>这是将 MP4 视频转换为 Ogg Theora 的 FFmpeg 命令示例。<br>因为 FFmpeg 支持很多输入格式，几乎任何输入视频格式（AVI、MOV、WebM……）应该都可以使用下面的命令。</p>
<blockquote>
<p>请确保你的 FFmpeg 副本是启用 libtheora 和 libvorbis 编译的。检查方法是不带任何参数执行 ffmpeg，然后查看命令输出中的 configuration: 一行。</p>
</blockquote>
<p>警告<br>当前官方 FFmpeg 版本的 Ogg&#x2F;Theora 多路复用器中存在一些错误。<br>强烈建议使用最新的静态每日构建之一，或从其主分支构建以获取最新修复。</p>
<p>平衡质量与文件大小</p>
<ol>
<li><strong>视频质量</strong>等级（-q:v）必须在 1 和 10 之间。<br>将质量设为 6 是在质量和文件大小之间的一个不错的妥协。<br>如果要编码较高的分辨率（例如 1440p 或者 4K），你可能想要把 -q:v 降为 5，把文件大小控制在合理的范围内。<br>因为 1440p 和 4K 视频的像素密度更高，相较于低分辨率的视频，较低的质量预设看上去的效果是一样甚至更好的。</li>
<li><strong>音频质量</strong>等级（-q:a）必须在 -1 和 10 之间。<br>将质量设为 6 是在质量和文件大小之间的一个不错的妥协。<br>与视频质量不同，提升音频质量并不会显著增加输出文件的大小。<br>因此，如果你想要尽可能清晰的音频，可以将其设为 9，达到感知上无损的音频。<br>在你的输入文件使用的已经是有损音频压缩时，这个设置尤其有用。<br>更高质量的音频确实会增加解码器的 CPU 使用率，因此在系统负载较高的情况下可能会导致音频丢失。<br>Ogg Vorbis 音频质量预设及其对应的可变比特率表见这个页面。</li>
<li>**GOP（图片组）**大小 （-g：v） 是关键帧之间的最大间隔。<br>增加此值可以提高压缩率，而对质量几乎没有影响。<br>默认大小 （12） 对于大多数类型的内容来说太低，因此建议在降低视频质量之前使用更高的 GOP 值。<br>不过，随着 GOP 规模的增加，压缩优势将逐渐消失。64 到 512 之间的值通常提供最佳压缩。<blockquote>
<p>更高的 GOP 大小将增加最大寻道时间，当从 64 开始超过 2 的幂时会突然增加。GOP 大小的最大寻道时间 65 的长度几乎是 GOP 尺寸 64 的两倍，具体取决于解码速度。</p>
</blockquote>
</li>
</ol>
<p>FFmpeg：转换时保持原始视频分辨率<br>以下命令会在保持原始分辨率的前提下对视频进行转换。<br>视频和音频的比特率会被设为可变，在最大化质量的同时在不需要高比特率视频&#x2F;音频的时候节省空间（例如静态场景）。<br>ffmpeg -i input.mp4 -q:v 6 -q:a 6 -g:v 64 output.ogv</p>
<p>FFmpeg：调整视频大小并转换<br>以下命令会在保持现有长宽比的前提下将视频调整到 720 像素高（720p）。<br>如果原始文件分辨率是大于 720p 的，就能够显著降低文件大小：<br>ffmpeg -i input.mp4 -vf “scale&#x3D;-1:720” -q:v 6 -q:a 6 -g:v 64 output.ogv</p>
<p>色键视频<br>色键（Chroma Key）也就是“绿幕”效果，能够移除图像或视频中的特定颜色，替换为其他背景。<br>我们将通过在 GDScript 中编写自定义着色器，并使用 VideoStreamPlayer 节点来显示视频内容来实现色键效果。</p>
<p>场景设置<br>确保场景包含用于播放视频的 VideoStreamPlayer 节点，和用于保存用于控制色键效果的 UI 元素的 Control 节点。<br><img src="https://wzcwzc10.github.io/posts_img/godot/06/chroma_key_scene.webp"></p>
<p>编写自定义着色器<br>要实现色键效果，请按照下列步骤操作：</p>
<ol>
<li>选择场景中的 VideoStreamPlayer 节点。</li>
<li>在 CanvasItem &gt; Material 下，创建一个名为“ChromaKeyShader.gdshader”的新着色器。</li>
<li>在“ChromaKeyShader.gdshader”文件中，编写自定义着色器代码，如下所示：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">shader_type canvas_item;</span><br><span class="line"></span><br><span class="line">// 色度键（绿幕）透明效果的统一变量</span><br><span class="line">uniform vec3 chroma_key_color : source_color = vec3(0.0, 1.0, 0.0); // 要抠除的基准颜色，默认为绿色</span><br><span class="line">uniform float pickup_range : hint_range(0.0, 1.0) = 0.1;            // 抠取范围，颜色距离在此范围内将被完全透明化</span><br><span class="line">uniform float fade_amount : hint_range(0.0, 1.0) = 0.1;             // 过渡边缘的渐变宽度，实现柔和边缘</span><br><span class="line"></span><br><span class="line">void fragment() &#123;</span><br><span class="line">    // 获取当前纹理在指定UV坐标处的颜色值</span><br><span class="line">    vec4 color = texture(TEXTURE, UV);</span><br><span class="line"></span><br><span class="line">    // 计算当前像素颜色与设定的色键颜色之间的欧几里得距离</span><br><span class="line">    float distance = length(color.rgb - chroma_key_color);</span><br><span class="line"></span><br><span class="line">    // 如果颜色距离小于等于抠除范围，则丢弃该像素（使其完全透明）</span><br><span class="line">    // 距离越小，颜色越接近设定的色键颜色，越容易被抠除</span><br><span class="line">    if (distance &lt;= pickup_range) &#123;</span><br><span class="line">        discard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据抠除范围和渐变宽度，计算透明度的平滑过渡因子</span><br><span class="line">    float fade_factor = smoothstep(pickup_range, pickup_range + fade_amount, distance);</span><br><span class="line"></span><br><span class="line">    // 输出最终颜色：RGB 保持原样，Alpha 通道使用计算出的渐变因子</span><br><span class="line">    COLOR = vec4(color.rgb, fade_factor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>着色器使用距离计算来识别接近色键颜色的像素并将其丢弃，从而有效地删除所选颜色。<br>距离色键颜色稍远的像素将根据 fade_factor 进行淡入淡出，从而使它们与周围的颜色平滑地混合。<br>此过程会创建所需的色键效果，使其看起来像是背景已被其他图像或视频替换。<br>上面的代码是色键着色器的简单演示，用户可以根据自己的具体要求进行自定义。</p>
<p>UI 控件<br>为了允许用户实时操纵色键效果，我们在 Control 节点中创建了滑动条。<br>Control 节点的脚本包含以下功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">extends Control</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _on_color_picker_button_color_changed(color):</span><br><span class="line">    # 更新 VideoStreamPlayer 节点材质中的 &quot;chroma_key_color&quot; 着色器参数</span><br><span class="line">    $VideoStreamPlayer.material.set(&quot;shader_parameter/chroma_key_color&quot;, color)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _on_h_slider_value_changed(value):</span><br><span class="line">    # 更新 VideoStreamPlayer 节点材质中的 &quot;pickup_range&quot; 着色器参数</span><br><span class="line">    $VideoStreamPlayer.material.set(&quot;shader_parameter/pickup_range&quot;, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _on_h_slider_2_value_changed(value):</span><br><span class="line">    # 更新 VideoStreamPlayer 节点材质中的 &quot;fade_amount&quot; 着色器参数</span><br><span class="line">    $VideoStreamPlayer.material.set(&quot;shader_parameter/fade_amount&quot;, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _on_video_stream_player_finished():</span><br><span class="line">    # 视频播放结束后自动重新开始播放</span><br><span class="line">    $VideoStreamPlayer.play()</span><br></pre></td></tr></table></figure>
<p>还要确保滑动条的范围合适，此处我们的设置是：</p>
<p>信号处理<br>将适当的信号从 UI 元素连接到你创建的 Control 节点的脚本上，来控制色键效果。这些信号处理函数会更新着色器的 uniform 变量，响应用户输入。<br>保存并运行场景来查看色键效果的实际表现！<br>通过 godot 提供的 UI 控件，现在你可以实时调整色键颜色、拾取范围（pickup range）和淡入度量（fade amount），从而为你的视频内容实现所需的色键功能。</p>
<h3 id="创建电影"><a href="#创建电影" class="headerlink" title="创建电影"></a>创建电影</h3><p>Godot 可以为任何 2D 或 3D 项目录制非实时音视频(离线渲染)适合很多不同的场景：</p>
<ul>
<li>录制游戏预告片以供宣传使用。</li>
<li>录制过场动画。</li>
<li>记录程序生成的动画或动作设计。在视频录制过程中，仍可以进行用户交互，录制的视频中也可以包含音频（尽管在录制视频时你将无法听到它）。</li>
<li>比较动画场景中图形设置、着色器或渲染技术的视觉输出。<br>借助 Godot 的动画功能，例如 AnimationPlayer 节点、Tweeners、粒子和着色器，它可以有效地用于创建任何类型的 2D 和 3D 动画（以及静态图像）。</li>
</ul>
<p>使用 Godot 进行视频渲染比 Blender 更加高效。<br>也就是说，非实时渲染器（例如 Cycles 和 Eevee）可以带来更好的视觉效果（代价是更长的渲染时间）。</p>
<p>与实时视频录像相比，非实时录像的一些优点包括：</p>
<ul>
<li>无论你的硬件性能如何，都可以使用任何图形设置（包括要求极高的设置）。输出视频 始终 具有完美的帧节奏；它永远不会出现丢帧或卡顿的情况。更快的硬件将允许你在更短的时间内渲染给定的动画，而视觉输出保持不变。</li>
<li>以比屏幕分辨率更高的分辨率进行渲染，而无需依赖特定于驱动程序的工具，例如 NVIDIA 的动态超级分辨率（Dynamic Super Resolution）或 AMD 的虚拟超级分辨率（Virtual Super Resolution）。</li>
<li>以高于视频目标帧率的帧率进行渲染，然后进行后处理以生成高质量的运动模糊。这也使得在多个帧上聚合的效果（例如时间抗锯齿、SDFGI 和体积雾）看起来更好。</li>
</ul>
<p>警告<br>此功能并非专为在游戏中捕捉实时镜头而设计。<br>玩家应该使用<code>OBS Studio</code>或<code>SimpleScreenRecorder &lt;https://www.maartenbaert.be/simplescreenrecorder/&gt;</code> 之类的工具来录制游戏视频，因为它们可以更好地截取合成器的输出，比 Godot 使用 Vulkan 或 OpenGL 所能完成的工作要多。<br>也就是说，如果你的游戏在录制时以接近实时的速度运行，你仍可以使用此功能（但它将缺少可被听见的音频播放，因为音频会直接保存到视频文件中）。</p>
<p>启用 Movie Maker 模式<br>在运行项目之前单击编辑器右上角的“电影胶片卷”（movie reel）按钮：<br>将显示一个菜单，其中包含启用 Movie Maker 模式和转到设置的选项。<br>启用 Movie Maker 模式时，图标将获得与强调色匹配的背景：<br>当编辑器退出时，Movie Maker 状态 不会 保留，因此如果需要，你必须在重新启动编辑器后再次重新启用 Movie Maker 模式。</p>
<blockquote>
<p>在项目重新启动之前，运行项目时切换 Movie Maker 模式不会产生任何效果。</p>
</blockquote>
<p>在通过运行项目录制视频之前，仍然需要配置输出文件路径。可以在项目设置中为所有场景设置该路径：<br>或者，你可以通过将名为 movie_file 的 String 元数据添加到场景的 根节点 ，来设置每个场景的输出文件路径。仅当主场景设置为相关场景时，或者通过按 F6<code>（在 macOS 上 :kbd:</code>Cmd + R）直接运行场景时，该功能才会被使用。</p>
<p>项目设置或元数据中指定的路径可以是绝对路径，也可以是相对于项目根目录的路径。<br>在配置并启用 Movie Maker 模式后，从编辑器运行项目时将自动使用该模式。</p>
<p>命令行用法<br>Movie Maker 也可以通过命令行启用：<br>godot –path &#x2F;path&#x2F;to&#x2F;your_project –write-movie output.avi<br>如果输出路径是相对路径，那么它是 相对于项目文件夹 ，而不是当前工作目录。<br>在上面的示例中，文件将被写入 &#x2F;path&#x2F;to&#x2F;your_project&#x2F;output.avi。<br>此行为类似于 –export 命令行参数。<br>由于 Movie Maker 的输出分辨率是由视口大小设置的，因此如果项目使用 disabled 或 canvas_items 拉伸模式，你可以在启动时调整窗口大小以覆盖它：<br>godot –path &#x2F;path&#x2F;to&#x2F;your_project –write-movie output.avi –resolution 1280x720<br>请注意，窗口大小受显示器分辨率的限制。如果你需要以比屏幕分辨率更高的分辨率录制视频，请参阅 以比屏幕分辨率更高的分辨率进行渲染。<br>录制的 FPS 也可以在命令行上覆盖，而无需编辑项目设置：<br>godot –path &#x2F;path&#x2F;to&#x2F;your_project –write-movie output.avi –fixed-fps 30</p>
<p>备注<br>–write-movie 和 –fixed-fps 命令行参数在导出的项目中都可用。<br>项目运行时无法切换 Movie Maker 模式，但可以使用 OS.execute() 方法来运行导出项目的第二个实例以录制视频文件。</p>
<p>选择输出格式<br>输出格式由 MovieWriter 类提供。Godot 有 3 个内置的 MovieWriters，更多可以通过扩展实现：<br>OGV（推荐）<br>OGV 容器，其中 Theora 用于视频，Vorbis 用于音频。具有有损视频和音频压缩功能，在文件大小和编码速度之间取得了良好的平衡，图像质量比 MJPEG 更好。它有 4 个速度级别，可以通过更改编辑器 &gt; Movie Writer &gt; 编码速度来调整，最快的速度与 AVI 一样快，压缩率更好。在较慢的速度水平下，它可以更好地压缩，同时保持相同的图像质量。可以通过更改视频的编辑器 &gt; Movie Writer &gt; 视频质量和音频的编辑器 &gt; Movie Writer &gt; 音频质量来调整有损压缩质量。<br>关键帧间隔可以通过更改编辑器 &gt; Movie Writer &gt; 关键帧间隔来调整。在某些情况下，增加此设置可以提高压缩效率，而不会造成任何缺点。<br>生成的文件可以在 Godot 中使用 VideoStreamPlayer 和大多数视频播放器查看，但不能在网络浏览器中查看。OGV 不支持透明度。<br>要使用 OGV，请在编辑器 &gt; Movie Writer &gt; 影片文件项目设置中指定要创建的 .ogv 文件的路径。</p>
<blockquote>
<p>OGV 只能在编辑器版本中录制。另一方面，OGV 播放 在编辑器和导出模板构建中都是可能的。</p>
</blockquote>
<p>AVI<br>带有 MJPEG 的 AVI 容器，用于视频和未压缩音频。具有有损视频功能 压缩，从而产生中等文件大小和快速编码。<br>有损压缩质量可以通过更改来调整 编辑 &gt; 电影编剧 &gt; 视频质量 。<br>生成的文件可以在大多数视频播放器中查看，但必须将其转换为另一种格式才能在 Web 上查看，或在 Godot 使用 VideoStreamPlayer 节点查看。 MJPEG 不支持透明度。 AVI 输出的文件大小目前限制为最大 4 GB。<br>要使用 AVI，请 .avi 在 编辑器 &gt; Movie Writer &gt; Movie File 项目设置。</p>
<p>PNG<br>用于视频的 PNG 图像序列和用于音频的 WAV。具有无损视频压缩功能，但代价是文件较大且编码速度较慢。这被设计为 录制后使用外部工具编码为视频文件。<br>支持透明度，但根视口 必须 将其 transparent_bg 属性设置为 true ，以使透明度在输出图像上可见。这可以通过启用 渲染 &gt; 视口 &gt; 透明背景 高级项目设置来实现。 显示 &gt; 窗口 &gt; 大小 &gt; 透明 和 显示 &gt; 窗口 &gt; 像素级透明度 &gt; 启用 可以选择启用，以允许在录制视频时预览透明度，但不必在录制视频时启用它们。输出图像包含透明度。<br>要使用 PNG，请指定要在 编辑器 &gt; Movie Writer &gt; 电影文件 项目设置中创建的 .png 文件。生成的 .wav 文件将与 .png 文件同名（去掉扩展名的话）。</p>
<p>自定义<br>如果你需要直接编码为不同的格式或通过第三方软件传输数据流，可以扩展 MovieWriter 类来创建你自己的电影编写器（movie writers）。出于性能原因，这通常应该使用 GDExtension 来完成。</p>
<p>配置<br>在项目设置的 编辑器 &gt; Movie Writer 部分中可配置多个选项。其中一些仅在启用“项目设置”对话框右上角的 高级选项 后才可见。</p>
<ul>
<li>混音率： 编写电影时在录制的音频中使用的音频混合率。这可能与项目的混合速率不同，但该值必须能被录制的 FPS 整除，以防止音频随着时间的推移而失去同步。</li>
<li>扬声器模式： 编写电影时录制的音频中使用的扬声器模式（stereo 立体声、5.1 环绕声或 7.1 环绕声）。</li>
<li>视频质量： 将视频写入 OGV 或 AVI 文件时使用的图像质量，介于 0.01 到 1.0（含）之间。更高的质量值会导致输出更好看，但代价是文件大小更大。建议的质量值介于 0.75 和 0.9 之间。即使在质量 1.0 下，压缩仍然是有损的。此设置不会影响音频质量，并且在写入 PNG 图像序列时将被忽略。</li>
<li>电影文件： 电影的输出路径。这可以是绝对路径，或相对于项目根目录的相对路径。</li>
<li>禁用垂直同步： 如果启用，则在写入电影时请求禁用垂直同步。如果硬件足够快，能够以高于显示器刷新率的帧速率渲染、编码和保存视频，这可以加快视频写入速度。如果操作系统或图形驱动程序强制垂直同步且应用程序无法禁用它，则此设置无效。</li>
<li>FPS： 输出影片中每秒渲染的帧数。值越高，动画越平滑，但代价是渲染时间更长和输出文件大小更大。大多数视频托管平台不支持高于 60 的 FPS 值，但你可以使用更高的值并用它来生成运动模糊。</li>
<li>音频质量： 将视频写入 OGV 文件时使用的音频质量，介于 -0.1 和 1.0（含）之间。更高的质量值会导致更好的音频质量，但代价是文件大小稍大。建议的质量值介于 0.3 到 0.5 之间。即使在质量上 1.0，压缩保持有损。</li>
<li>编码速度： 将视频写入 OGV 文件时要使用的速度级别。速度水平越快，压缩效率越低。图像质量几乎保持不变。</li>
<li>关键帧间隔： 也称为 GOP（图片组），写入 OGV 文件时使用的最大帧间数。较高的值可以提高压缩效率而不会造成质量损失，但代价是视频搜索速度较慢。</li>
</ul>
<p>备注<br>当使用 disabled 或 2d 拉伸模式 时，输出文件的分辨率由窗口大小设置。确保在启动画面结束 之前 调整窗口大小。为此，建议调整高级设置中的 显示 &gt; 窗口 &gt; 大小 &gt; 窗口宽度覆盖 和 窗口高度覆盖 。<br>另见 以比屏幕分辨率更高的分辨率进行渲染。</p>
<p>退出 Movie Maker 模式<br>为了安全退出使用 Movie Maker 模式的项目，请使用窗口顶部的 X 按钮，或在脚本中调用 get_tree().quit()。你也可以使用 –quit-after N 命令行参数，其中 N 是退出前要渲染的帧数。<br>不建议按 F8 （ Cmd + . 在 macOS 上）或按 运行 Godot 的终端 Ctrl + C ，因为这会导致格式不正确的 AVI 文件，没有持续时间信息。对于 PNG 图像序列，PNG 图像不会受到负面更改，但关联的 WAV 文件仍将缺少持续时间信息。OGV 文件最终的持续时间视频和音轨可能略有不同，但仍然有效。<br>某些视频播放器可能仍然能够播放包含有效视频和音频的 AVI 或 WAV 文件。但是，使用 AVI 或 WAV 文件的软件（例如视频编辑器）可能无法打开该文件。在这些情况下，使用视频转换器程序 可以提供一些帮助。<br>如果你使用 AnimationPlayer 来控制场景中的“主要动作”（例如摄像机移动），则可以在相关的 AnimationPlayer 节点上启用 Movie Quit On Finish 属性。启用后，当动画播放完毕 并且 引擎在 Movie Maker 模式下运行时，此属性将使 Godot 自行退出。请注意， 此属性对循环动画没有影响 。因此，你需要确保动画设置为非循环。</p>
<p>使用高质量的图形设置<br>movie 功能标签 可用于覆盖特定的项目设置。这对于启用高质量图形设置来说非常有用，但这些设置的速度不足以在硬件上以实时速度运行。<br>请记住，将每个设置设为最大值仍然会降低影片保存速度，尤其是在以更高分辨率录制时。<br>因此，建议仅在图形设置对输出图像产生可以有价值的影响时，再增加图形设置。<br>还可以在脚本中查询此功能标签，以提高环境资源中设置的质量设置。例如，为了进一步改善 SDFGI 细节并减少漏光：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extends Node3D</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	if OS.has_feature(&quot;movie&quot;):</span><br><span class="line">		# When recording a movie, improve SDFGI cell density</span><br><span class="line">		# without decreasing its maximum distance.</span><br><span class="line">		get_viewport().world_3d.environment.sdfgi_min_cell_size *= 0.25</span><br><span class="line">		get_viewport().world_3d.environment.sdfgi_cascades = 8</span><br></pre></td></tr></table></figure>
<p>以比屏幕分辨率更高的分辨率进行渲染<br>通过4K或8K等高分辨率渲染可以显着提高整体渲染质量。</p>
<p>备注<br>对于 3D 渲染，Godot 在高级项目设置中提供了 渲染 &gt; 缩放 3D &gt; 缩放 ，可以将其设置为高于 1.0 以获得 超采样抗锯齿 。当 3D 渲染在视口上绘制时，它会被 降采样 。这提供了一种性能代价高昂但高质量的抗锯齿形式，并且不会增加最终的输出分辨率。<br>首先考虑使用此项目设置，因为与实际增加输出分辨率相比，它可以避免减慢影片写入速度和增加输出文件大小。<br>如果你希望以更高分辨率渲染 2D，或者实际上你需要更高的原始像素输出来进行 3D 渲染，则可以将分辨率提高到屏幕允许的分辨率之上。<br>默认情况下，Godot 在项目中使用 disabled 拉伸模式 。如果使用 disabled 或 canvas_items 拉伸模式，窗口大小决定输出视频分辨率。<br>另一方面，如果项目配置中使用 viewport 拉伸模式，则视口分辨率会决定输出视频分辨率。视口分辨率使用 显示 &gt; 窗口 &gt; 大小 &gt; 视口宽度 和 视口高度 项目设置进行设置。这可用于以比屏幕分辨率更高的分辨率渲染视频。<br>要在录制过程中缩小窗口而不影响输出视频分辨率，可以将高级项目设置中 显示 &gt; 窗口 &gt; 大小 &gt; 窗口宽度覆盖 和 窗口高度覆盖 设置为大于 0 的值。<br>要仅在录制电影时应用分辨率覆盖，可以使用 movie 功能标签 来覆盖这些设置。</p>
<p>后期处理步骤<br>以下列出一些常见的后期处理步骤。</p>
<blockquote>
<p>当使用多步后处理时，请尝试在单一 FFmpeg命令中执行所有这些步骤。这将避免掉多个有损的编码步骤从而节省编码时间并提高品质。</p>
</blockquote>
<p>将 OGV&#x2F;AVI 视频转换为 MP4<br>尽管 YouTube 等一些平台支持直接上传 AVI 文件，但许多其他平台则需要事先进行格式转换。HandBrake（GUI）和 FFmpeg（CLI）都是这方面非常流行的开源工具。FFmpeg 的学习曲线相对陡峭，但功能也更强大。<br>以下命令将 OGV&#x2F;AVI 视频转换为恒定速率因子 （CRF） 为 15 的 MP4 （H.264） 视频。这会导致文件相对较大，但非常适合重新编码视频以减小其大小的平台（例如大多数视频共享网站）：<br>ffmpeg -i input.avi -crf 15 output.mp4<br>要以牺牲质量为代价获得较小的文件，请 增加 上述命令中的 CRF 值。<br>要获得具有更好的大小&#x2F;质量比的文件（以较慢的编码时间为代价），请在上述命令中的 -crf 15 之前添加 -preset veryslow。相反地，-preset veryfast 可用于实现更快的编码，但代价是尺寸&#x2F;质量比更差。<br>将 PNG 图像序列 + WAV 音频转换为视频<br>如果你选择录制 PNG 图像序列和 WAV 文件，则需要先将其转换为视频，然后才能在其他地方使用。<br>Godot 生成的 PNG 图像序列的文件名始终包含 8 位数字，从 0 开始，数字以零填充。如果指定输出路径 folder&#x2F;example.png ，Godot 将在该文件夹中写入 folder&#x2F;example00000000.png 、 folder&#x2F;example00000001.png 等。音频将保存在 folder&#x2F;example.wav 中。<br>FPS 使用 -r 参数指定。它应该与录制期间指定的 FPS 相匹配。否则视频会显得速度减慢或加快，并且音频与视频不同步。<br>ffmpeg -r 60 -i input%08d.png -i input.wav -crf 15 output.mp4<br>如果你在启用透明度的情况下录制了 PNG 图像序列，则需要使用支持存储透明度的视频格式。 MP4&#x2F;H.264 不支持存储透明度，因此可以使用 WebM&#x2F;VP9 作为替代方案：<br>ffmpeg -r 60 -i input%08d.png -i input.wav -c:v libvpx-vp9 -crf 15 -pix_fmt yuva420p output.webm</p>
<p>视频剪辑<br>录制视频后你可以剪辑掉不想保留的视频部分。例如，要丢弃 12.1 秒之前的所有内容，并仅保留该点之后 5.2 秒的视频：<br>ffmpeg -i input.avi -ss 00:00:12.10 -t 00:00:05.20 -crf 15 output.mp4<br>也可以使用 GUI 工具 LosslessCut 来剪辑视频。</p>
<p>视频缩放<br>以下命令将视频大小调整为 1080 像素高 (1080p)，同时保留其现有的宽高比：<br>ffmpeg -i input.avi -vf “scale&#x3D;-1:1080” -crf 15 output.mp4<br>降低帧率<br>下面的命令会将视频的帧率更改为 30 FPS，如果输入视频中帧率更高，则会丢弃一些原始帧：<br>ffmpeg -i input.avi -r 30 -crf 15 output.mp4<br>使用 FFmpeg 生成累积运动模糊<br>Godot 没有内置对运动模糊的支持，但仍然可以在录制的视频中创建运动模糊。<br>如果你以原始帧率的几倍来录制视频，则可以将帧混合在一起，然后再减少帧率以生成具有 累积运动模糊 的视频。这种运动模糊看起来很棒，但因为必须每秒渲染更多帧，生成可能需要很长时间（除了后期处理所花费的时间之外）。<br>以 240 FPS 的源视频为例，生成 4 倍运动模糊并将其输出帧率降低至 60 FPS：<br>ffmpeg -i input.avi -vf “tmix&#x3D;frames&#x3D;4, fps&#x3D;60” -crf 15 output.mp4<br>因为这个操作将能够在给定时间内处理更多数据，所以也会使得在多个帧上的收敛效果（例如时间抗锯齿、SDFGI 和体积雾）变得更快，因此看起来表现更好。如果你想在不添加运动模糊的情况下获得这个表现提升，请参阅 降低帧率。</p>
<h2 id="资产管线"><a href="#资产管线" class="headerlink" title="资产管线"></a>资产管线</h2><h3 id="导入流程"><a href="#导入流程" class="headerlink" title="导入流程"></a>导入流程</h3><p>Godot 内部会自动导入外部导入文件，存放在隐藏的 res:&#x2F;&#x2F;.godot&#x2F;imported&#x2F; 文件夹中。<br>在代码中尝试访问导入后的资产需要使用资源加载器(ResourceLoader)，因为会自动考虑内部文件的存储位置。<br>如果用 <code>FileAccess</code> 尝试访问导入后的资产，虽然在编辑器中是可行的，但是在导出后的项目中会失败。<br>然而资源加载器(ResourceLoader)无法访问未经导入的文件，只有 <code>FileAccess</code> 类可以。</p>
<p>更改导入参数<br>要在 Godot 中更改资产的导入参数，请在“文件系统”面板中选中相关的资源：<br>参数调整完毕后，单击重新导入。<br>还可以同时更改多个资产的导入参数。<br>在文件系统停靠栏中一起选择所有这些参数，重新导入时，公开的参数将应用于所有这些参数。<br>当源资产的 MD5 校验发生变化时,Godot 将执行自动重新导入, 应用为该特定资产配置的预设.</p>
<p>重新导入多个资产<br>在进行项目时有数个资产都需要修改同一个参数的情况，例如启用 mipmap，只改动特定的参数。<br>为此，请选择要重新导入的多个资产。现在导入选项卡的每个导入参数的左边都会出现一个复选框。</p>
<p>生成的文件<br>导入时会在源文件的旁边生成额外的 &lt;资产&gt;.import 文件，包含的是导入配置。<br>请务必将这些文件提交进版本控制系统，包含重要元数据。<br>此外，额外的资产会被放在隐藏的 res:&#x2F;&#x2F;.godot&#x2F;imported&#x2F; 文件夹中：<br>如果此文件夹中的任何文件（或整个文件夹）被删除，则会自动重新导入资产。<br>因此，不建议将 .godot&#x2F; 文件夹提交给版本控制系统。提交这个文件夹虽然能够缩短在另一台计算机上检出后重新导入的时间，但是需要相当多的空间和带宽。<br>在项目创建时生成的默认版本控制元数据将自动忽略 .godot&#x2F; 文件夹。</p>
<p>更改导入资源类型<br>一些源资产可以作为不同类型的资源被导入。为此，选择所需资源的相关类型，然后点击 重新导入 即可：</p>
<ul>
<li>选择 Keep File (exported as is) 作为资源类型以跳过文件导入，具有此资源类型的文件将在项目导出期间按原样保留。</li>
<li>选择 Skip File (not exported) 作为资源类型以跳过文件导入并在项目导出期间忽略文件。</li>
</ul>
<p>更改默认导入参数<br>不同类型的游戏可能需要不同的默认值。<br>通过使用<strong>预设按钮</strong>菜单可以将导入选项更改为预定义的选项集。<br>除了某些提供预设的资产类型外，还可以保存和清除默认设置：<br>可以使用“项目设置”对话框的 默认导入设置 选项卡，在项目范围内更改给定资源类型的默认导入参数：</p>
<h3 id="导入图像"><a href="#导入图像" class="headerlink" title="导入图像"></a>导入图像</h3><p>Godot 可以导入以下图像格式：</p>
<ul>
<li>BMP（.bmp）——不支持每像素 16 位的图像。只支持每像素 1 位、4 位、8 位、24 位和 32 位的图像。</li>
<li>DirectDraw Surface（.dds）——如果纹理中存在 mipmap，则直接加载。 可以使用自定义 mipmap 制作特效。</li>
<li>Khronos 纹理 (.ktx) —— 使用 libktx 解码。仅支持 2D 图像。不支持立方体贴图、纹理数组和去填充（de-padding）。</li>
<li>OpenEXR（.exr）——支持 HDR（强烈推荐使用在全景天空上）。</li>
<li>Radiance HDR（.hdr）——支持 HDR（强烈推荐使用在全景天空上）。</li>
<li>JPEG（.jpg、.jpeg）——由于该格式的限制，不支持透明度。</li>
<li>PNG（.png）——导入时精度限制为每个通道 8 位（无 HDR 图像）。</li>
<li>Truevision Targa（.tga）</li>
<li>SVG （.svg） - 使用 ThorVG 栅格化 SVG 导入它们时。 支持有限 ;复杂向量可能无法正确渲染。 文本必须转换为路径 ; 否则，它不会出现在栅格化图像中。 您可以使用其 ThorVG 的 基于 Web 的查看器 。对于复杂的向量，使用 Inkscape 将它们渲染为 PNG 通常是更好的解决方案。这可以自动化，这要归功于它的 命令行界面 。</li>
<li>WebP（.webp）——WebP 文件支持透明，也支持有损和无损压缩。精度限制是每通道 8 位。</li>
</ul>
<p>导入纹理<br>Godot 中的默认操作是将图像导入为纹理。纹理存储在显存中。<br>纹理的像素数据无法直接从 CPU 访问，除非在脚本中将它们转换回 Image。这就是使绘制纹理变得高效的原因。<br>在文件系统面板中选择图像后，可以调整十多个导入选项：</p>
<p>可以在“导入”面板中选择其他导入资源的类型：</p>
<ul>
<li>BitMap： 1 位单色纹理（旨在用作 TextureButton 和 TouchScreenButton 中的点击遮罩）。<br>  此资源类型无法直接显示在 2D 或 3D 节点上，但可以使用 get_bit 从脚本中查询像素值。</li>
<li>Cubemap： 将纹理导入为 6 面的立方体贴图，并在立方体贴图的侧面（无缝立方体贴图）之间进行插值，可以在自定义着色器中进行采样。</li>
<li>CubemapArray:  将纹理导入为 6 面立方体贴图的集合，可以在自定义着色器中进行采样。<br>  此资源类型只能在使用 Forward+ 或 Mobile 渲染器时显示，而不能显示 Compatibility 渲染器。</li>
<li>Font Data (Monospace Image Font)：（字体数据，等宽图像字体）将图像导入为位图字体，其中所有字符都具有相同的宽度。请参阅 使用字体。</li>
<li>Image： 按原样导入图像。此资源类型无法直接显示在 2D 或 3D 节点上，但可以使用 get_pixel 从脚本中查询像素值。</li>
<li>Texture2D： 将图像导入为2维纹理，适合在 2D 和 3D 表面上显示。这是默认的导入模式。</li>
<li>Texture2DArray： 将图像导入为二维纹理的集合。 Texture2DArray 类似于 3 维纹理，但层之间没有插值。<br>  内置 2D 和 3D 着色器无法显示纹理数组，因此必须在 2D 或 3D 中创建自定义着色器，以显示纹理数组中的纹理。</li>
<li>Texture3D： 将图像导入为3维纹理。这不是应用到3D表面上的2D纹理。 Texture3D 类似于纹理数组，但在层之间进行插值。<br>  通常用于体积雾的 FogMaterial 密度图、particle attractor 向量场、 Environment 3D LUT 颜色校正和自定义着色器。</li>
<li>TextureAtlas： 将图像导入为不同纹理的 图集 。可用于减少动画 2D 精灵的内存使用量。由于缺少内置 3D 着色器的支持，仅支持 2D。</li>
</ul>
<p>对于立方体贴图 ，预期的图像顺序是 X+、X-、Y+、Y-、Z+、Z-（在 Godot 的坐标系中，因此 Y+ 是“向上”，Z- 是“向前”）。<br>以下是可用于立方体贴图图像的模板（右键单击 &gt; 链接另存为…）：</p>
<p>检测 3D<br>默认的导入选项（不带 mipmap 并且使用 Lossless 压缩）适合 2D，对于大多数 3D 项目而言并不理想。<br>检测 3D能够让 Godot 关注纹理在 3D 场景中的使用（例如用作 BaseMaterial3D 的纹理）。<br>一旦使用，就会将部分导入选项进行修改，这样纹理标志就对 3D 更友好。<br>除非修改了 检查 3D &gt; 压缩至，否则此时就会启用 mipmap 并将压缩模式修改为 VRAM Compressed。纹理会自动进行重新导入。<br>检测到纹理在 3D 中使用时会在“输出”面板中打印一个消息。<br>如果纹理检测到在 3D 中使用后遇到了质量问题（例如像素风纹理），请在用于 3D 之前修改 检查 3D &gt; 压缩至 选项，或者在用于 3D 之后将 压缩 &gt; 模式 修改为 Lossless。这样比禁用检测 3D 更好，因为仍然会启用 mipmap 生成，从远处观察纹理就不会感觉模糊。</p>
<p>压缩 &gt; 模式</p>
<ul>
<li>Lossless：无损压缩。2D 资产的默认压缩模式。显示资产时不会有任何失真，磁盘压缩也比较合适。<br>  但如果与 VRAM 压缩相比，使用的显存就明显要更多。这也是像素画的推荐设置。</li>
<li>Lossy：有损压缩。适合较大的 2D 资产。会有一些失真，但是比 VRAM 压缩要少，文件大小比无损压缩以及 VRAM 未压缩要小好几倍。<br>  这个模式不会降低显存占用；与无损压缩和 VRAM 未压缩相同。</li>
<li>VRAM Compressed：VRAM 压缩。 3D 资产的默认压缩模式。<br>  会降低磁盘上的大小，显存占用也会显著降低（通常是 4 到 6 倍）。应该避免在 2D 中使用这个模式，因为会有明显的失真，在低分辨率纹理上尤为明显。</li>
<li>VRAM Uncompressed：VRAM 未压缩。仅适用于不能压缩的格式，例如原始浮点数图像。</li>
<li>Basis Universal：这也是一种 VRAM 压缩模式，编码后的纹理格式为能够在加载时转码为大多数 GPU 压缩格式。<br>  这样得到的文件就很小，能够利用 VRAM 压缩，但相对于 VRAM 压缩而言质量较差，压缩耗时也更长。<br>  显存占用通常和 VRAM 压缩相同。Basis Universal 不支持浮点数图像格式（引擎会在内部回退至 VRAM 压缩）。</li>
</ul>
<p>请注意，在分辨率较高的情况下，VRAM 压缩的影响要大得多。<br>当 VRAM 压缩采用 4:1 的压缩比（对于 S3TC 的不透明纹理为 6:1）时，可以在 GPU 上使用相同数量显存的同时，有效地使纹理在每个轴上增大两倍。<br>VRAM 压缩还减少了采样纹理所需的内存带宽，这可以加快在内存带宽受限场景中（集成显卡和移动设备上常见）的渲染速度。<br>综合这些因素，对于具有高分辨率纹理的 3D 游戏来说，VRAM 压缩技术是必备条件之一。<br>可以在文件系统停靠栏中双击纹理，然后查看检查器，来预览纹理占用的内存量</p>
<p>压缩 &gt; 高质量<br>压缩 &gt; HDR 压缩<br>压缩 &gt; 法线贴图<br>压缩 &gt; 通道打包<br>Mipmap &gt; 生成<br>Mipmap &gt; 限制<br>粗糙度 &gt; 模式<br>粗糙度 &gt; 原法线<br>处理 &gt; 修复 Alpha 边框<br>处理 &gt; 预乘 Alpha<br>处理 &gt; 法线贴图翻转 Y<br>处理 &gt; HDR 作为 sRGB<br>处理 &gt; HDR 限制曝光<br>处理 &gt; 大小限制<br>检查 3D &gt; 压缩至<br>SVG &gt; 缩放<br>编辑器 &gt; 使用编辑器缩放<br>编辑器&gt;为浅色编辑器主题转换颜色<br>导入包含文本的 SVG 图像</p>
<h3 id="导入音频采样"><a href="#导入音频采样" class="headerlink" title="导入音频采样"></a>导入音频采样</h3><p>Godot 提供了三个选项来导入音频数据：WAV、Ogg Vorbis 和 MP3。<br>不同的格式各有优点：</p>
<ol>
<li>WAV 文件使用原始数据或轻度压缩（IMA ADPCM 或 Quite OK Audio）。<br> 目前它们只能以原始格式导入，但 Godot 允许在导入后进行压缩。<br> 它们很轻，可以在 CPU 上播放（这种格式的数百个同时语音就可以了）。缺点是它们占用大量磁盘空间。</li>
<li>Ogg Vorbis 文件使用更强的压缩，因此文件更小，但需要更多的处理能力才能播放。</li>
<li>MP3 文件使用比 IMA ADPCM 或 Quite OK Audio 的 WAV 更好的压缩，但比 Ogg Vorbis 差。<br> 这意味着与 Ogg Vorbis 质量大致相同的 MP3 文件将明显更大。从好的方面来说，与 Ogg Vorbis 相比，MP3 需要更少的 CPU 使用率来播放。</li>
</ol>
<p>小技巧<br>请考虑使用 WAV 来实现短且重复的音效<br>使用 Ogg Vorbis 来实现音乐、语音和长音效<br>MP3 对于 CPU 资源有限的移动端项目和 Web 项目来说很有用，特别是在同时播放多个压缩声音（例如长环境声）时</p>
<h3 id="导入翻译"><a href="#导入翻译" class="headerlink" title="导入翻译"></a>导入翻译</h3><p>常规国际化文本通常位于资源文件中（GNU 内容则是 .po 文件）。然<br>而，游戏可以使用比应用程序多几个数量级的文本，因此它们必须支持能高效处理多语言文本加载的方法。</p>
<p>有两种方法来生成多语言的游戏和应用程序（都基于键值对系统）。</p>
<ol>
<li>使用其中一种语言作为“键”（通常是英语）</li>
<li>使用特定的标识符。（同时使用多种语言）<br>一般来说, 游戏使用第二种方法, 并为每个字符串使用唯一的ID.<br>这允许你在翻译为其他语言时修改文本. 唯一ID可以是数字, 字符串, 或带有数字的字符串</li>
</ol>
<p>为了完成图片并允许对翻译的有效支持， Godot 有一个特殊的导入器，可以读取 CSV 文件。<br>大多数电子表格 编辑器可以导出为这种格式，因此唯一的要求是 文件有特殊的安排。<br>看 使用电子表格进行本地化， 以获取有关格式化和导入 CSV 的详细信息。</p>
<h3 id="导入-3D-场景"><a href="#导入-3D-场景" class="headerlink" title="导入 3D 场景"></a>导入 3D 场景</h3><p>可用的 3D 文件格式</p>
<ol>
<li><p>glTF 2.0 （推荐使用）。Godot 完全支持文本（.gltf）和二进制（ .glb ）格式。</p>
</li>
<li><p>.blend （Blender）。这是通过调用 Blender 以透明方式导出到 glTF 来实现的（需要安装 Blender）。</p>
</li>
<li><p>DAE（COLLADA），一个受支持的比较老的格式。</p>
</li>
<li><p>OBJ（Wavefront）格式 + 它们的 MTL 材质文件。这也是完全支持的，但由于格式的限制支持相当有限（不支持轴心、骨架、动画、UV2、PBR 材质……）。</p>
</li>
<li><p>FBX，通过 ufbx 库支持。之前的导入工作流程使用 FBX2glTF 集成。<br> 这需要安装一个外部程序，该程序链接到 专有的 FBX SDK，因此我们建议使用默认的 ufbx 方法或其他格式 上面列出（如果适合您的工作流程）。</p>
</li>
<li><p>从 Blender 导出 glTF 2.0 文件（推荐）</p>
<ol>
<li>作为 glTF 二进制文件（.glb）是较小的选项。包括在 Blender 中设置的网格和纹理。当引入 Godot 时，纹理是对象材质文件的一部分。</li>
<li>作为 glTF 文本文件，二进制数据和纹理独立（.gltf 文件 + .bin 文件 + 纹理）<br> 将 glTF 与纹理分开使用的原因有两个：<br> 一是将场景以基于文本的格式和二进制数据，描述在单独的二进制文件中。这对于版本控制很有用，如果要基于文本格式评审更改。<br> 二是你需要将纹理文件与材质文件分开。如果你不需要其中任何一个，glTF 二进制文件（.glb）就可以了。</li>
</ol>
</li>
</ol>
<p>glTF 导入过程中，首先将 glTF 文件的数据加载到内存中的 <code>GLTFState</code> 类中，然后使用该数据生成 Godot 场景。<br>在运行时导入文件时，可以直接将该场景添加到树中。<br>导出过程则与此相反，Godot 场景被转换为 GLTFState 类，然后从中生成 glTF 文件。<br>在编辑器中导入 glTF 文件时，还有两个步骤：<br>	生成 Godot 场景后，ResourceImporterScene 类用于应用其他导入设置，包括你通过导入面板和高级导入设置对话框配置的设置。<br>	然后将其保存为 Godot 场景文件，这才是你运行&#x2F;导出游戏时使用的文件。</p>
<p class="div-border" style="background-color: rgba(196, 26, 26, 0.1);border: 1px solid #c41a1aff;border-radius: 0.4rem;">
<mark class="hl-label red">警告</mark><br>
如果你的模型包含混合形状（也称为“形状关键帧”和“变形目标”）<br>
则需要将 glTF 导出设置 数据 > 骨架 > 仅导出变形骨骼（Data > Armature > Export Deformation Bones Only） 配置为 启用（Enabled）。<br>
无论如何导出不变形的骨骼都会导致不正确的着色。
</p>

<ol start="2">
<li>直接在 Godot 中导入 .blend 文件<br>编辑器可以通过透明的方式调用 Blender 的 glTF 导出功能来直接导入 .blend 文件。<br>这样可以使你更快地迭代 3D 场景。<br>可以将场景保存在 Blender 中，按 alt-tab 返回 Godot，然后立即查看更改。<br>使用版本控制时也更有效，你不再需要将导出的 glTF 文件的副本提交到版本控制。<br>要使用 .blend 导入，您必须在打开 Godot 编辑器之前安装 Blender（如果打开已包含 .blend 文件的项目）。<br>如果您将 Blender 安装在其默认位置，Godot 应该能够自动检测其路径。<br>如果不是这种情况，请在编辑器设置中配置 Blender 可执行文件的路径（文件系统 &gt; 导入）。<br>.blend 导入过程会首先转换为 glTF，因此仍然使用 Godot 的 glTF 导入代码。因此，.blend 导入过程与 glTF 导入过程相同，但在开始时会有一个额外的步骤。</li>
<li>从 Blender 导出的 DAE 文件<br>Blender 也有内置的 COLLADA 支持，但它无法正常工作以满足游戏引擎的需求，因此不应按原样使用。<br>但是，使用内置 Collada 支持导出的场景可能仍然适用于没有动画的简单场景。<br>对于复杂场景或包含动画的场景，强烈建议改用 glTF。</li>
<li>在 Godot 中导入 OBJ 文件<br>OBJ 是最简单的 3D 格式，Godot 应该能够成功导入大多数 OBJ 文件。<br>不过 OBJ 格式的限制也很多：不支持蒙皮、动画、UV2、PBR 材质。</li>
</ol>
<ul>
<li>在 Godot 中使用 OBJ 网格的方法有两种：<ol>
<li>直接将它们加载到 MeshInstance3D 节点，或任何其他需要网格的属性（例如 GPUParticles3D）中。这是默认模式。</li>
<li>在导入面板中将其导入模式更改为 场景 ，然后重新启动编辑器。<br>  这会允许使用与 glTF 或 Collada 场景相同的导入选项，例如在导入时展开 UV2（对于 使用光照贴图全局照明）。<blockquote>
<p>Blender 3.4 及更高版本可以在 OBJ 文件中导出 RGB 顶点颜色（这是 OBJ 格式的非标准扩展）。Godot 能够导入这些顶点颜色，但它们不会显示在材质上，除非您在材质上启用 顶点颜色 &gt; 用作反照率 。<br>OBJ 网格的顶点颜色在导入后会保留其原始颜色空间（sRGB&#x2F;线性），但其亮度被限制为 1.0（这些颜色不能过亮）。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<ol start="5">
<li>在 Godot 中导入 FBX 文件<br>默认情况下，在 Godot 4.3 或更高版本中，添加到 Godot 项目的任何 FBX 文件都将使用 ufbx 导入方法。<br>任何在如 4.2 等之前的版本中添加到项目的文件将继续通过 FBX2glTF 方法导入，除非你进入该文件的导入设置，并将导入器更改为 ufbx。<br>如果你将 .fbx 文件保留在项目文件夹中，但不希望 Godot 导入它们，请在高级项目设置中禁用 文件系统 &gt; 导入 &gt; FBX &gt; 启用 。<br>如果你想设置 FBX2glTF 的工作流程(一般情况下不推荐)，除非你有具体理由——你需要下载 FBX2glTF 可执行文件<br>然后在编辑器设定 Filesystem &gt; Import &gt; FBX &gt; FBX2glTFPath 中 指定该文件路径<br>FBX 导入过程中会首先转换为 glTF，因此过程仍然使用 Godot 的 glTF 导入代码。FBX 导入过程与 glTF 导入过程相同，但在开始时多了一个额外的步骤。</li>
</ol>
<p>导出模型的注意事项</p>
<ul>
<li>单独导出纹理<br>虽然纹理可以和模型一起以某些文件格式导出，如 glTF 2.0，也可以单独导出它们。<br>Godot的材质使用 PBR（基于物理的渲染），所以如果一个纹理程序可以导出 PBR 纹理，它们就可以在 Godot 中工作。<br>这包括 Substance 套件，ArmorPaint （开源） ，Material Maker （开源） 。</li>
<li>导出注意事项<br>由于 GPU 只能渲染三角形，所以包含四边形或 N 边形的网格必须在渲染前进行三角剖分。<br>Godot 可以在导入时对网格进行三角剖分，但结果可能无法预测或不正确，特别是对于 N 边形。<br>无论目标应用是什么，在导出场景之前进行三角剖分会得到更一致的结果，因此应该尽可能地进行三角剖分。<br>为了避免在 Godot 中导入后出现三角剖分不正确的问题，建议让 3D 建模软件自行对对象进行三角剖分。<br>在Blender中，可以通过向对象添加三角剖分修改器，并确保在导出对话框中勾选 应用修改器 来实现。<br>另外，根据导出工具的不同，你可以在导出对话框中找到并启用 Triangulate Faces 选项。<br>为了避免在编辑器中出现 3D 选择的问题，建议在导出场景前在 3D 建模软件中应用对象变换。</li>
<li>光照注意事项<br>虽然可以使用 glTF、 .blend 或 Collada 格式从 3D 场景中导入灯光，但通常建议在导入场景后在 Godot 编辑器中设计场景的照明。<br>这样可以让你更准确地感受到最终结果，因为不同的引擎会以不同的方式渲染灯光。这也避免了由于导入过程中灯光显示过强或过弱的问题。</li>
</ul>
<p>使用名称后缀自定义节点类型<br>下面描述的所有后缀都可以与 -，$ 和 _ 搭配使用，并且是大小写不敏感。</p>
<ul>
<li>选择退出<br>不希望 Godot 执行下面描述的任何操作<br>可以将 nodes&#x2F;use_node_type_suffixes import 选项设置为 false。<br>这将禁用所有节点类型后缀，从而使节点与指示的原始文件保持相同的类型。<br>但是，仍然会尊重 -noimp 后缀，以及 -vcol 或 -loop 等非节点后缀。<br>或者，您可以通过将 nodes&#x2F;use_name_suffixes import 选项设置为 false 来完全选择退出所有名称后缀。<br>这将完全阻止常规场景导入代码查看名称后缀。但是，特定于格式的导入代码可能仍会查看名称后缀，例如 glTF 导入器检查 -loop 后缀。<br>禁用这些选项会使编辑器导入的文件与原始文件更相似，并且更类似于在运行时导入文件。<br>对于在运行时工作、提供更可预测的结果且仅具有显式定义行为的导入工作流，请考虑将这些选项设置为 false 并改用 GLTFDocumentExtension。</li>
<li>删除节点和动画 （-noimp）<br>具有 -noimp 后缀的节点和动画将在导入时被删除，无论其类型如何。它们不会出现在导入的场景中。<br>这相当于在高级导入设置对话框中为节点启用 跳过导入 功能。</li>
<li>创建碰撞体（-col、-convcol、-colonly、-convcolonly）<br>-col 选项只作用于网格物体. 如果该选项被检测到, 将会添加一个静态碰撞体的子节点, 用的是跟网格一样的几何体.<br>这会创建一个三角形网格碰撞体, 这个选项对碰撞检测来说很慢但是精确.<br>这个选项通常是关卡几何体需要的(但是也看看下面的 -colonly ).<br>选项 -convcol 将创建一个 ConvexPolygonShape3D 而不是 ConcavePolygonShape3D。<br>与可以凹陷的三角形网格不同，凸形只能准确表示没有任何凹角的形状（金字塔是凸的，但空心盒子是凹的）。<br>因此，凸碰撞形状通常不适合关卡几何体。当表示足够简单的网格时，凸碰撞形状可以比三角形碰撞形状产生更好的性能。<br>该选项非常适合需要最精确碰撞检测的简单或动态对象。<br>然而，在这两个例子中，视觉几何体处理过于复杂或对于碰撞而言不够光滑。<br>物理引擎会出现小故障从而不必要地降低了引擎的速度。<br>为了解决这个问题，存在 -colony 修饰符。<br>该修饰符将在导入时删除网格，并创建一个 StaticBody3D 静态碰撞体。<br>这有助于将可视网格和实际碰撞体分开。<br>-convcolonly 选项的工作方式类似，但会创建一个 ConvexPolygonShape3D，而不是使用凸分解。<br>对于 Collada 文件，选项 -colonly 也可以与 Blender 的空对象一起使用。<br>导入时，它将创建一个 StaticBody3D，并将碰撞节点作为子节点。<br>碰撞节点将具有许多预定义的形状之一，具体取决于 Blender 的空对象绘制类型：</li>
<li>在 Blender 中为 Empty 选择创建时的绘制类型<ul>
<li>单箭头将创建 SeparationRayShape3D。</li>
<li>方块将创建 BoxShape3D。</li>
<li>图像将创建 WorldBoundaryShape3D。</li>
<li>球体（和其他未列出的类型）将创建 SphereShape3D。<br>可能的话，请试着使用少量图元碰撞形状，而不是三角形网格或凸型体。图元形状的性能和可靠性通常更好。<blockquote>
<p>为了在 Blender 编辑器上获得更好的可见性，可以在碰撞空物体上设置“透视”选项，并通过更改 编辑 &gt; 偏好设置 &gt; 主题 &gt; 3D 视图 &gt; 空物体 选项为其设置不同的颜色。</p>
</blockquote>
</li>
</ul>
</li>
<li>创建遮挡器（-occ、-occonly）<br>  如果导入带有 -occ 后缀的网格，则会根据网格的几何形状创建一个 Occluder3D 节点，它不会替换网格。带有 -occonly 后缀的网格节点在导入时将转换为 Occluder3D。</li>
<li>创建导航（-navmesh）<br>  具有 -navmesh 后缀的网格节点, 将被转换为导航网格. 原始网格节点将在导入时被删除.</li>
<li>创建 VehicleBody（-vehicle）<br>  具有 -vehicle 后缀的网格节点， 将作为一个 VehicleBody3D 节点的子节点被导入。</li>
<li>创建 VehicleWheel（-wheel）<br>  具有 -wheel 后缀的网格节点，将作为一个 VehicleWheel3D 节点的子节点被导入。</li>
<li>刚体（-rigid）<br>  具有 -rigid 后缀的网格节点，将作为一个 RigidBody3D 节点的子节点被导入。</li>
<li>动画循环（-loop、-cycle）<br>  源 3D 文件中以标记 loop 或 cycle 开始或结束的动画剪辑，将作为设置了循环标志的 Godot Animation 导入。 这与上述其他后缀不同，不需要连字符。<br>  在 Blender 中，这需要使用 NLA 编辑器，并用 loop 或 cycle 前缀或后缀命名该动作。</li>
<li>材质 alpha （-alpha）<br>  带有 -alpha 后缀的材质将使用 TRANSPARENCY_ALPHA 透明模式。</li>
<li>材质顶点颜色 （-vcol）<br>  带有 -vcol 后缀的材料将与 FLAG_ALBEDO_FROM_VERTEX_COLOR 和 FLAG_SRGB_VERTEX_COLOR 标志设置。</li>
</ul>
<p>导入配置<br>Godot提供了多种自定义导入数据的方法，比如导入停靠面板、高级导入设置对话框和继承场景。<br>这可以用来对导入的场景进行进一步的更改，比如调整网格、添加物理信息和添加新节点。<br>你还可以编写一个脚本，在导入过程结束时运行代码，以执行任意的自定义操作。<br>请尽可能在导入前修改初始数据，而不是导入后再配置场景。这有助于最大程度降低场景在 3D 建模软件中与实际导入场景之间的差异。<br>可参考 导出模型的注意事项 及 使用名称后缀自定义节点类型 来获取更多信息。</p>
<p>导入工作流程<br>由于 Godot 只能保存自己的场景格式（.tscn&#x2F;.scn），Godot 无法保存原始 3D 场景文件（使用不同的格式）。<br>为了允许自定义场景及其材质，Godot 的场景导入器允许不同的工作流程，视数据的导入方式而定。<br>这个导入过程可以通过3个不同的界面进行自定义，具体取决于你的需求：</p>
<ul>
<li>在“文件系统”面板中单击一次 3D 场景后，可以在导入面板进行操作。</li>
<li>高级导入设置对话框，可以通过双击文件系统停靠栏中的 3D 场景或单击导入停靠栏中的高级 … 按钮来访问该对话框。<br>  这允许您在 Godot 中自定义每个对象的选项，并预览模型和动画。请参阅高级导入设置 页面以获取更多信息。</li>
<li>导入提示是添加到 3D 建模软件中的对象名称的特殊后缀，它可以允许你在 3D 建模软件中自定义每个对象的选项。<br>对于基本自定义，使用导入面板的配置就足够了。<br>但是对于更复杂的操作（例如基于每种材质定义材质覆盖），你需要使用“高级导入设置”对话框或导入提示，亦或者同时使用两者。</li>
</ul>
<p>使用导入面板<br>在文件系统面板选中一个 3D 场景之后，可以在导入面板中调整以下选项：</p>
<ul>
<li>根类型： 被用作为根节点的节点类型。<br>  建议使用一个继承自 Node3D 的节点。否则你可能会无法直接在 3D 编辑器里面设置节点的位置。</li>
<li>根名称： （Root Name）导入场景中根节点的名称。<br>  在编辑器中实例化场景（或从文件系统面板拖放）时，这通常不太明显，因为在这种情况下，根节点会被重命名以匹配文件名。</li>
<li>应用根缩放： （Apply Root Scale）如果启用， 根缩放 将直接 应用 于网格和动画，同时保持根节点的缩放为默认值 (1, 1, 1) 。<br>  这意味着如果你稍后在导入的场景中添加一个子节点，它不会被缩放。如果禁用， 根缩放 将乘以根节点的缩放。</li>
</ul>
<p>网格</p>
<ul>
<li>确保切线： （Ensure Tangents）如果勾选，在导入的网格没有提供切线数据时，将会使用 Mikktspace 生成顶点的切线。<br>  但更推荐使用 3D 建模软件在导出的时候生成切线图像，而不是依赖这个选项。<br>  正确显示法线和高度贴图以及需要切线的任何材质&#x2F;着色器功能都需要切线。<br>  如果你不使用需要切线的材质特性，关闭这个选项可以减少导出文件的大小，并且能更快地导入没有存储切线的 3D 文件。</li>
<li>生成 LOD： 如果勾选，则会生成网格的低细节的变体，这些变体将显示在远处以提高渲染性能。<br>  并非所有网格体都会受益于 LOD，特别是如果它们从未从远处渲染。<br>  禁用此功能可以减少输出文件大小并加快导入速度。请参阅 网格的细节级别（LOD） 了解更多信息。</li>
<li>创建阴影网格： 如果勾选，则可以在导入时生成阴影网格。<br>  这可以通过在可能的情况下将顶点接在一起来优化阴影渲染，而不会降低质量。<br>  这反过来又减少了渲染阴影所需的内存带宽。<br>  阴影网格生成当前不支持使用比源网格更低的细节级别（但阴影渲染将在相关时使用 LOD）。</li>
<li>Light Baking：光照烘焙，在 3D 场景中配置网格的全局光照模式。<br>  如果设置为 Static Lightmaps（静态光照贴图），则将网格的 GI 模式设置为 Static（静态）并在导入时生成 UV2，用于烘焙光照贴图。</li>
<li>光照贴图纹素大小： （Lightmap Texel Size）仅当 光照烘焙 设置为 Static Lightmaps 时可见。<br>  用来控制烘焙光照贴图上每个纹素的大小。<br>  较小的值会产生更精确的光照贴图，但代价是更大的光照贴图大小和更长的烘焙时间。</li>
</ul>
<p>蒙皮</p>
<ul>
<li>使用具名蒙皮： 如果勾选，则为动画使用命名的 Skins。<br>  MeshInstance3D 节点包含 3 个相关属性：指向 Skeleton3D 节点的骨架 NodePath（通常为 .. ）、一个网格和一个蒙皮：<ul>
<li>Skeleton3D 节点包含一个骨骼列表，其中包括骨骼的名称、它们的姿势和休息状态、一个名称和一个父骨骼。</li>
<li>网格是显示网格所需的所有原始顶点数据。就网格而言，它知道如何对顶点进行加权绘制，并使用一些通常从 3D 建模软件导入的内部编号。</li>
<li>蒙皮包含将此网格物体绑定到此 Skeleton3D 上所需的信息。<br>  对于 3D 建模软件选择的每一个内部骨骼 ID，它都包含两个内容。<br>  首先，一个矩阵，称为绑定姿势矩阵（Bind Pose Matrix）、逆绑定矩阵（ Inverse Bind Matrix），或者简称 IBM。<br>  其次，蒙皮包含每个骨骼的名称（如果启用 使用具名蒙皮 选项），或者骨骼在 Skeleton3D 列表中的索引（如果禁用了 使用具名蒙皮 选项）。</li>
</ul>
</li>
</ul>
<p>这些信息加在一起，足以告诉 Godot 如何使用骨骼 3D 节点中的骨骼姿势来渲染每个 MeshInstance3D 中的网格。请注意，每个 MeshInstance3D 都可以共享绑定，这在从 Blender 导出的模型中很常见；或者每个 MeshInstance3D 都可以使用单独的蒙皮对象，这在从其他工具（如 Maya）导出的模型中很常见。</p>
<p>动画</p>
<ul>
<li>导入： 如果选中，则从 3D 场景导入动画。</li>
<li>FPS： 用线性插值将动画曲线烘焙为一系列点时使用的每秒帧数。<br>  建议将此值设置为与 3D 建模软件中的基准值相匹配。<br>  数值越大，动画越精确，动作变化越快，但文件大小和内存使用量也越大。<br>  由于采用了插值技术，超过 30 FPS 通常不会有太大的好处（因为动画在更高的渲染帧频下仍会显得流畅）。</li>
<li>修剪： 如果没有关键帧变化，则修剪动画的开头和结尾。这可以减少某些 3D 场景的输出文件大小和内存使用量，具体取决于其动画轨道的内容。</li>
<li>移除不可修改的轨道： 移除只包含默认值的动画轨道。这可以减少某些 3D 场景的输出文件大小和内存使用量，具体取决于其动画轨道的内容。</li>
</ul>
<p>导入脚本</p>
<ul>
<li>Path：路径，导入脚本的路径，该脚本可在导入过程完成后运行代码，以进行自定义处理。<br>  更多信息请参阅 使用导入脚本实现自动化。</li>
</ul>
<p>glTF</p>
<ul>
<li>嵌入图像处理： 控制如何处理嵌入 glTF 场景中的纹理。<br>  Discard All Textures （忽略所有纹理）不会导入任何纹理，如果你想在 Godot 中手动设置材质，该选项将非常有用。<br>  Extract Textures （提取纹理）将纹理提取到外部图像中，从而减小文件大小，并对导入选项进行更多控制。<br>  Embed as Basis Universal （嵌入为基础通用）和 Embed as Uncompressed （嵌入为未压缩）分别将纹理嵌入已导入的场景中，并对 VRAM 进行压缩和不压缩。</li>
</ul>
<p>FBX</p>
<ul>
<li>进口商使用哪种导入方法。UBFX 将 FBX 文件作为 FBX 文件进行处理。<br>  FBX2glTF 在导入时将 FBX 文件转换为 glTF，需要额外的设置。<br>  不建议使用 FBX2glTF，除非您有特定的 rason 在 ufbx 上使用它或处理不同的文件格式。</li>
<li>启用或禁用几何辅助节点</li>
<li>嵌入图像处理： 控制如何处理嵌入 glTF 场景中的纹理。<br>  Discard All Textures （忽略所有纹理）不会导入任何纹理，如果你想在 Godot 中手动设置材质，该选项将非常有用。<br>  Extract Textures （提取纹理）将纹理提取到外部图像中，从而减小文件大小，并对导入选项进行更多控制。<br>  Embed as Basis Universal （嵌入为基础通用）和 Embed as Uncompressed （嵌入为未压缩）分别将纹理嵌入已导入的场景中，并对 VRAM 进行压缩和不压缩。</li>
</ul>
<p>Blender-specific 选项<br>仅对 .blend 文件可见。</p>
<p>Nodes  节点</p>
<ul>
<li>Visible：All 导入所有内容，甚至是不可见的对象。<br>  仅可见 仅导入可见对象。Renderable 仅导入在 Blender 中标记为可渲染的对象，无论它们是否实际可见。<br>  在 Blender 中，渲染性可以通过单击 Outliner 中每个对象旁边的相机图标来切换，而可见性则通过眼睛图标来切换。</li>
<li>仅限活动收集： 如果选中，则仅导入 Blender 中活动集合中的节点。</li>
<li>准时灯光： 如果选中，则从 Blender 导入灯光（定向、全向和聚光灯）。“准时”不要与“位置”混淆，这就是为什么还包括定向灯的原因。</li>
<li>相机： 如果选中，则从 Blender 导入摄像机。</li>
<li>自定义属性： 如果选中，则从 Blender 导入自定义属性作为 glTF extras。<br>  然后，可以从编辑器插件中使用此数据，该插件使用 GLTF 文档。<br>  register_gltf_document_extension（），它可以在导入时设置节点元数据（以及其他用例）。</li>
<li>修饰 符： 如果设置为 “无修改器”，则在导入时将忽略对象修改器。如果设置为 “所有修改器”，则在导入时将修改器应用于对象。</li>
</ul>
<p>网格</p>
<ul>
<li>颜色： 如果选中，则从 Blender 导入顶点颜色。</li>
<li>乌布苏： 如果选中，则从 Blender 导入顶点 UV1 和 UV2。</li>
<li>法线： 如果选中，则从 Blender 导入顶点法线。</li>
<li>导出几何体节点实例： 如果选中，则导入 几何体节点 实例。</li>
<li>切线： 如果选中，则从 Blender 导入顶点切线。</li>
<li>Skins：None 跳过从 Blender 导入骨架皮肤数据。<br>  4 影响（兼容） 导入皮肤数据以与所有渲染器兼容，但代价是精度较低 对于某些钻机。<br>  All Influences 导入具有所有影响的皮肤数据（在 Godot 中最多 8 个），这更精确，但可能与所有渲染器不兼容。</li>
<li>仅导出骨骼变形网格体（Export Bones Deforming Mesh）： 如果选中，则仅从 Blender 导入使网格变形的骨骼。</li>
</ul>
<p>Materials材料</p>
<ul>
<li>已启用解压： 如果选中，则将原始图像解压缩到 Godot 文件系统并使用它们。<br>  这允许更改图像导入设置，例如 VRAM 压缩。如果未选中，则允许 Blender 转换原始图像，例如将粗糙度和金属重新打包为一个粗糙度 + 金属纹理。<br>  在大多数情况下，应选中此选项，但如果 .blend 文件的图像格式不正确，则必须禁用此选项才能获得正确的行为。</li>
<li>出口材料： 如果设置为 “占位符”，则不导入材质，但保留曲面槽，以便可以将单独的材质分配给不同的曲面。<br>  如果设置为 导出（Export）， 则按原样导入材质（请注意，程序化 Blender 材质可能无法正常工作）。<br>  如果设置为 “命名占位符”，则导入材质，但不导入打包到 .blend 文件中的图像。纹理必须在导入的材质中手动重新分配。</li>
</ul>
<p>动画</p>
<ul>
<li>限制播放： 如果选中，则将动画导入限制在 Blender 中定义的播放范围（Blender 中动画时间轴右侧的 开始 和 结束 选项）。<br>  这可以避免包含未使用的动画数据，使导入的场景更小、加载速度更快。<br>  但是，如果在 Blender 中未正确设置播放范围，这也可能导致动画数据丢失。</li>
<li>始终采样： 如果选中，则在导入时强制对动画进行采样，以确保 Blender 和 glTF 执行动画插值的方式之间的一致性，但代价是文件大小较大。<br>  如果未选中，由于两者之间的插值语义不同，您在 Blender 中看到的内容和在 Godot 中导入的场景之间的动画插值方式可能会有所不同。</li>
<li>团体轨道： 如果选中，则将动画（活动动画和 NLA 轨道上的动画）导入为单独的轨道。<br>  如果未选中，则所有当前分配的作都将变为一个 glTF 动画。</li>
</ul>
<p>使用导入脚本实现自动化<br>可以提供一个特殊脚本来处理导入后的整个场景。<br>这非常适合后期处理、更换材质和用几何图形做有趣的事情等等。<br>通过右键单击文件系统面板并选择 新建脚本… ，创建一个不附加到任何节点的脚本。<br>在脚本编辑器中，编写以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@tool # 必须添加此注解，才能在编辑器中运行（包括导入时）</span><br><span class="line">extends EditorScenePostImport</span><br><span class="line"></span><br><span class="line"># 该示例用于修改导入场景中所有节点的名称</span><br><span class="line"># 在场景导入完成后立即调用，并接收场景根节点作为参数</span><br><span class="line">func _post_import(scene):</span><br><span class="line">    # 将所有节点名称改为 &quot;modified_[原节点名]&quot;</span><br><span class="line">    iterate(scene)</span><br><span class="line">    return scene # 记得返回修改后的场景，否则更改不会生效</span><br><span class="line"></span><br><span class="line"># 递归遍历函数，对每个节点进行处理</span><br><span class="line"># （仅用于演示；EditorScenePostImport 实际上只需要实现 `_post_import(scene)` 函数即可）</span><br><span class="line">func iterate(node):</span><br><span class="line">    if node != null:</span><br><span class="line">        # 打印日志：显示节点名称的变更</span><br><span class="line">        print_rich(&quot;Post-import: [b]%s[/b] -&gt; [b]%s[/b]&quot; % [node.name, &quot;modified_&quot; + node.name])</span><br><span class="line">        # 修改当前节点名称</span><br><span class="line">        node.name = &quot;modified_&quot; + node.name</span><br><span class="line">        # 递归处理所有子节点</span><br><span class="line">        for child in node.get_children():</span><br><span class="line">            iterate(child)</span><br></pre></td></tr></table></figure>


<p>使用动画库<br>从 Godot 4.0 开始，可以选择从 glTF 文件导入 仅 动画，而不导入其他信息。<br>这在某些资产管线中用于将动画与模型分开分发。比如，给多个角色使用一套动画，而每个角色不必有重复的动画数据。<br>那么，请在文件系统栏目中选择 glTF 文件，然后在导入栏中更改导入模式为动画库：<br>glTF 文件将作为 AnimationLibrary 导入，而不是 PackedScene 。然后，可以使用 AnimationPlayer 节点引用此动画库。<br>更改导入模式为动画库后，可见的导入选项与使用场景导入模式时相同。有关更多信息，请参阅 使用导入面板 。</p>
<p>过滤脚本<br>可以使用特殊语法指定过滤器脚本, 以决定应保留哪些动画的哪些轨道.<br>过滤脚本对每个导入的动画执行。语法由两种类型的语句组成，第一种用于选择要过滤的动画，第二种用于过滤匹配动画中的单个轨道。所有名称模式都使用不区分大小写的表达式匹配，并支持 ? 和 * 通配符【底层使用 String.matchn() 】<br>脚本必须以动画筛选器语句开头（如以 @ 开头的行表示）。<br>例如，如果我们想将过滤器应用于名称以 “_Loop” 结尾的所有导入动画：<code>@+*_Loop</code><br>同样，可以将其他模式添加到同一行，用逗号分隔。<br>下面是一个修改后的示例，以额外包括名称以 “Arm_Left” 开头的所有动画，但也排除了名称以 “Attack” 结尾的所有动画：<code>@+*_Loop, +Arm_Left*, -*Attack</code><br>在动画选择过滤器语句之后, 我们添加轨道过滤模式来指示保留或丢弃哪些动画轨道. 如果未指定轨道过滤器模式, 则匹配动画中的所有轨道都会被丢弃！<br>需要注意的是, 轨道过滤器表达式是按顺序作用于动画中的每条轨道, 这意味着, 一行表达式可能包含某个轨道, 但后续的规则仍然可以忽略它. 同样, 一个被之前规则排除的轨道, 可能被过滤器脚本后续的规则重新包含进来.<br>例如：在名称以 “_Loop” 结尾的动画中包括所有轨道，但丢弃任何影响以 “Control” 结尾的“ 骨架” 的轨道，除非它们的名称中带有 “Arm”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@+*_Loop</span><br><span class="line">+*</span><br><span class="line">-Skeleton:*Control</span><br><span class="line">+*Arm*</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，像 “Skeleton:Leg_Control” 这样的轨道会被丢弃，而像 “Skeleton:Head” 或 “Skeleton:Arm_Left_Control” 这样的轨道会被保留。<br>任何不是以 + 或 - 开头的轨道过滤器行将会被忽略.</p>
<p>场景继承<br>在许多情况下，可能需要对导入的场景进行手动修改。<br>默认情况下，这是不可能的，因为如果源 3D 资产发生变化，Godot 将重新导入整个场景。<br>然而，可以使用场景继承来创建本地修改。如果你尝试使用场景 &gt; 打开场景… 或场景 &gt; 快速打开场景… 来打开已导入的场景，以下对话框将会出现：<br>在继承场景中，修改的唯一限制是：</p>
<ul>
<li>无法删除基础场景中的节点，但可以在任何地方添加其他节点。</li>
<li>子资源无法被编辑（如上所述它们将保存在外部）。<br>除此之外，一切都是允许的。</li>
</ul>
<p>高级导入设置<br>常规导入面板为导入的 3D 模型提供了许多基本选项，而高级导入设置则提供每个对象的选项、模型预览和动画预览。<br>要打开它，请选择导入停靠栏底部的<strong>高级按钮</strong>。<br>这适用于作为场景导入的 3D 模型以及动画库。</p>
<p>使用高级导入设置对话框<br>你看到的第一个选项卡是场景选项卡。<br>右侧面板中的选项与“导入”面板相同，但是你还可以看到 3D 预览。<br>按住鼠标左键并拖动鼠标就能够旋转 3D 预览。缩放可以通过鼠标滚轮调整。</p>
<p>配置节点导入选项<br>在场景选项卡中，可以在左侧的树状视图中单独选中构成场景的节点：<br>这样就会出现针对节点的导入选项：</p>
<ul>
<li>跳过导入：勾选后，该节点不会出现在最终导入的场景中。启用这个选项会禁用其他所有选项。</li>
<li>生成 &gt; 物理：勾选后，会生成一个 PhysicsBody3D 父节点，碰撞形状会作为该 MeshInstance3D 节点的同级节点。</li>
<li>生成 &gt; 导航网格：勾选后，会生成一个 NavigationRegion3D 子节点用于进行导航。<br>  Mesh + NavMesh 会保持原有网格可见，而 NavMesh Only 则只会导入导航网格（不带可视化表示）。<br>  NavMesh Only 应该在手动制作了用于导航的简化网格时使用。</li>
<li>生成 &gt; 遮挡器：勾选后，会生成一个 OccluderInstance3D 同级节点用于进行遮挡剔除，会使用网格的几何体作为遮挡器形状的基础。<br>  Mesh + Occluder 会保持原有网格可见，而 Occluder Only 则只会导入遮挡器（不带可视化表示）。<br>  Occluder Only 应该在手动制作了用于遮挡剔除的简化网格时使用。</li>
</ul>
<p>仅当启用上述某些选项时，这些选项才可见：</p>
<ul>
<li>物理 &gt; 实体类型：仅在启用 生成 &gt; 物理 后可见。<br>  控制创建的 PhysicsBody3D：Static 即创建 StaticBody3D，Dynamic 创建 RigidBody3D，Area 创建 Area3D。</li>
<li>物理 &gt; 形状类型： 仅在 生成 &gt; 物理 启用时可见。<br>  Trimesh （三角网格）可实现精确的三角形碰撞，但是它只能与 Static 主体类别一起使用。<br>  其他类型精度较低，可能需要手动配置，但可以用于任何实体类型。对于静态几何体，请使用 Trimesh 。<br>  对于动态几何体， 尽可能使用图元，以获得更好的性能， 如果形状较大且复杂，则可以使用其中一种凸分解模式。</li>
<li>拆分 &gt; 高级： 仅当 物理 &gt; 形状类型 为 Decompose Convex （凸面分解）时可见。<br>  如果选中，则可以调整高级拆分选项。如果禁用，则只能调整预设的 精度 （通常就足够了）。</li>
<li>拆分 &gt; 精度： 仅当 物理 &gt; 形状类型 为 Decompose Convex 时可见。控制用于凸面分解的精度。<br>  数值越高，碰撞的细节越多，但生成速度会变慢，物理模拟时的 CPU 占用率也会增加，为提高性能，建议在使用时尽可能降低该值。</li>
<li>遮挡器 &gt; 化简距离： 仅当 生成 &gt; 遮挡器 设置为 Mesh + Occluder 或 Occluder Only 时可见。<br>  数值越大，遮挡网格的顶点越少（从而降低 CPU 利用率），但代价是会出现更多遮挡剔除问题（如误报或漏报）。<br>  如果你发现当摄像机靠近某个网格时，物体在不该消失的时候消失了，请尝试减小该值。</li>
</ul>
<p>配置网格体和材质导入选项<br>在 “高级导入设置 “对话框中，有两种方法可以选择单个网格或材质：<br>切换到对话框左上角的 网格 或 材质 选项卡。<br>保留在 场景 选项卡中，但展开左侧树状视图中的选项。选择网格或材质后，会显示与 网格 和 材质 选项卡相同的信息，但显示的是树状视图而不是列表。<br>如果你选择了一个网格，右侧面板上将会出现不同的选项：</p>
<p>最常见的用例如下:</p>
<ul>
<li>保存到文件： 将 Mesh 资源 保存到一个外部文件中（这不是一个场景文件）。<br>  通常，你不需要使用这个功能来将网格放置在一个3D场景中——相反地，你应该直接实例化 3D 场景。<br>  然而，直接访问 Mesh 资源对于特定节点很有用，例如 MeshInstance3D、 MultiMeshInstance3D 、 GPUParticles3D 或 CPUParticles3D。<br>  启用 保存到文件 后，你还需要使用出现的选项来指定一个输出文件路径。<br>  建议使用 .res 输出文件扩展名，因为它具有较小的文件大小和更快的加载速度，而 .tres 用于写入大量数据时效率不高。</li>
<li>生成 &gt; 阴影网格： 针对 使用导入面板 中描述的场景范围导入选项 网格 &gt; 创建阴影网格 的每个网格进行覆盖。<br>  Default （默认）将使用场景范围的导入选项，而 Enable （启用）或 Disable （禁用）可以在特定网格上强制启用或禁用此行为。</li>
<li>生成 &gt; 光照贴图 UV： 针对 使用导入面板 中描述的场景范围导入选项 网格&gt; 光照烘焙 的每个网格覆盖。<br>  Default （默认）将使用场景范围的导入选项，而 Enable （启用）或 Disable （禁用）可以在特定网格上强制启用或禁用此行为。<br>  在具有 Static 光烘焙模式的场景中将此设置为 Enable 相当于配置该网格使用 Static Lightmaps （静态光照贴图）。<br>  在具有 Static Lightmaps 光烘焙模式的场景中将此设置为 Disable 相当于配置该网格使用 Disable 。</li>
<li>生成 &gt; LOD： 针对 使用导入面板 中描述的场景范围导入选项 网格&gt; 生成 LOD 的每个网格进行覆盖。<br>  Default 将使用场景范围的导入选项，而 Enable 或 Disable 可以在特定网格上强制启用或禁用此行为。</li>
<li>LOD &gt; 法线合并角度： 在生成网格 LOD 中保留几何边缘所需要的两个顶点之间的最小角度差异。<br>  如果在 LOD 生成中遇到视觉问题，减小此值可能会有所帮助（但会以更低效的 LOD 生成为代价）。</li>
</ul>
<p>如果你选择一种材质，在右侧面板中只会出现一个选项：<br>当选中 使用外部 并指定输出路径时，可以使用外部材质而不是原始 3D 场景文件中所包含的材质。请参阅下面的部分。</p>
<p>将材质提取到单独文件中<br>虽然 Godot 可以导入在 3D 建模软件中编辑过的材质，但默认配置可能不适合你的需求。例如：</p>
<ul>
<li>你想要配置你所使用的 3D 应用程序不支持的材质特性。</li>
<li>你想要使用不同的纹理过滤模式，因为从 Godot 4.0 开始此选项是在材质中配置的（而不是在图像中）。</li>
<li>你想要将其中一种材质替换为完全不同的材质，例如一个自定义着色器。<br>为了能够在 Godot 编辑器中修改 3D 场景的材质，需要使用 外部 材质资源。<br>在“高级导入设置”对话框的左上角，选择 动作 &gt; 提取材质 ：<br>启用 使用外部 时，请注意，“高级导入设置”对话框将继续显示网格的原始材质（在 3D 建模软件中设计的材质）。<br>这意味着你对材质进行的自定义在此对话框中不可见。<br>为了预览修改后的材质，需要使用编辑器将导入的 3D 场景放置在另一个场景中。</li>
</ul>
<p>重新导入源 3D 场景时，Godot 不会覆盖对提取材质所做的更改。<br>然而，如果源 3D 文件中的材质名称发生更改，则原始材质和提取的材质之间的链接将会丢失。<br>为此，你需要使用“高级导入设置”对话框，将重命名后的材质与现有提取的材质相关联。</p>
<p>上述操作可以在对话框的 材质 选项卡中完成。<br>操作方法是，首先选择材质，启用 保存为文件 ，然后使用启用 保存为文件 后出现的 路径 选项指定保存路径。</p>
<p>动画选项<br>生成的 AnimationPlayer 有几个额外的选项可用节点，以及它们在场景选项卡 。</p>
<p>优化<br>导入动画时, 会运行优化程序, 从而大大减少动画的大小.<br>一般情况下, 除非你怀疑动画可能因启用而被破坏, 否则应始终启用此功能.</p>
<p>保存到文件<br>默认情况下, 动画保存为内置.<br>可以将它们保存到一个文件中.<br>这允许向动画添加自定义轨道并在重新导入后保留它们.</p>
<p>切片<br>可以将单个时间线上的切片指定为多个动画。<br>这样做的前提是模型上仅存在一个名叫 default 的动画。<br>要创建切片，请先将切片数量改为大于零的值。<br>之后就可以对切片进行命名、指定起讫帧、选择动画是否循环。</p>
<h3 id="3D-骨架重定向"><a href="#3D-骨架重定向" class="headerlink" title="3D 骨架重定向"></a>3D 骨架重定向</h3><p>在多个骨架之间共享动画<br>Godot 具有 3D 位置、旋转、缩放轨道（本文称这些轨道为“变换”轨道），其节点路径指向骨骼，用于骨架骨骼动画。<br>这意味着仅仅通过使用相同的骨骼名称是无法在多个骨架之间共享动画的。<br>Godot 允许骨骼与骨骼之间存在父子关系，每个骨骼都可以具有旋转、缩放、位置等属性，这意味着即使名称相同的骨骼仍然可以具有不同的变换值。<br>骨架（Skeleton）会将默认姿势所必须的变换值存储为放松姿势（Bone Rest）。如果骨骼姿势等于放松姿势，那么这个骨架就处于默认姿势。<br>骨骼模型具有不同的放松姿势，具体取决于导出的环境。例如，Blender 输出的 glTF 模型的骨骼会将“编辑骨骼方向”作为放松姿势的旋转。然而有些骨骼模型是没有任何放松姿势旋转的，比如 Maya 输出的 glTF 模型。<br>要在 Godot 中共享动画，放松姿势和骨骼名称都需要相匹配，从而在某些情况下删除不需要的轨道。在 Godot 4.0+ 中，可以使用场景导入器来实现。</p>
<p>重定向选项<br>骨骼映射<br>在高级场景导入菜单中选中 Skeleton3D 节点时，右侧将出现一个菜单，其中包含“重定向”部分。重定向部分只中有一个属性 bone_map（骨骼映射）。<br>选中骨架节点后，请先设置一个新的 BoneMap 和 SkeletonProfile。Godot 有一个用于人形模型的预设，名为 SkeletonProfileHumanoid。<br>本教程假设你使用的就是 SkeletonProfileHumanoid。</p>
<p>备注<br>如果需要不同于 SkeletonProfileHumanoid 的配置文件，你可以通过选择 Skeleton3D 并使用 3D 视口工具栏中的 Skeleton3D 菜单从编辑器中导出一个 SkeletonProfile。</p>
<p>使用 SkeletonProfileHumanoid 时，将在设置 SkeletonProfile 时执行自动映射。<br>如果自动映射的效果不佳，你也可以手动映射骨骼。</p>
<p>缺失、重复以及不正确的父子关系映射都会显示为洋红色&#x2F;红色按钮（取决于编辑器设置）。<br>这些问题不会阻止导入过程，但会警告动画可能无法正确共享。</p>
<p>备注<br>自动映射会对骨骼名称进行模式匹配。所以建议骨骼都使用常见的英文名称。</p>
<p>设置 bone_map 后，以下部分中提供了多个选项。</p>
<p>移除轨道<br>如果是要将资源导入为 AnimationLibrary，那么我们建议启用这些选项。而如果是要将资源导入为场景，那么某些情况下就应该禁用这些选项。例如导入带有动画配件的角色时，这些选项可能会导致配件没有动画。</p>
<p>排除骨骼变换<br>删除动画中除骨骼变换轨道之外的所有轨道。</p>
<p>非重要位置<br>删除动画中除了在 SkeletonProfile 中定义过的 root_bone 和 scale_base_bone 以外的位置轨道。在 SkeletonProfileHumanoid 中，这意味着要删除除 Root 和 Hips 之外的位置轨道。自 Godot 4.0+ 起，动画在变换值中包含放松姿势。如果禁用此选项，动画可能会意外地改变身体形状。</p>
<p>未映射骨骼<br>删除动画中未映射的骨骼变换轨道。</p>
<p>骨骼命名器<br>重命名骨骼<br>重命名映射的骨骼。</p>
<p>唯一节点<br>使骨架成为唯一节点，名称在 skeleton_name 中指定。<br>这会使得动画轨道路径能够统一，独立于场景层次结构。</p>
<p>放松修复器<br>SkeletonProfileHumanoid 中定义参考姿势有以下规则：</p>
<ul>
<li>人形物体呈 T 形姿势</li>
<li>人形物体在 Y 朝上的右手坐标系中面向 +Z</li>
<li>人形物体不应该有变换节点</li>
<li>将 +Y 轴从父关节指向子关节</li>
<li>+X 旋转使关节像肌肉收缩一样弯曲<br>这些规则是混合动画和反向动力学（IK）的便捷定义。如果你的模型与此定义不符，你需要用这些选项来进行修正。</li>
</ul>
<p>应用节点变换<br>如果没有正确导出资产进行共享，导入的骨骼可能会将Transform作为节点。例如，从 Blender 导出的但没有执行 “应用变换”的glTF就是这样的情况。看起来模型与定义相符，但内部Tranforms与定义不同。此选项可通过在导入时应用变换来修复此类模型。</p>
<p>备注</p>
<p>如果导入的场景包含骷髅以外的其他对象，该选项可能会产生负面影响。</p>
<p>归一化位置轨道<br>位置轨道主要用于模型的移动，但在不同高度的模型之间共享移动动画可能会由于步长的差异而导致滑倒现象。该选项会根据 scale_base_bone 高度标准化位置轨道。scale_base_bone 高度作为 motion_scale 存储在骨骼中，并且标准化的位置轨道值在播放时将乘以该值。如果禁用此选项，则位置轨道不会被标准化，骨架的 motion_scale 始终以 1.0 的形式导入。</p>
<p>对于 SkeletonProfileHumanoid，scale_base_bone 是“臀部”，因此臀部的高度用作 motion_scale。</p>
<p>覆盖轴<br>通过覆盖模型的 Bone Rest 来统一模型的 Bone Rest，以匹配 SkeletonProfile 中定义的参考姿势。</p>
<p>备注<br>该选项是 Godot 4.0+ 中共享动画的最重要的选项，但请注意， 如果外部设置的原始 Bone Rest 很重要 ，则此选项可能会产生可怕的结果。如果你想在保留原始 Bone Rest 的情况下共享动画，请考虑使用 实时重定向模块 。</p>
<p>修复剪影<br>尝试让模型的剪影与 SkeletonProfile 中定义的参考姿势相匹配，例如 T-Pose。<br>该功能无法修复差异太大的剪影，并且可能不适用于修复骨骼滚动。<br>使用 SkeletonProfileHumanoid 时，不需要为 T-Pose 模型启用此选项，但应为 A-Pose 模型启用。然而，在这种情况下，根据模型的脚跟高度，固定脚的结果有可能会很糟糕，因此，可能需要添加你并不希望在 filter 数组中固定的 SkeletonProfile 骨骼名称，如下例所示。</p>
<p>此外，对于膝盖或脚弯曲的模型，可能需要调整 scale_base_bone 高度。为此可以使用 base_height_ adjustment 选项。</p>
<h3 id="导出-3D-场景"><a href="#导出-3D-场景" class="headerlink" title="导出 3D 场景"></a>导出 3D 场景</h3><p>在 Godot 中可以将 3D 场景导出为 glTF 2.0 文件。<br>你可以将其导出为 glTF 二进制文件（.glb 文件）或者内嵌 glTF 及纹理（gltf + .bin + 纹理）。<br>这样就可以在 Godot 中创建场景，比如使用 CSG 网格进行关卡的搭建，然后导出到类似 Blender 的程序里进行整理，然后再弄回 Godot。<br>要在编辑器中导出场景，请打开场景 &gt; 导出为… &gt; glTF 2.0 场景…</p>
<p>限制</p>
<ul>
<li>不支持导出粒子，因为不同的引擎对粒子的实现是不同的。</li>
<li>无法导出 ShaderMaterial。</li>
<li>不支持导出 2D 场景。</li>
</ul>
<h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><h3 id="音频总线"><a href="#音频总线" class="headerlink" title="音频总线"></a>音频总线</h3><p>Godot的音频引擎允许创建任意数量的音频总线, 并且可以向每个总线添加任意数量的效果处理器.<br>运行游戏的设备的硬件会限制总线的数量, 以及在性能开始下降之前可以使用的效果.</p>
<p>分贝标度<br>分贝(dB)标度是一个相对标度. 它等于声功率比的常用对数的20倍(20 × log10(P&#x2F;P&#x2F;0)).<br>每增&#x2F;减6分贝, 声幅就会加倍&#x2F;减半.12dB代表系数4,18dB代表系数8,20dB代表系数10,40dB代表系数100, 以此类推.<br>由于比例是对数的, 因此无法表示真零(无音频).<br>0 dB 是数字音频系统中可能的最大振幅. 这个限制不是人为的限制, 而是声音硬件的限制. 因振幅太高而无法完全反映在0dB以下的音频, 会产生一种被称为 削波 的失真.<br>为了避免削波，你应该调整混音，使master 总线（后面会有更多的介绍）永远不超过 0 dB。<br>低于0dB限制的每6dB, 声能就会 减半 . 这意味着-6dB的音量是0dB的一半. -12dB是-6dB的一半, 依此类推.<br>使用分贝时, -60dB和-80dB范围内的声音被认为是听不见的. 也就是说你的工作范围一般在-60dB和0dB之间.</p>
<p>音频总线(audio bus)音频通道 (audio channel)<br>音频总线可以在Godot 编辑器的底部面板中找到:<br>音频从扬声器播放出来之前通过的地方.<br>它可以 修改 和 重路由 音频数据.<br>音频总线有一个 VU表(播放声音时亮起的条形), 表示通过的信号的幅度.</p>
<p>最左边的总线是 主总线 .<br>此总线将混音输出到你的扬声器, 因此, 正如之前 分贝标度 部分所述, 请确保主总线中的混音水平永远低于 0 dB.<br>其余的音频总线可以灵活地进行路由.<br>在修改声音后, 它们会将其发送到左边的另一条总线上. 非主总线的目标总线可以被单独设置.<br>而右侧总线的音频会被路由至左侧总线, 这避免了无限循环.</p>
<p>通过总线播放音频<br>要测试将音频传递到总线, 请创建AudioStreamPlayer节点, 加载AudioStream并选择要播放的目标总线:</p>
<p>自动总线禁用<br>你不需要手动禁用闲置总线,Godot在检测到总线已经静音数秒之后, 就会禁用它(以及所有效果).</p>
<p>总线重排<br>流播放器使用总线名称来识别总线, 允许在保留对总线的引用时添加, 删除和移动总线.<br>然而, 重命名总线会导致引用丢失, 流播放器将输出到主总线.<br>之所以选择这个系统, 是因为重新排列总线相比重命名总线更为常用.</p>
<p>默认总线布局<br>默认的总线布局会自动保存到 res:&#x2F;&#x2F; default_bus_layout.tres 文件中.<br>自定义总线布局可以从磁盘中保存和加载.</p>
<h3 id="音频特效"><a href="#音频特效" class="headerlink" title="音频特效"></a>音频特效</h3><p>Amplify（增幅）<br>	增幅改变信号的音量。不过使用时要小心：把电平调得太高的话，声音就会出现数字削波，从而产生令人不快的噼啪声和爆音。<br>BandLimit 和 BandPass（带限和带通）<br>	这些是谐振滤波器，可阻止截断（Cutoff）点附近的频率。带通滤波器可用于模拟通过旧电话线或扩音器的声音。调制带通频率可以模拟哇音（wah-wah）吉他踏板的声音</p>
<p>捕获<br>Capture（捕获）效果器会将其所在音频总线的音频帧复制到内部缓冲区中。可用于从麦克风捕获数据或通过网络实时传输音频。<br>Chorus（和声）<br>	正如该效果的名称所暗示的那样，和声效果将使单个音频样本听起来像整个合唱。它通过复制信号并稍微改变每个副本的时间和音高，并通过 LFO（低频振荡器）随时间变化来实现此目的。然后，复制信号与原始信号混合在一起，产生丰富、宽广、宏大的声音。尽管和声传统上用于声音，但几乎任何类型的声音都可以使用和声。<br>Compressor（压缩器）<br>	当输入信号的幅度超过某一阈值时，动态范围压缩器会自动衰减（避开）该信号的电平。所施加的衰减水平与传入音频超过阈值的程度成正比。压缩器的“比例”参数控制衰减的程度。压缩器的主要用途之一是，当一个信号具有非常大声和小声的部分时，压缩器可以用于降低其动态范围。降低信号的动态范围可以使其更方便混音。<br>	压缩器有很多用途。例如：<br>	它可用于主总线中，在受到限制器影响之前压缩整个输出，从而使限制器的效果更加微妙。<br>	它可用于语音通道，以确保它们听起来尽可能均匀。<br>	它可以通过另一个声源来侧链（Sidechain）。也就是说, 它可以利用另一个音频总线的电平进行阈值检测，来降低一个信号的电平。这种技术在电子游戏混音中非常常见。当游戏中或多人游戏的声音需要被玩家清楚听到时，可以“降低”（Duck）音乐或音效的电平。<br>	它可以通过较慢的启动（attack）来突出瞬态，让音效听起来更有力。<br>Delay（延迟）<br>	数字延迟本质上是复制一个信号，并以指定的速度重复播放它，且每次重复时音量都会衰减。延迟非常适合模拟如峡谷或大房间这样的声学空间，其中声音的反弹在每次重复之间都有很多延迟。这点与混响相反，混响的声音更自然、更模糊。将其与混响结合使用可以创建非常自然的声音环境！<br>Distortion（失真）<br>	使声音失真。Godot 提供了几种类型的失真：<br>	Overdrive 过载，听起来像吉他失真踏板或扩音器。这种声音失真，听起来像是通过低质量的扬声器或设备发出的。<br>	Tan 正弦，听起来像是另一种有趣的过载风格。<br>	Bit crushing 位破碎，会限制信号的幅度，使其听起来平坦且嘎吱作响。<br>	所有这三种类型的失真都可以为原始声音添加更高频率的声音，使其在混音中更加突出。<br>EQ（均衡器）<br>	所有其他均衡器都继承自 EQ。可以使用自定义脚本对其进行扩展，以创建一个具有自定义频段数的均衡器。<br>	EQ6、EQ10、EQ21<br>	Godot 提供了三种具有不同频段数量的均衡器，其频段数如标题所示（分别为 6、10 和 21 个频段）。主总线上的均衡器可用于截断设备扬声器无法很好地重现的低频和高频声音。例如，手机或平板电脑扬声器通常不能很好地重现低频声音，并且可能使限幅器或压缩器衰减用户根本听不到的声音。<br>	注意：插入耳机时可以禁用均衡器效果，为用户提供两全其美的效果。<br>过滤器<br>所有其他滤波器都继承自 Filter，不应直接使用。<br>HardLimiter（硬限幅器）<br>	一种与压缩器类似的限幅器，但灵活性较差，旨在防止信号振幅超过给定的 dB 阈值。在主总线的终点添加一个限幅器是一种很好的做法，因为它提供了一种防止削波的简单保护措施。<br>HighPassFilter（高通滤波器）<br>	截断特定截断频率以下的频率。高通滤波器用于减少信号的低音内容。<br>HighShelfFilter（高架滤波器）<br>	减少所有高于特定截断频率的频率。<br>Limiter（限幅器）<br>	这是旧的限制器效果，建议改用新的硬限幅器（HardLimiter）效果。<br>	以下是该效果的一个例子，如果将上限设置为 -12 dB，阈值为 0 dB，则所有通过的音频样本都会减少 12dB。这会改变音频的波形并引入失真。<br>	该效果为了兼容性而保留，但应将其视为已弃用。<br>LowPassFilter（低通滤波器）<br>	截断特定截断频率以上的频率，也可以产生谐振（增强接近截断频率的频率）。低通滤波器可用于模拟“低沉”的声音。例如，水下的声音、被墙壁阻挡的声音或远处的声音。<br>LowShelfFilter（低架滤波器）<br>	降低低于特定截断频率的所有频率。<br>NotchFilter（陷波滤波器）<br>	与带通滤波器相反，它从给定截断频率的频谱中移除一个声音频段。<br>Panner（声像）<br>	声像效果允许在左右通道之间调整信号的立体声平衡。配置该效果时建议使用耳机。<br>Phaser（移相器）<br>	这种效果是通过对同一声音的两个副本进行移相而形成的，因此，它们会以一种有趣的方式相互抵消。 移相器会产生令人愉悦的嘶嘶声，在音频频谱中来回移动，如果你要创建科幻风格效果或达斯·维德（Darth Vader）那般的声音，移相器是个好选择。<br>PitchShift（移调）<br>	这种效果可以独立于速度调整信号的音高。所有频率均可增减，对瞬态的影响极小。PitchShift 可用于创建极其高亢&#x2F;低沉的声音。需要注意的是，当推到一个狭窄窗口之外时，改变音调可能会听起来不自然。<br>Record（录制）<br>	录音效果允许用户从麦克风录制声音。<br>Reverb（混响）<br>	混响模拟不同大小的房间。它具有可调节的参数，可以调整这些参数以获得特定房间的声音。混响通常从 Area3D 输出（参见《混响总线》），或将“室内”感觉应用于所有声音。<br>SpectrumAnalyzer（频谱分析仪）<br>	这个效果并不会改变音频，相反，你可以把这个效果添加到你想要进行频谱分析的总线上。这通常被用于音频可视化。将声音可视化是一种仅吸引注意力而不增加音量的好方法。使用了这个效果的演示项目可在这里找到。<br>StereoEnhance（立体增强）<br>	该效果使用一些算法来增强信号的立体声宽度。</p>
<h3 id="音频流"><a href="#音频流" class="headerlink" title="音频流"></a>音频流</h3><p>AudioStream（音频流）<br>音频流是一种产生声音的抽象对象。<br>声音可以来自许多地方，但最常见的是从文件系统加载。<br>音频文件可以作为 AudioStream 加载并放置在 AudioStreamPlayer 中。<br>你可以在《导入音频采样》中找到支持的格式和格式差异等信息。</p>
<p>还有其他类型的 AudioStream，例如 AudioStreamRandomizer。<br>这种音频流每次都会从音频流列表中挑选不同的音频流进行播放，并应用随机音高和音量调整，这有助于为经常播放的声音添加变化。</p>
<p>AudioStreamPlayer（音频流播放器）<br>这是一种标准的非位置型的流播放器。它可以播放到任何总线。在 5.1 声音设置中，它可以将音频发送到立体声混音或前置扬声器。<br>播放类型是一种实验性设置，可能会在 Godot 的未来版本中发生变化。它的存在使得 Web 导出使用基于 Web Audio-API 的样本，而不是像大多数平台那样将所有声音流式传输到浏览器。这可以防止音频在单线程 Web 导出中出现乱码。默认情况下，只有 Web 平台会使用样本。除非有明确的理由，否则不建议更改此设置。你可以在项目设置的音频 &gt; 常规（必须打开高级设置才能看到）下更改 Web 和其他平台的默认播放类型。</p>
<p>AudioStreamPlayer2D<br>AudioStreamPlayer 的一种变体，在 2D 位置环境中发出声音。<br>当靠近屏幕左侧时，声像将向左移动。当靠近右侧时，声像将向右移动。</p>
<p>备注<br>Area2D 可用于将声音从其包含的任何 AudioStreamPlayer2D 转移到特定总线。<br>这样就可以创造具有不同混响或音质的总线，从而来处理游戏世界特定部分发生的动作。</p>
<p>AudioStreamPlayer3D<br>AudioStreamPlayer 的一种变体，在 3D 位置环境中发出声音。<br>根据播放器相对于屏幕的位置，它可以将声音定位为立体声、5.1 或 7.1，具体取决于所选的音频设置。<br>与 AudioStreamPlayer2D 类似，Area3D 可以将声音转移到特定的音频总线上。<br>与 2D 版本不同的是，3D 版本的 AudioStreamPlayer 还有一些更高级的选项：</p>
<ol>
<li><p>Reverb buses（混响总线）<br>Godot 允许进入特定 Area3D 节点的 3D 音频流，将干音频和湿音频发送到单独的总线上。<br>这有益于为不同类型的房间配置多种混响配置。<br>这可以通过在 Area3D 属性的 Reverb Bus（混响总线）部分中启用这种类型的混响来实现：<br>同时，还创建了一个特殊的总线布局，其中每个 Area3D 都从每个 Area3D 接收混响信息。<br>需要在每个混响总线中创建和配置混响效果，才能完成所需效果的设置：</p>
</li>
<li><p>Doppler（多普勒）<br>Area3D 的 Reverb Bus（混响总线）部分还有一个名为 Uniformity（统一性）的参数。<br>某些类型的房间比其他类型的房间反射的声音更多（例如仓库），因此即使声源可能很远，整个房间几乎都可以均匀地听到混响。<br>尝试使用该参数可以模拟这种效果。<br>当发射源和侦听者之间的相对速度发生变化时，这被视为发出的声音的音高增加或减少。<br>Godot 可以跟踪 AudioStreamPlayer3D 和 Camera 节点的速度变化。<br>这两个节点都具有该属性，必须手动启用：<br>根据对象的移动方式通过设置启用它：对于使用 _process 移动的对象使用 Idle，对于使用 _physics_process 移动的对象使用 Physics。跟踪将自动进行。</p>
</li>
</ol>
<h3 id="将游戏玩法与音频和音乐同步"><a href="#将游戏玩法与音频和音乐同步" class="headerlink" title="将游戏玩法与音频和音乐同步"></a>将游戏玩法与音频和音乐同步</h3><ol>
<li>使用系统时钟同步<br>调用 AudioStreamPlayer.play()，声音不会立即开始播放，而是在音频线程处理下一个块时开始。<br>这种延迟是无法避免的，但可以通过调用 AudioServer.get_time_to_next_mix() 来估算。<br>输出延迟（混音后发生的延迟），可以通过调用 AudioServer.get_output_latency() 来估算。<br>将这两者相加，就可以几乎准确地猜测 _process() 期间，声音或音乐将何时在扬声器中开始播放：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var time_begin</span><br><span class="line">var time_delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	time_begin = Time.get_ticks_usec()</span><br><span class="line">	time_delay = AudioServer.get_time_to_next_mix() + AudioServer.get_output_latency()</span><br><span class="line">	$Player.play()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _process(delta):</span><br><span class="line">	# Obtain from ticks.</span><br><span class="line">	var time = (Time.get_ticks_usec() - time_begin) / 1000000.0</span><br><span class="line">	# Compensate for latency.</span><br><span class="line">	time -= time_delay</span><br><span class="line">	# May be below 0 (did not begin yet).</span><br><span class="line">	time = max(0, time)</span><br><span class="line">	print(&quot;Time is: &quot;, time)</span><br></pre></td></tr></table></figure>
<p>但在长期运行中，由于声音硬件时钟永远不会与系统时钟完全同步，因此时间信息将慢慢漂移。<br>对于一首歌开始和结束时间各为几分钟的节奏游戏来说，这种方法是可行的（也是推荐的方法）。<br>对于播放时间可能更长的游戏来说，游戏最终会不同步，因此需要采用一种不同的方法。</p>
<ol start="2">
<li>使用声音硬件时钟同步<br>使用 AudioStreamPlayer.get_playback_position() 来获取歌曲的当前位置听起来很理想，但这样做并没有那么有用。<br>该值将分块（每次音频回调混合一个声音块时）递增，因此多次调用可能返回相同的值。<br>除此之外，由于前面提到的原因，该值也会与扬声器不同步。<br>为了补偿“分块”（chunked）输出，有个函数可能会有所帮助：<code>AudioServer.get_time_since_last_mix()</code>。<br>将这个函数的返回值与 get_playback_position() 相加可以提高精度：<br><code>var time = $Player.get_playback_position() + AudioServer.get_time_since_last_mix()</code><br>为了提高精度，减去延迟信息（音频从混合后到被听见花费的时间）：<br><code>var time = $Player.get_playback_position() + AudioServer.get_time_since_last_mix() - AudioServer.get_output_latency()</code><br>由于多线程的工作方式，结果可能会有点抖动。只需检查该值是否不小于前一帧的值（如果小于，则丢弃它）。<br>这种方法也不如之前的方法精确，但它适用于任何长度的歌曲，或将任何东西（例如音效）与音乐同步。<br>下面是使用这种方法之前相同的代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func _ready():</span><br><span class="line">	$Player.play()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _process(delta):</span><br><span class="line">	var time = $Player.get_playback_position() + AudioServer.get_time_since_last_mix()</span><br><span class="line">	# Compensate for output latency.</span><br><span class="line">	time -= AudioServer.get_output_latency()</span><br><span class="line">	print(&quot;Time is: &quot;, time)</span><br></pre></td></tr></table></figure>


<h3 id="使用麦克风录音"><a href="#使用麦克风录音" class="headerlink" title="使用麦克风录音"></a>使用麦克风录音</h3><p>在项目设置 Audio &gt; Driver &gt; Enable Input 中启用音频输入，否则你只会获取到空白的音频文件。<br>演示项目的结构<br><a target="_blank" rel="noopener" href="https://github.com/godotengine/godot-demo-projects/tree/master/audio/mic_record">https://github.com/godotengine/godot-demo-projects/tree/master/audio/mic_record</a><br>该演示由单个场景组成。<br>该场景包含两个主要部分：GUI 和音频。<br>在该演示中，创建了一个名为 Record 的总线，并附有效果 Record 来处理音频录制。<br>用一个名为 AudioStreamRecord 的 AudioStreamPlayer 进行录制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var effect</span><br><span class="line">var recording</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	# We get the index of the &quot;Record&quot; bus.</span><br><span class="line">	var idx = AudioServer.get_bus_index(&quot;Record&quot;)</span><br><span class="line">	# And use it to retrieve its first effect, which has been defined</span><br><span class="line">	# as an &quot;AudioEffectRecord&quot; resource.</span><br><span class="line">	effect = AudioServer.get_bus_effect(idx, 0)</span><br></pre></td></tr></table></figure>
<p>音频录制由 AudioEffectRecord 资源处理，该资源具有三种方法：get_recording()、is_recording_active() 和 set_recording_active()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func _on_record_button_pressed():</span><br><span class="line">	if effect.is_recording_active():</span><br><span class="line">		recording = effect.get_recording()</span><br><span class="line">		$PlayButton.disabled = false</span><br><span class="line">		$SaveButton.disabled = false</span><br><span class="line">		effect.set_recording_active(false)</span><br><span class="line">		$RecordButton.text = &quot;Record&quot;</span><br><span class="line">		$Status.text = &quot;&quot;</span><br><span class="line">	else:</span><br><span class="line">		$PlayButton.disabled = true</span><br><span class="line">		$SaveButton.disabled = true</span><br><span class="line">		effect.set_recording_active(true)</span><br><span class="line">		$RecordButton.text = &quot;Stop&quot;</span><br><span class="line">		$Status.text = &quot;Recording...&quot;</span><br></pre></td></tr></table></figure>
<p>在演示开始时，录制效果未激活。当用户按下 RecordButton 时，使用 set_recording_active(true) 启用该效果。<br>在下次按下按钮时，由于 effect.is_recording_active() 为 true，可以通过调用 effect.get_recording() 将录制的流存储到 recording 变量中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func _on_play_button_pressed():</span><br><span class="line">	print(recording)</span><br><span class="line">	print(recording.format)</span><br><span class="line">	print(recording.mix_rate)</span><br><span class="line">	print(recording.stereo)</span><br><span class="line">	var data = recording.get_data()</span><br><span class="line">	print(data.size())</span><br><span class="line">	$AudioStreamPlayer.stream = recording</span><br><span class="line">	$AudioStreamPlayer.play()</span><br></pre></td></tr></table></figure>
<p>要播放录音，请将录音赋值为 AudioStreamPlayer 的流并调用 play()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func _on_save_button_pressed():</span><br><span class="line">	var save_path = $SaveButton/Filename.text</span><br><span class="line">	recording.save_to_wav(save_path)</span><br><span class="line">	$Status.text = &quot;Saved WAV file to: %s\n(%s)&quot; % [save_path, ProjectSettings.globalize_path(save_path)]</span><br></pre></td></tr></table></figure>
<p>要保存录音，可以带文件路径调用 save_to_wav()。在该演示中，路径由用户通过一个 LineEdit 输入框定义。</p>
<h3 id="文本转语音"><a href="#文本转语音" class="headerlink" title="文本转语音"></a>文本转语音</h3><p>基本用法<br>在能够使用文本转语音进行基本操作前，需要执行一次以下步骤：</p>
<ol>
<li>在 Godot 编辑器中为项目启用 TTS</li>
<li>向系统查询可用语音列表</li>
<li>存储你想要使用的语音 ID<br>默认情况下，为了避免不必要的开销，Godot 项目级别的文本转语音设置处于禁用状态。启用方法是：</li>
<li>前往 项目 &gt; 项目设置</li>
<li>确保打开了高级设置开关</li>
<li>单击 音频 &gt; 常规</li>
<li>确保选中 文本转语音 选项</li>
<li>如果出现提示，请重新启动 Godot。<br>文本转语音会使用特定的语音。用户的系统中可能安装了多种语音。获得语音 ID 后，你就可以用它来读出文本：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># One-time steps.</span><br><span class="line"># Pick a voice. Here, we arbitrarily pick the first English voice.</span><br><span class="line">var voices = DisplayServer.tts_get_voices_for_language(&quot;en&quot;)</span><br><span class="line">var voice_id = voices[0]</span><br><span class="line"></span><br><span class="line"># Say &quot;Hello, world!&quot;.</span><br><span class="line">DisplayServer.tts_speak(&quot;Hello, world!&quot;, voice_id)</span><br><span class="line"></span><br><span class="line"># Say a longer sentence, and then interrupt it.</span><br><span class="line"># Note that this method is asynchronous: execution proceeds to the next line immediately,</span><br><span class="line"># before the voice finishes speaking.</span><br><span class="line">var long_message = &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur&quot;</span><br><span class="line">DisplayServer.tts_speak(long_message, voice_id)</span><br><span class="line"></span><br><span class="line"># Immediately stop the current text mid-sentence and say goodbye instead.</span><br><span class="line">DisplayServer.tts_stop()</span><br><span class="line">DisplayServer.tts_speak(&quot;Goodbye!&quot;, voice_id)</span><br></pre></td></tr></table></figure>

<p>功能要求<br>Godot 包含了文本转语音功能，可以在 DisplayServer 类中找到。<br>Godot 依赖于系统库来实现文本转语音功能。这些库默认安装在 Windows、macOS、Web、Android 和 iOS 上，但并非安装在所有 Linux 发行版上。<br>如果它们不存在，文本转语音功能将不起作用。具体来说，tts_get_voices（） 方法将返回一个空列表，表示没有可用的语音。</p>
<h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><h3 id="导出项目"><a href="#导出项目" class="headerlink" title="导出项目"></a>导出项目</h3><p>单击 导出 按钮，添加导出预设.<br>一般使用默认选项导出就足够了，通常无需对其进行调整。<br>但是，许多平台都需要安装其他工具（SDK）才能导出。<br>此外，Godot 需要安装导出模板来创建软件包。<br>缺少某些内容时，导出菜单将发出提示，并且在解决该问题之前，用户将无法为该平台进行导出：</p>
<p>菜单底部的按钮允许你用几种不同的方式导出项目：</p>
<ol>
<li>全部导出：将项目导出为所有定义的预设的可播放版本（Godot 可执行文件和项目数据）。所有预设都必须定义<strong>导出路径</strong>才能正常工作。</li>
<li>导出项目：将项目导出为所选预设的可播放版本（Godot 可执行文件和项目数据）。</li>
<li>导出 PCK&#x2F;ZIP：将项目资源导出为 PCK 或 ZIP 包。这不是一个可玩的版本，它仅导出项目数据，没有 Godot 可执行文件。</li>
</ol>
<p>资源选项<br>导出时，Godot 会先创建一个所有要导出的文件的列表，然后再创建包。有 3 种不同的导出模式：</p>
<ol>
<li>导出项目中的所有资源</li>
<li>导出选中的场景（包括依赖项）</li>
<li>导出选中的资源（包括依赖项）<br>导出为专用服务器将从项目中删除所有视觉对象，并将其替换为占位符。<br>这包括立方体贴图、立方体贴图阵列、材质、网格体、纹理 2D、纹理 2DArray、纹理 3D。<br>您还可以进入文件列表并指定您希望保留的特定视觉资源。</li>
</ol>
<p>资源列表下方是两个可以设置的过滤器。<br>第一种允许将非资源文件（如.txt、.json 和 .csv）与项目一起导出。<br>第二个过滤器可用于排除特定类型的每个文件，而无需手动取消选择每个文件。例如，.png 文件。</p>
<p>配置文件<br>导出配置存储在两个文件中，这两个文件都可以在项目目录中找到：</p>
<ol>
<li>export_presets.cfg ：此文件中包含绝大多数导出配置，可以安全地提交到版本控制。这里的内容通常没有什么是你需要保密的。</li>
<li>.godot&#x2F;export_credentials.cfg ：此文件包含被视为机密的导出选项，例如密码和加密密钥。通常不用版本控制或与其他人共享。<br>由于凭证文件通常不包含在版本控制系统中，因此如果将项目克隆到新计算机，某些导出选项将会丢失。<br>处理此问题的最简单方法是手动将文件从旧位置复制到新位置。</li>
</ol>
<p>从命令行导出<br>在生产中, 自动化构建很有用,Godot使用 –export 和 –export-debug 命令行参数来支持它.<br>从命令行导出仍需要导出预设来定义导出参数. 该命令的基本调用将是:<br><code>godot --export-release &quot;Windows Desktop&quot; some_name.exe</code><br>假设有一个名为“Windows Desktop”的预设，并且可以找到模板，它将导出为 some_name.exe（如果导出预设的名字中存在空格或特殊字符，就必须放在引号里）。<br>输出路径是相对于项目的路径或者绝对路径；它使用的不是命令被调用时的目录。<br>输出的文件扩展名应该与 Godot 导出过程所使用的相匹配：</p>
<ul>
<li>Windows：.exe</li>
<li>macOS：.app 或 .zip（ 或从 macOS 导出时 .dmg）</li>
<li>Linux：任意扩展名（没有也行）。64 位 x86 二进制文件通常使用 .x86_64。</li>
<li>HTML5：.zip</li>
<li>Android：.apk</li>
<li>iOS：.zip<br>你还可以将其配置为仅导出 PCK 或 ZIP 文件，能够让多个 Godot 可执行文件执行同一个导出的主包文件。<br>这样做时，仍然必须在命令行中指明导出预设的名称：<code>godot --export-pack &quot;Windows Desktop&quot; some_name.pck</code><br>将 –export 标志与 –path 标志组合起来通常很有用，这样你就不必在运行命令之前 cd 到项目文件夹中了：<br><code>godot --path /path/to/project --export-release &quot;Windows Desktop&quot; some_name.exe</code></li>
</ul>
<p>PCK 与 ZIP 打包文件格式对比</p>
<ul>
<li>PCK 格式：<br>未压缩的格式。文件尺寸较大，但读写较快。<br>尽管有 第三方工具 来提取和创建PCK文件, 但使用用户操作系统上通常存在的工具是不可读和不可写的.</li>
<li>ZIP 格式：<br>压缩格式。文件尺寸较小，但读写较慢。<br>可以使用用户操作系统中的常见工具读取或写入. 这对简化制作mod很有用.(另请参阅 导出包、补丁、Mod)</li>
</ul>
<p>由于已知的错误 ，当将 ZIP 文件用作包文件时，导出的二进制文件将不会尝试自动使用它。<br>因此，您必须创建一个启动器脚本 ，播放器可以双击或从终端运行该脚本来启动项目：<br><code>:: launch.bat (Windows)</code><br>@echo off<br>my_project.exe –main-pack my_project.zip</p>
<p><code># launch.sh (Linux)</code><br>.&#x2F;my_project.x86_64 –main-pack my_project.zip<br>保存启动脚本, 并将它与导出的二进制文件放在同一文件夹中. 在Linux上, 请确保使用 chmod +x launch.sh 命令给予启动脚本可执行权限.</p>
<h3 id="导出包、补丁、Mod"><a href="#导出包、补丁、Mod" class="headerlink" title="导出包、补丁、Mod"></a>导出包、补丁、Mod</h3><p>PCK&#x2F;ZIP 文件概述<br>Godot 通过资源包实现此功能（扩展名为 .pck 的 PCK 文件或 ZIP 文件）。<br>如果您想在运行时加载松散的文件（不是 Godot 打包在 PCK 或 ZIP 中），请考虑使用 运行时文件加载和保存 代替。<br>这对于加载不是用 Godot 制作的用户生成内容非常有用，而无需用户将他们的模组打包成特定的文件格式。<br>这种方法的缺点是它对游戏逻辑不太透明，因为它不会从与 PCK&#x2F;ZIP 文件相同的资源管理中受益。</p>
<p>生成 PCK 文件</p>
<ul>
<li>单击导出 PCK&#x2F;ZIP</li>
<li>另一种方法是从命令行导出 使用 –export-pack。<br>  输出文件必须带有 .pck 或 .zip 文件扩展名。导出过程将为 选择的平台。<br>备注<br>游戏支持mod将需要其用户创建类似的导出文件。<br>假设原始游戏需要 PCK 资源的某种结构和&#x2F;或其脚本具有特定的接口，那么有两种选择……</li>
</ul>
<ol>
<li>开发人员必须公开这些预期结构&#x2F;接口的文档，期望模组制作者安装 Godot 引擎<br> 然后，在为游戏构建 Mod 内容时，这些修改者也将遵守文档中定义的 API（这样它将起作用）。<br> 用户然后将如上所述，使用 Godot 的内置导出工具来创建 PCK 文件</li>
<li>开发者使用 Godot 来构建 GUI 工具，用这个工具向项目中添加特定的 API 内容。<br> 这个 Godot 工具要么是在启用了工具构建的引擎上执行，要么就必须能够访问到这种版本的邀请（一同分发，或者加入到原版游戏的文件之中）。<br> 这样这个工具就可以使用 OS.execute() 通过命令行使用 Godot 可执行文件来导出 PCK 文件。<br> 游戏本体不应该使用工具构建的引擎（出于安全考虑），所以最好将 mod 工具和游戏分开。</li>
</ol>
<p>在运行时打开 PCK 或 ZIP 文件<br>PCK 和 ZIP 文件的加载需要用到 ProjectSettings 单例。<br>下面的例子需要在游戏可执行文件所在目录中存在 mod.pck 文件。<br>该 PCK 或 ZIP 文件的根目录中包含一个 mod_scene.tscn 测试场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func _your_function():</span><br><span class="line">	# This could fail if, for example, mod.pck cannot be found.</span><br><span class="line">	var success = ProjectSettings.load_resource_pack(OS.get_executable_path().get_base_dir().path_join(&quot;mod.pck&quot;))</span><br><span class="line"></span><br><span class="line">	if success:</span><br><span class="line">		# Now one can use the assets as if they had them in the project from the start.</span><br><span class="line">		var imported_scene = load(&quot;res://mod_scene.tscn&quot;)</span><br></pre></td></tr></table></figure>
<p>默认情况下，如果您导入的文件路径&#x2F;名称与项目中已有的文件路径&#x2F;名称相同，则导入的文件将替换它。<br>这是创建 DLC 或模组时需要注意的事情。您可以通过使用将 mod 隔离到特定 mods 子文件夹的工具来解决此问题。<br>然而，这也是为自己的游戏创建补丁的一种方式。此类 PCK&#x2F;ZIP 文件可以修复先前加载的 PCK&#x2F;ZIP 的内容（因此，加载包的顺序很重要）。<br>为了退出这个行为, 把 false 作为第二个参数传递给 ProjectSettings.load_resource_pack().</p>
<p>故障排除<br>如果您正在加载资源包并且没有注意到任何更改，则可能是由于包装装载太晚。<br>菜单尤其如此 可能使用 preload（） 的 Load （） 中。这意味着在菜单中加载包不会影响已预加载的其他场景。<br>为避免这种情况，您需要尽早加载包。<br>为此，请创建一个新的自动加载脚本并调用 ProjectSettings.load_resource_pack（） 在自动加载脚本的 _init（） 函数中，而不是 _enter_tree（） 或 _ready（）。</p>
<h3 id="功能标签"><a href="#功能标签" class="headerlink" title="功能标签"></a>功能标签</h3><p>?</p>
<h3 id="为-Windows-导出"><a href="#为-Windows-导出" class="headerlink" title="为 Windows 导出"></a>为 Windows 导出</h3><p>在 PC 上分发游戏的最简单方法是复制可执行文件（godot.exe），将文件夹压缩，然后发送给别人。然而，这样一般并不理想。<br>Godot 在使用导出系统时，为 PC 分发提供了一种更为优雅的方法。<br>为 Windows 导出时，导出器将提取所有项目文件并创建一个 data.pck 文件。<br>该文件与特别优化的二进制文件捆绑在一起，更小、更快，并且不包含编辑器和调试器。</p>
<p>更改可执行文件图标<br>Godot 会自动使用在项目设置中指定为项目图标的图像，将其转换为 ICO 文件以供导出后的项目使用。<br>如果想要手动创建 ICO 文件，针对不同分辨率设置不同的图标外观，请查看 手动更改 Windows 的应用程序图标 页面。</p>
<p>代码签名<br>Godot 能够在导出时自动进行代码签名。<br>为此，您必须拥有 Windows SDK（在 Windows 上）或 osslsigncode （在任何其他作系统上）已安装。<br>您还需要一个包签名证书， 有关创建的信息可以在这里找到 。<br>警告<br>如果你用内嵌的PCK文件导出到Windows, 你将无法签名程序, 因为它会崩溃.<br>在Windows上,PCK嵌入也会在杀毒软件中造成误报. 因此, 建议避免使用它, 除非你的项目通过Steam发布, 因为这样就绕过了代码签名和防病毒检查.</p>
<p>场景布置<br>需要在两个地方更改设置。</p>
<ol>
<li>首先是在编辑器设置的导出 &gt; Windows 下。<br> 单击 Sign Tool 设置旁边的文件夹，如果你使用的是 Windows，请找到并选择 SignTool.exe，如果你使用的是其他操作系统，请选择 osslsigncode。</li>
<li>Windows 导出预设，可以在项目 &gt; 导出…中找到。<br> 如果尚未添加，则添加一个 Windows 桌面预设。在选项下有一个代码签章类别。<br> 必须将 Enabled 设置为 true，将 Identity 设置为签名证书。其他设置可以根据需要进行调整。完成后，Godot 就会在导出时为项目进行签名。</li>
</ol>
<p>环境变量<br>使用以下环境变量在编辑器外部设置导出选项。<br>在导出过程中，这些值会覆盖你在导出菜单中设置的值。</p>
<table>
<thead>
<tr>
<th align="left">导出选项</th>
<th align="left">环境变量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">加密 &#x2F; 密钥</td>
<td align="left"><code>GODOT_SCRIPT_ENCRYPTION_KEY</code></td>
</tr>
<tr>
<td align="left">选项 &#x2F; 代码签名 &#x2F; 身份类型</td>
<td align="left"><code>GODOT_WINDOWS_CODESIGN_IDENTITY_TYPE</code></td>
</tr>
<tr>
<td align="left">选项 &#x2F; 代码签名 &#x2F; 身份</td>
<td align="left"><code>GODOT_WINDOWS_CODESIGN_IDENTITY</code></td>
</tr>
<tr>
<td align="left">选项 &#x2F; 代码签名 &#x2F; 密码</td>
<td align="left"><code>GODOT_WINDOWS_CODESIGN_PASSWORD</code></td>
</tr>
</tbody></table>
<p>导出选项<br>在 <code>EditorExportPlatformWindows</code> 类引用。</p>
<h3 id="为-Android-导出"><a href="#为-Android-导出" class="headerlink" title="为 Android 导出"></a>为 Android 导出</h3><p>安装 OpenJDK 17<br>下载 Android SDK</p>
<p>在 Godot 中进行设置<br>设置两个路径：<br>Java SDK Path 应当为 OpenJDK 17 的安装位置。<br>Android Sdk Path 设置为Android SDK的安装位置. 例如,Windows上的 %LOCALAPPDATA%\Android\Sdk\ , 或macOS上的 &#x2F;Users&#x2F;$USER&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F; .</p>
<p>提供启动器图标<br>启动器图标是 Android 启动器应用把你的应用展示给用户时所用到的。<br>Godot 只需要高分辨率图标（适用于 xxxhdpi 屏幕），会自动生成低分辨率的变体。<br>这里有三种类型的图标：</p>
<ol>
<li>主图标：“经典”图标。这会在所有 Android 版本不高于 Android 8（Oreo）中使用。必须至少为 192×192 px。</li>
<li>自适应图标：从 Android 8 开始（含）引入了自适应图标（Adaptive Icons）。<br> 应用为了有原生的样式需要包含分离的背景与前景图标。用户的启动程序会控制图标的动画和遮罩。必须至少为 432×432 px。</li>
<li>主题图标 （可选）：从 Android 13 开始（含）引入了主题图标。<br> 应用程序需要包含一个单色图标来启用此特性。用户的启动程序会控制图标的主题。必须至少为 432×432 px。</li>
</ol>
<p>若未提供要求的图标（单色图标除外），Godot将按回退链自动替换：当前图标加载失败时，依次尝试链中的下一个候选图标。</p>
<ol>
<li>主图标：提供的主图标 -&gt; 项目图标 -&gt; 默认 Godot 主图标。</li>
<li>自适应图标前景：提供的前景图标 -&gt; 提供的主图标 -&gt; 项目图标 -&gt; 默认 Godot 前景图标。</li>
<li>自适应图标背景：提供的背景图标 -&gt; 默认 Godot 背景图标。<br>强烈建议提供所有要求的图标的指定分辨率。这样一来，你的应用程序在所有的 Android 设备和版本上都会显得非常漂亮。</li>
</ol>
<p>环境变量</p>
<table>
<thead>
<tr>
<th align="left">导出选项</th>
<th align="left">环境变量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">加密 &#x2F; 密钥</td>
<td align="left"><code>GODOT_SCRIPT_ENCRYPTION_KEY</code></td>
</tr>
<tr>
<td align="left">选项 &#x2F; 密钥库 &#x2F; 调试</td>
<td align="left"><code>GODOT_ANDROID_KEYSTORE_DEBUG_PATH</code></td>
</tr>
<tr>
<td align="left">选项 &#x2F; 密钥库 &#x2F; 调试用户</td>
<td align="left"><code>GODOT_ANDROID_KEYSTORE_DEBUG_USER</code></td>
</tr>
<tr>
<td align="left">选项 &#x2F; 密钥库 &#x2F; 调试密码</td>
<td align="left"><code>GODOT_ANDROID_KEYSTORE_DEBUG_PASSWORD</code></td>
</tr>
<tr>
<td align="left">选项 &#x2F; 密钥库 &#x2F; 发布</td>
<td align="left"><code>GODOT_ANDROID_KEYSTORE_RELEASE_PATH</code></td>
</tr>
<tr>
<td align="left">选项 &#x2F; 密钥库 &#x2F; 发布用户</td>
<td align="left"><code>GODOT_ANDROID_KEYSTORE_RELEASE_USER</code></td>
</tr>
<tr>
<td align="left">选项 &#x2F; 密钥库 &#x2F; 发布密码</td>
<td align="left"><code>GODOT_ANDROID_KEYSTORE_RELEASE_PASSWORD</code></td>
</tr>
</tbody></table>
<h3 id="为-macOS-导出"><a href="#为-macOS-导出" class="headerlink" title="为 macOS 导出"></a>为 macOS 导出</h3><h3 id="为-iOS-导出"><a href="#为-iOS-导出" class="headerlink" title="为 iOS 导出"></a>为 iOS 导出</h3><h3 id="为-Web-导出"><a href="#为-Web-导出" class="headerlink" title="为 Web 导出"></a>为 Web 导出</h3><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>添加 Android 导出预设项并且标记为可执行之后<br>Godot 就可以检测到有 USB 设备插到了电脑上<br>并且允许用户在该设备上自动导出、安装、然后运行（调试模式的）项目。</p>
<p>使用一键部署<br>Android：<br>请在移动设备上打开开发者模式，然后在设备的设置中启用 USB 调试。<br>启用 USB 调试后，请将设备通过 USB 线缆连接到 PC。<br>如果你是高级用户，也可以使用无线 ADB。</p>
<h3 id="为专用服务器导出"><a href="#为专用服务器导出" class="headerlink" title="为专用服务器导出"></a>为专用服务器导出</h3><p>需要在运行 Godot 的时候使用 headless 显示服务器和 Dummy 音频驱动。</p>
<p>编辑器与导出模板<br>可以在无头模式下使用编辑器或导出模板（调试或发布）二进位。你应该使用哪一种取决于你的用例：</p>
<ul>
<li>Export template（导出模板）：不包含编辑器的功能，体积更小、优化更高，是在服务器平台下的最佳选择。</li>
<li>Editor（编辑器）：包含编辑器功能的可执行文件，目的是用来导出项目。<br>  该可执行文件可以用来运行专用服务，但是因为其体积较大、优化程度较低，所以不建议将其作为专用服务器使用。</li>
</ul>
<p>导出方法<br>针对服务器导出项目的方法有两种：</p>
<ol>
<li>为服务器托管平台创建单独的导出预设，然后像往常一样导出项目。</li>
<li>仅导出PCK档案，最好是与将托管服务器的平台相配对的平台。将此PCK档案放在与导出模板二进位档案相同的文件夹中，将二进位档案重新命名为与PCK相同的名称（减去文件扩展名），然后执行该二进位档案。<br>两种方法的输出结果应该相同。本页其余部分将重点介绍第一种方法。</li>
</ol>
<p>启动专用服务器<br>如果你的客户端和服务器都是同一个 Godot 项目的一部分，则必须添加一种使用命令行参数直接启动服务器的方法。<br>如果你使用导出为专用服务器导出模式 导出了该项目（或已添加 dedicated_server 作为自定义功能标记），则可以使用 dedicated_server 功能标签来检测是否正在使用专用服务器 PCK：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Note: Feature tags are case-sensitive.</span><br><span class="line">if OS.has_feature(&quot;dedicated_server&quot;):</span><br><span class="line">	# Run your server startup code here...</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
<p>如果你还希望在使用内置的 –headless 命令行参数时托管服务器，可以在主场景（或自动加载）的 _ready() 方法中添加以下代码段来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if DisplayServer.get_name() == &quot;headless&quot;:</span><br><span class="line">	# Run your server startup code here...</span><br><span class="line">	#</span><br><span class="line">	# Using this check, you can start a dedicated server by running</span><br><span class="line">	# a Godot binary (editor or export template) with the `--headless`</span><br><span class="line">	# command-line argument.</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
<p>如果希望使用自定义命令行参数，可在主场景（或自动加载）的 _ready() 方法中添加以下代码段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if &quot;--server&quot; in OS.get_cmdline_user_args():</span><br><span class="line">	# Run your server startup code here...</span><br><span class="line">	#</span><br><span class="line">	# Using this check, you can start a dedicated server by running</span><br><span class="line">	# a Godot binary (editor or export template) with the `--server`</span><br><span class="line">	# command-line argument.</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
<p>最好新增至少一个上述命令列参数来启动服务器，因为它可用于从命令列测试服务器功能，而无需导出项目。<br>如果你的客户端和服务器是独立的Godot项目, 服务器通常应该配置成运行主场景时自启服务的方式.</p>
<p>在 Linux 上，要在崩溃或系统重新启动后重新启动您的专用服务器， 您可以 创建 systemd 服务 。<br>这还可以让您以更方便的方式查看服务器日志，并由 systemd 提供自动日志轮换。<br>当您的项目可托管为 systemd 服务时，您还应该启用 application&#x2F;run&#x2F;flush_stdout_on_print 项目设置。<br>这样，journald（systemd 日志记录服务）可以收集 进程运行时的日志。<br>如果你有容器的经验, 可以考虑将专用服务器包装在一个 Docker 容器中. 这样, 在弹性配置中可以更容易地使用它(这不在本教程的范围内).</p>
<h2 id="文件与数据-I-O"><a href="#文件与数据-I-O" class="headerlink" title="文件与数据 I&#x2F;O"></a>文件与数据 I&#x2F;O</h2><h3 id="后台加载"><a href="#后台加载" class="headerlink" title="后台加载"></a>后台加载</h3><p>后台加载<br>标准加载方法（ResourceLoader.load 或 GDScript 中更简单的 load）会阻塞线程，让你的游戏在加载资源时显得无响应。<br>解决这个问题的一种方法是使用 ResourceLoader 在后台线程中异步加载资源。</p>
<p>使用 ResourceLoader</p>
<ol>
<li>使用 <code>ResourceLoader.load_threaded_request</code> 将资源加载请求加入队列，其他线程会在后台进行加载。</li>
<li>使用 <code>ResourceLoader.load_threaded_get_status</code> 检查状态。<br> 给 progress 传一个数组变量就可以获取进度，返回时该数组中包含一个元素，表示百分比。</li>
<li>最后调用 <code>ResourceLoader.load_threaded_get</code> 即可获取加载到的资源。<br>调用 load_threaded_get() 有两种结果：</li>
<li>要么资源已经完成了后台加载，此时就会立即返回；</li>
<li>要么加载尚未完成，此时就会和 load() 一样发生阻塞。<br>如果你希望保证调用时不发生阻塞，就需要确保请求加载和获取资源之间留够时间，或者也可以先手动进行状态检查。</li>
</ol>
<p>示例<br>下面这个例子演示的是如何进行场景的后台加载。<br>按下按钮后就会生成一个敌人。<br>敌人使用的是 _onready 时加载的 Enemy.tscn，按下按钮时进行实例化。<br>该场景的路径为 “Enemy.tscn”，位于 res:&#x2F;&#x2F;Enemy.tscn。<br>首先，我们将启动一个请求来加载资源并连接按钮：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ENEMY_SCENE_PATH : String = &quot;Enemy.tscn&quot;</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	ResourceLoader.load_threaded_request(ENEMY_SCENE_PATH)</span><br><span class="line">	self.pressed.connect(_on_button_pressed)</span><br></pre></td></tr></table></figure>
<p>现在按下按钮就会调用 _on_button_pressed。该方法的作用是生成敌人。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func _on_button_pressed(): # Button was pressed.</span><br><span class="line">	# Obtain the resource now that we need it.</span><br><span class="line">	var enemy_scene = ResourceLoader.load_threaded_get(ENEMY_SCENE_PATH)</span><br><span class="line">	# Instantiate the enemy scene and add it to the current scene.</span><br><span class="line">	var enemy = enemy_scene.instantiate()</span><br><span class="line">	add_child(enemy)</span><br></pre></td></tr></table></figure>

<h3 id="Godot-项目中的文件路径"><a href="#Godot-项目中的文件路径" class="headerlink" title="Godot 项目中的文件路径"></a>Godot 项目中的文件路径</h3><p>如何在项目中使用 res:&#x2F;&#x2F; 和 user:&#x2F;&#x2F; 标记来访问路径，<br>及 Godot 会在你的以及用户系统上的哪些位置存储项目和编辑器文件。</p>
<p>路径分隔符<br>Godot 使用 UNIX 风格的路径分隔符（正斜杠 &#x2F;）。<br>在 Godot 里写的不是类似 C:\Projects\Game 的路径，而应该写 C:&#x2F;Projects&#x2F;Game。<br>有些路径相关的方法也支持 Windows 风格的路径分隔符（反斜杠\），不过需要写两个（\），因为 \ 一般是用来进行字符转义的，有特殊含义。<br>这样就能够处理其他 Windows 程序所返回的路径了。仍建议在代码里只使用正斜杠，这样才能确保一切都能正常工作。</p>
<p>访问项目文件夹中的文件（res:&#x2F;&#x2F;）<br>只要文件夹中存在名叫 project.godot 的文本文件，即便是空文件，Godot 也会认为这个文件夹中包含了一个项目。<br>包含这个文件的文件夹是项目根文件夹。<br>相对于这个文件夹的任何文件，都可以通过以 res:&#x2F;&#x2F; 开头的路径访问，这个前缀代表“资源”（resource）。</p>
<p>访问持久化用户数据（user:&#x2F;&#x2F;）<br>要存储持久化数据文件，比如玩家的存档、设置等，你会想要使用 user:&#x2F;&#x2F; 作为路径前缀，而不是 res:&#x2F;&#x2F;。<br>这是因为游戏运行时，项目的文件系统很可能是只读的。<br>user:&#x2F;&#x2F; 前缀指向的是用户设备上的其他目录。<br>与 res:&#x2F;&#x2F; 不同，即便在导出后的项目中，user:&#x2F;&#x2F; 指向的这个目录也会自动创建并且保证可写。<br>user:&#x2F;&#x2F; 文件夹的位置由“项目设置”中的配置决定：</p>
<ul>
<li>默认情况下，user:&#x2F;&#x2F; 文件夹是在编辑器数据路径中创建的 app_userdata&#x2F;[项目名称] 文件夹。<br>  使用这一默认值的目的是让原型和测试项目能够在 Godot 的数据文件夹中达到自包含。</li>
<li>如果在项目设置中启用了 application&#x2F;config&#x2F;use_custom_user_dir，则会在 Godot 编辑器数据路径的旁边创建 user:&#x2F;&#x2F; 文件夹，即在应用程序数据的标准位置。<br>默认情况下，文件夹名称是从项目名称推导出来的，但可以使用 application&#x2F;config&#x2F;custom_user_dir_name 进行进一步的自定义。这个路径可以包含路径分隔符，那么比如你就可以把给定工作室的项目都分组到 工作室名称&#x2F;游戏名称 这样的目录结构之下。<br>在桌面平台上，user:&#x2F;&#x2F; 的实际目录路径为：<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位置</th>
<th align="left">默认</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left">Windows：<code>%APPDATA%\Godot\app_userdata\[项目名称]</code><br>macOS：<code>~/Library/Application Support/Godot/app_userdata/[项目名称]</code><br>Linux：<code>~/.local/share/godot/app_userdata/[项目名称]</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">自定义目录</td>
<td align="left">Windows：<code>%APPDATA%\[项目名称]</code><br>macOS：<code>~/Library/Application Support/Godot/[项目名称]</code><br>Linux：<code>~/.local/share/godot/[项目名称]</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">自定义目录及名称</td>
<td align="left">Windows：<code>%APPDATA%\[自定义目录名称]</code><br>macOS：<code>~/Library/Application Support/[自定义目录名称]</code><br>Linux：<code>~/.local/share/[自定义目录名称]</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">在移动平台上，这个路径是与项目相关的，每个项目都不一样，并且出于安全原因无法被其他应用程序访问。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">在 HTML5 导出中，user:&#x2F;&#x2F; 会指向保存在设备的虚拟文件系统，这个文件系统使用 IndexedDB 实现。（仍然可以通过 JavaScriptBridge 与主文件系统交互。）</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
</ul>
<p>将路径转换为绝对路径或“本地”路径<br>你可以使用 <code>ProjectSettings.globalize_path()</code> 将类似 res:&#x2F;&#x2F;path&#x2F;to&#x2F;file.txt 的本地路径转换为操作系统的绝对路径。<br>例如，可以使用 <code>ProjectSettings.globalize_path()</code> 在操作系统的文件管理器中通过 OS.shell_open() 打开“本地”路径，因为这个函数只接受原生操作系统路径。<br>要将操作系统绝对路径转换为以 res:&#x2F;&#x2F; 或 user:&#x2F;&#x2F; 开头的“本地”路径，请使用 ProjectSettings.localize_path()。<br>只对指向项目根目录或者 user:&#x2F;&#x2F; 文件夹中的文件或文件夹有效。</p>
<p>编辑器数据路径<br>根据平台的不同，编辑器会使用不同的路径来存储编辑器数据、编辑器设置、缓存。默认情况下，这些路径是：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">编辑器数据</td>
<td align="left">Windows：<code>%APPDATA%\Godot/</code><br>macOS：<code>~/Library/Application Support/Godot/</code><br>Linux：<code>~/.local/share/godot/</code></td>
</tr>
<tr>
<td align="left">编辑器设置</td>
<td align="left">Windows：<code>%APPDATA%\Godot/</code><br>macOS：<code>~/Library/Application Support/Godot/</code><br>Linux：<code>~/.config/godot/</code></td>
</tr>
<tr>
<td align="left">缓存</td>
<td align="left">Windows：<code>%TEMP%\Godot/</code><br>macOS：<code>~/Library/Caches/Godot/</code><br>Linux：<code>~/.cache/godot/</code></td>
</tr>
<tr>
<td align="left">Godot 符合 XDG 基本目录规范 在 Linux&#x2F;*BSD 上。您可以覆盖 XDG_DATA_HOME、XDG_CONFIG_HOME 和 XDG_CACHE_HOME 环境变量以更改编辑器和项目数据路径。</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>如果你使用的是 Flatpak 打包的 Godot，编辑器数据路径将位于 ~&#x2F;.var&#x2F;app&#x2F;org.godotengine.godot&#x2F; 的子文件夹中。</p>
</blockquote>
<p>自包含模式<br>如果你在编辑器二进制文件所在的目录下创建了名为 .<em>sc</em> 或 <em>sc</em> 的文件（macOS 编辑器 .app 捆绑包则是在 MacOS&#x2F;Contents&#x2F; 下），Godot 就会开启自包含模式。<br>这种模式下，Godot 会将所有编辑器数据、设置、缓存都写入一个与编辑器二进制文件位于同一目录中的名为 editor_data&#x2F; 的目录。你可以用它来创建便携安装的编辑器。<br>Steam 版本的 Godot 默认使用自包含模式。</p>
<p>备注<br>导出后的项目目前不支持自包含模式。要对相对于可执行文件路径的文件进行读写，请使用 OS.get_executable_path()。<br>注意，只有可执行文件位于可写的位置时，才能够对可执行文件路径上的文件进行写操作（即不在 Program Files 或者其他普通用户只读的目录中）。</p>
<h3 id="保存游戏"><a href="#保存游戏" class="headerlink" title="保存游戏"></a>保存游戏</h3><blockquote>
<p>如果你想保存玩家的设置，可以用 <code>ConfigFile</code> 来实现这个目的。<br>识别持久化对象<br>要保存哪些对象，要保存对象中的哪些信息。<br>本教程中，我们将使用“分组”来标记和处理要保存的对象，但当然也有其他可行的方法。</p>
</blockquote>
<ol>
<li><p>将想要保存的对象添加到“Persist”组。<br>完成这个操作后，我们需要保存游戏时，就可以获取所有需要保存的对象，然后通过这个脚本让这些对象去保存数据：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var save_nodes = get_tree().get_nodes_in_group(&quot;Persist&quot;)</span><br><span class="line">for node in save_nodes:</span><br><span class="line"># 现在，我们可以在每个节点上调用我们的保存函数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>序列化<br>下一步是序列化数据。使得读取和存储到磁盘变得更加容易。<br>在本例中，我们假设组 Persist 的每个成员都是一个实例化节点，因此有一个路径。<br>GDScript 具有用于在字典和字符串之间转换的辅助类 JSON。<br>我们的节点需要包含一个返回此数据的保存函数。保存函数将如下所示：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func save():</span><br><span class="line">	var save_dict = &#123;</span><br><span class="line">		&quot;filename&quot; : get_scene_file_path(),</span><br><span class="line">		&quot;parent&quot; : get_parent().get_path(),</span><br><span class="line">		&quot;pos_x&quot; : position.x, # Vector2 is not supported by JSON</span><br><span class="line">		&quot;pos_y&quot; : position.y,</span><br><span class="line">		&quot;attack&quot; : attack,</span><br><span class="line">		&quot;defense&quot; : defense,</span><br><span class="line">		&quot;current_health&quot; : current_health,</span><br><span class="line">		&quot;max_health&quot; : max_health,</span><br><span class="line">		&quot;damage&quot; : damage,</span><br><span class="line">		&quot;regen&quot; : regen,</span><br><span class="line">		&quot;experience&quot; : experience,</span><br><span class="line">		&quot;tnl&quot; : tnl,</span><br><span class="line">		&quot;level&quot; : level,</span><br><span class="line">		&quot;attack_growth&quot; : attack_growth,</span><br><span class="line">		&quot;defense_growth&quot; : defense_growth,</span><br><span class="line">		&quot;health_growth&quot; : health_growth,</span><br><span class="line">		&quot;is_alive&quot; : is_alive,</span><br><span class="line">		&quot;last_attack&quot; : last_attack</span><br><span class="line">	&#125;</span><br><span class="line">	return save_dict</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>保存和读取数据<br>需要打开一个文件，以便对其进行写入或读取。<br>现在我们有了调用组并获取其相关数据的方法，让我们使用 JSON 类将其转换为易于存储的字符串，并将它们存储在文件中。<br>这样做可以确保每一行都是自己的对象，因此我们也可以轻松地从文件中提取数据。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 注意：此函数可以从场景树的任意位置调用，与节点路径无关。</span><br><span class="line"># 遍历所有属于 &quot;Persist&quot; 组的节点，请求它们返回包含相关变量的字典。</span><br><span class="line">func save_game():</span><br><span class="line">    # 打开或创建本地保存文件（写入模式）</span><br><span class="line">    var save_file = FileAccess.open(&quot;user://savegame.save&quot;, FileAccess.WRITE)</span><br><span class="line">    </span><br><span class="line">    # 获取场景树中所有属于 &quot;Persist&quot; 组的节点</span><br><span class="line">    var save_nodes = get_tree().get_nodes_in_group(&quot;Persist&quot;)</span><br><span class="line">    </span><br><span class="line">    for node in save_nodes:</span><br><span class="line">        # 检查该节点是否为实例化场景，确保在加载时能重新实例化</span><br><span class="line">        if node.scene_file_path.is_empty():</span><br><span class="line">            print(&quot;持久化节点 &#x27;%s&#x27; 不是实例化场景，已跳过&quot; % node.name)</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        # 检查该节点是否实现了 save 方法</span><br><span class="line">        if !node.has_method(&quot;save&quot;):</span><br><span class="line">            print(&quot;持久化节点 &#x27;%s&#x27; 缺少 save() 函数，已跳过&quot; % node.name)</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        # 调用节点的 save 方法，获取其保存数据</span><br><span class="line">        var node_data = node.call(&quot;save&quot;)</span><br><span class="line"></span><br><span class="line">        # 使用 JSON.stringify 将数据字典序列化为 JSON 字符串</span><br><span class="line">        var json_string = JSON.stringify(node_data)</span><br><span class="line"></span><br><span class="line">        # 将每条节点的 JSON 数据作为一行写入保存文件</span><br><span class="line">        save_file.store_line(json_string)</span><br></pre></td></tr></table></figure>
<p>游戏已保存！现在，为了加载，我们将读取每一行。<br>使用 parse 方法将 JSON 字符串读回到字典中，然后遍历字典以读取我们的值。<br>但我们首先需要创建对象，然后我们可以使用文件名和父级值来实现这一点。这是我们的加载函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 注意：此函数可以从场景树的任意位置调用，与节点路径无关。</span><br><span class="line">func load_game():</span><br><span class="line">    # 检查存档文件是否存在</span><br><span class="line">    if not FileAccess.file_exists(&quot;user://savegame.save&quot;):</span><br><span class="line">        return  # 错误！没有可加载的存档文件，直接返回</span><br><span class="line"></span><br><span class="line">    # 在加载前需要重置游戏状态，避免加载时出现对象重复。</span><br><span class="line">    # 具体实现方式因项目而异，需谨慎处理。</span><br><span class="line">    # 在本示例中，通过删除所有标记为可保存的对象来实现重置。</span><br><span class="line">    var save_nodes = get_tree().get_nodes_in_group(&quot;Persist&quot;)</span><br><span class="line">    for node in save_nodes:</span><br><span class="line">        node.queue_free()  # 安全删除节点</span><br><span class="line"></span><br><span class="line">    # 打开存档文件，逐行读取并解析数据，恢复对应的对象</span><br><span class="line">    var save_file = FileAccess.open(&quot;user://savegame.save&quot;, FileAccess.READ)</span><br><span class="line">    while save_file.get_position() &lt; save_file.get_length():</span><br><span class="line">        var json_string = save_file.get_line()  # 读取一行 JSON 数据</span><br><span class="line"></span><br><span class="line">        # 创建 JSON 解析器实例</span><br><span class="line">        var json = JSON.new()</span><br><span class="line"></span><br><span class="line">        # 检查 JSON 解析是否出错，若失败则跳过该行</span><br><span class="line">        var parse_result = json.parse(json_string)</span><br><span class="line">        if parse_result != OK:</span><br><span class="line">            print(&quot;JSON 解析错误：&quot;, json.get_error_message(), &quot; 在 &quot;, json_string, &quot; 第 &quot;, json.get_error_line(), &quot; 行&quot;)</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        # 获取解析后的数据字典</span><br><span class="line">        var node_data = json.data</span><br><span class="line"></span><br><span class="line">        # 首先，需要创建对象实例，并添加到场景树中，设置其位置</span><br><span class="line">        var new_object = load(node_data[&quot;filename&quot;]).instantiate()  # 加载并实例化场景</span><br><span class="line">        get_node(node_data[&quot;parent&quot;]).add_child(new_object)         # 添加为指定父节点的子节点</span><br><span class="line">        new_object.position = Vector2(node_data[&quot;pos_x&quot;], node_data[&quot;pos_y&quot;])  # 设置位置</span><br><span class="line"></span><br><span class="line">        # 接着，恢复该对象的其他变量</span><br><span class="line">        for key in node_data.keys():</span><br><span class="line">            # 跳过已处理的特殊字段</span><br><span class="line">            if key in [&quot;filename&quot;, &quot;parent&quot;, &quot;pos_x&quot;, &quot;pos_y&quot;]:</span><br><span class="line">                continue</span><br><span class="line">            # 使用 set() 方法动态设置对象的属性</span><br><span class="line">            new_object.set(key, node_data[key])</span><br></pre></td></tr></table></figure>
<p>现在我们可以保存和加载几乎任何位于场景树中的任意数量的对象了！ 每个对象可以根据需要保存的内容存储不同的数据.</p>
<p>一些注释<br>我们可能忽略了 “将游戏状态设置到适合以加载数据” 这一步.<br>最终, 这一步怎么做的决定权在项目创建者手里. 这通常很复杂, 需要根据单个项目的需求对此步骤进行大量定制.<br>另外, 此实现假定没有Persist对象是其他Persist对象的子对象.<br>否则会产生无效路径. 如果这是项目的需求之一, 可以考虑分阶段保存对象(父对象优先), 以便在加载子对象时可用它们将确保它们可用于 add_child() 调用.<br>由于 NodePath 可能无效, 因此可能还需要某种方式将子项链接到父项.</p>
<p>JSON 与二进制序列化<br>简单的游戏状态可能可以使用 JSON，生成的是人类可读的文件，便于调试。<br>但是 JSON 也存在限制。如果你需要存储比较复杂的游戏状态，或者量比较大，使用二进制序列化可能更合适。</p>
<p>JSON 的限制<br>以下是一些使用 JSON 时会遇到的大坑。</p>
<ul>
<li>文件大小：JSON 使用文本格式存储数据，比二进制格式要大很多。</li>
<li>数据类型：JSON 只提供了有限的数据类型。如果你用到了 JSON 没有的数据类型，就需要自己在这个类型和 JSON 能够处理的类型之间来回转换。<br>  例如 JSON 无法解析以下重要的类型：Vector2、Vector3、Color、Rect2、Quaternion。</li>
<li>编解码需要自定义逻辑：如果你想要用 JSON 存储自定义的类，就需要自己编写这些类的编解码逻辑。</li>
</ul>
<p>二进制序列化<br>也可以使用二进制序列化来存储游戏状态，可以使用 FileAccess 的 get_var 和 store_var 来实现。<br>二进制序列化生成的文件比 JSON 小。<br>二进制序列化能够处理大多数常见数据类型。<br>二进制序列化在编解码自定义类时需要更少的自定义逻辑。<br>请注意，并非所有属性都包括在内。只有使用 PROPERTY_USAGE_STORAGE 标志集配置的属性才会被序列化。<br>你可以通过在类中重写 _get_property_list 方法，来向属性添加新的使用标志。<br>你还可以通过调用 Object._get_property_list 来检查属性使用是如何配置的。有关可能的使用标志，请参阅 PropertyUsageFlags。</p>
<h3 id="运行时文件加载和保存"><a href="#运行时文件加载和保存" class="headerlink" title="运行时文件加载和保存"></a>运行时文件加载和保存</h3><p>纯文本文件和二进制文件<br>Godot 的 FileAccess 类提供了读写文件系统中文件的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func save_file(content):</span><br><span class="line">	var file = FileAccess.open(&quot;/path/to/file.txt&quot;, FileAccess.WRITE)</span><br><span class="line">	file.store_string(content)</span><br><span class="line"></span><br><span class="line">func load_file():</span><br><span class="line">	var file = FileAccess.open(&quot;/path/to/file.txt&quot;, FileAccess.READ)</span><br><span class="line">	var content = file.get_as_text()</span><br><span class="line">	return content</span><br></pre></td></tr></table></figure>
<p>为了处理自定义二进制格式（例如加载 Godot 不支持的文件格式），FileAccess 提供了几种方法来读取&#x2F;写入整数、浮点数、字符串等。<br>这些 FileAccess 方法的名称以 get_ 和 store_。<br>如果你需要对读取二进制文件进行更多控制，或者需要读取不属于文件的二进制流，PackedByteArray 提供了几种辅助方法，可以将一系列字节解码&#x2F;编码为整数、浮点、字符串等数据类型。这些 PackedByteArray 方法的名称以 decode_ 和 encode_ 开头。另请参阅《二进制序列化 API》。</p>
<p>图像<br>Image 的 Image.load_from_file 静态方法处理各种事物，包括从基于文件扩展名的格式检测到从磁盘读取文件。<br>如果你需要错误处理或者更多的控制（例如更改加载 SVG 时的缩放），请根据文件格式使用以下方法：<br>Image.load_jpg_from_buffer<br>Image.load_ktx_from_buffer<br>Image.load_png_from_buffer<br>Image.load_svg_from_buffer 或 Image.load_svg_from_string<br>Image.load_tga_from_buffer<br>Image.load_webp_from_buffer</p>
<p>Godot 还可以在运行时使用以下方法保存几种图像格式：<br>Image.save_png 或 Image.save_png_to_buffer<br>Image.save_webp 或 Image.save_webp_to_buffer<br>Image.save_jpg 或 Image.save_jpg_to_buffer<br>Image.save_exr 或 Image.save_exr_to_buffer （仅在编辑器版本中可用，无法在导出后的项目中使用）<br>带有 to_buffer 后缀的方法会将图像保存到 PackedByteArray 而不是文件系统。<br>这有利于通过网络发送图像或将图像发生到 ZIP 存档，无需将其写入到文件系统。这可以通过降低 I&#x2F;O 利用率来提高性能。</p>
<p>备注<br>如果在 3D 曲面上显示加载的图像，请确保调用 Image.generate_mipmaps，以便在远处观察时纹理看起来不会有颗粒感。<br>在 2D 中，当遵循关于《减少降采样时的锯齿》的说明时也很有用。</p>
<p>加载图像并将其显示在 TextureRect 节点（需要转换为 ImageTexture）中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 从文件系统加载任意 Godot 支持格式的图像</span><br><span class="line">var image = Image.load_from_file(path)</span><br><span class="line"># （可选）如果要在3D表面显示该纹理，建议生成Mipmap，</span><br><span class="line"># 以避免在远距离观察时纹理出现颗粒感或闪烁。</span><br><span class="line"># image.generate_mipmaps()</span><br><span class="line">$TextureRect.texture = ImageTexture.create_from_image(image)</span><br><span class="line"></span><br><span class="line"># 将加载的 Image 对象保存为 PNG 图像文件</span><br><span class="line">image.save_png(&quot;/path/to/file.png&quot;)</span><br><span class="line"></span><br><span class="line"># 将转换后的 ImageTexture 中的图像数据提取并保存为 PNG 文件</span><br><span class="line">$TextureRect.texture.get_image().save_png(&quot;/path/to/file.png&quot;)</span><br></pre></td></tr></table></figure>

<p>音视频文件<br>Godot 支持在运行时加载 Ogg Vorbis、MP3 和 WAV 音频。<br>请注意，并非所有 扩展名为 .ogg 的文件是 Ogg Vorbis 文件。<br>有些可能是 Ogg Theora 视频，或者在 Ogg 容器中包含 Opus 音频。这些文件不会 在 Godot 中正确加载为音频文件。<br>通过 AudioStreamPlayer 节点加载 Ogg Vorbis 音频文件的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$AudioStreamPlayer.stream = AudioStreamOggVorbis.load_from_file(path)</span><br></pre></td></tr></table></figure>
<p>通过 VideoStreamPlayer 节点加载 Ogg Theora 视频文件的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个新的VideoStreamTheora对象实例</span><br><span class="line">var video_stream_theora = VideoStreamTheora.new()</span><br><span class="line"></span><br><span class="line"># 设置视频文件路径给video_stream_theora对象。</span><br><span class="line"># 注意：文件扩展名可以是.ogg，即使实际上是一个Ogg Theora格式的视频文件</span><br><span class="line">video_stream_theora.file = &quot;/path/to/file.ogv&quot;</span><br><span class="line"></span><br><span class="line"># 将设置好的视频流赋值给场景中的VideoStreamPlayer节点</span><br><span class="line">$VideoStreamPlayer.stream = video_stream_theora</span><br><span class="line"></span><br><span class="line"># 如果在设置stream属性之前VideoStreamPlayer的流是空的，</span><br><span class="line"># 那么VideoStreamPlayer的自动播放(Autoplay)属性将不会生效。</span><br><span class="line"># 因此，在设置了stream属性之后，需要手动调用play()方法来播放视频。</span><br><span class="line">$VideoStreamPlayer.play()</span><br></pre></td></tr></table></figure>

<p>3D 场景<br>Godot 在编辑器和导出项目中都对 glTF 2.0 提供了一流的支持。<br>结合使用 GLTFDocument 和 GLTFState，Godot 可以在导出的项目中加载和保存 glTF 文件，包括文本格式（.gltf）和二进制格式（.glb）。<br>二进制格式应该优先考虑，因为它写入速度更快且体积更小，但文本格式更易于调试。</p>
<p>从 Godot 4.3 开始，FBX 场景也可以在运行时使用 FBXDocument 和 FBXState 类。<br>执行此作的代码 与 glTF 相同，但您需要替换 GLTFDocument 和 GLTFState 以及 FBXDocument 和 FBXState 在下面的代码示例中。<br>存在已知问题 运行时 FBX 加载，因此目前首选使用 glTF。</p>
<p>加载 glTF 场景并将其根节点附加到场景的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 加载一个现有的 glTF 场景。</span><br><span class="line"># GLTFState 用于存储 GLTFDocument 在加载 glTF 场景过程中的状态信息。</span><br><span class="line"># GLTFDocument 是实际负责将 glTF 数据解析并转换为 Godot 节点树的类，</span><br><span class="line"># 因此它支持 glTF 的各种特性，例如灯光、摄像机、动画等。</span><br><span class="line">var gltf_document_load = GLTFDocument.new()</span><br><span class="line">var gltf_state_load = GLTFState.new()</span><br><span class="line">var error = gltf_document_load.append_from_file(&quot;/path/to/file.gltf&quot;, gltf_state_load)</span><br><span class="line">if error == OK:</span><br><span class="line">    # 成功加载后，从状态中生成对应的场景根节点</span><br><span class="line">    var gltf_scene_root_node = gltf_document_load.generate_scene(gltf_state_load)</span><br><span class="line">    # 将生成的场景添加为当前节点的子节点</span><br><span class="line">    add_child(gltf_scene_root_node)</span><br><span class="line">else:</span><br><span class="line">    # 加载失败时显示错误信息</span><br><span class="line">    show_error(&quot;无法加载 glTF 场景（错误代码：%s）。&quot; % error_string(error))</span><br><span class="line"></span><br><span class="line"># 保存一个新的 glTF 场景。</span><br><span class="line">var gltf_document_save := GLTFDocument.new()</span><br><span class="line">var gltf_state_save := GLTFState.new()</span><br><span class="line"># 将指定的场景节点导出到 glTF 状态中</span><br><span class="line">gltf_document_save.append_from_scene(gltf_scene_root_node, gltf_state_save)</span><br><span class="line"># 输出文件的扩展名（`.gltf` 或 `.glb`）决定了保存为文本格式还是二进制格式</span><br><span class="line"># 此外，也可使用 `GLTFDocument.generate_buffer()` 将数据保存到内存中</span><br><span class="line">gltf_document_save.write_to_filesystem(gltf_state_save, path)</span><br></pre></td></tr></table></figure>
<p>注<br>加载 glTF 场景时，必须设置基础路径，以便可以正确加载纹理等外部资源。<br>从文件加载时，基础路径会自动设置为包含该文件的文件夹。从缓冲区加载时，必须手动设置该基础路径，因为 Godot 无法推断该路径。<br>要设置基础路径，请在调用 GLTFDocument.append_from_buffer 或 GLTFDocument.append_from_file 之前，在 GLTFState 实例上设置 GLTFState.base_path。</p>
<p>字体<br>FontFile.load_dynamic_font 支持以下字体文件格式：TTF、OTF、WOFF、WOFF2、PFB、PFM<br>另一方面，FontFile.load_bitmap_font支持 BMFont 格式（.fnt 或 .font）。<br>此外，可以使用 Godot 对《系统字体》的支持来加载系统上安装的任何字体。<br>根据文件扩展名自动加载字体文件，然后将其作为主题覆盖添加到 Label 节点的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var path = &quot;/path/to/font.ttf&quot;</span><br><span class="line">var path_lower = path.to_lower()</span><br><span class="line">var font_file = FontFile.new()</span><br><span class="line">if (</span><br><span class="line">		path_lower.ends_with(&quot;.ttf&quot;)</span><br><span class="line">		or path_lower.ends_with(&quot;.otf&quot;)</span><br><span class="line">		or path_lower.ends_with(&quot;.woff&quot;)</span><br><span class="line">		or path_lower.ends_with(&quot;.woff2&quot;)</span><br><span class="line">		or path_lower.ends_with(&quot;.pfb&quot;)</span><br><span class="line">		or path_lower.ends_with(&quot;.pfm&quot;)</span><br><span class="line">):</span><br><span class="line">	font_file.load_dynamic_font(path)</span><br><span class="line">elif path_lower.ends_with(&quot;.fnt&quot;) or path_lower.ends_with(&quot;.font&quot;):</span><br><span class="line">	font_file.load_bitmap_font(path)</span><br><span class="line">else:</span><br><span class="line">	push_error(&quot;Invalid font file format.&quot;)</span><br><span class="line"></span><br><span class="line">if not font_file.data.is_empty():</span><br><span class="line">	# If font was loaded successfully, add it as a theme override.</span><br><span class="line">	$Label.add_theme_font_override(&quot;font&quot;, font_file)</span><br></pre></td></tr></table></figure>

<p>ZIP 压缩包<br>Godot 支持使用 ZIPReader 和 ZIPPacker 类读取和写入 ZIP 档案。<br>这支持任何 ZIP 文件，包括由 Godot 的“导出 PCK&#x2F;ZIP”功能生成的文件（尽管这些文件将包含导入的 Godot 资源而不是原始项目文件）。<br>备注<br>使用 ProjectSettings.load_resource_pack 将 Godot 导出的 PCK 或 ZIP 文件加载为 附加数据包。<br>这种方法是 DLC 的首选，因为它可以无缝地与附加数据包（虚拟文件系统）进行交互。</p>
<p>这种 ZIP 存档支持可与运行时图像、3D 场景和音频加载相结合，提供无缝的模组化体验，而无需用户通过 Godot 编辑器生成 PCK&#x2F;ZIP 文件。<br>示例在 ItemList 节点中列出 ZIP 存档中的文件，然后将从中读取的内容写入新的 ZIP 存档（本质上是复制该存档）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 加载一个已存在的 ZIP 压缩包</span><br><span class="line">var zip_reader = ZIPReader.new()</span><br><span class="line">zip_reader.open(path)  # 打开指定路径的 ZIP 文件</span><br><span class="line">var files = zip_reader.get_files()  # 获取压缩包内所有文件的路径列表</span><br><span class="line"># 文件列表默认未排序，进行排序以确保处理顺序一致</span><br><span class="line">files.sort()</span><br><span class="line">for file in files:</span><br><span class="line">    $ItemList.add_item(file, null)  # 在 ItemList 控件中添加文件名</span><br><span class="line">    # 将路径以 &quot;/&quot; 结尾的条目（即文件夹）设置为禁用状态</span><br><span class="line">    $ItemList.set_item_disabled(-1, file.ends_with(&quot;/&quot;))</span><br><span class="line"></span><br><span class="line"># 保存为一个新的 ZIP 压缩包</span><br><span class="line">var zip_packer = ZIPPacker.new()</span><br><span class="line">var error = zip_packer.open(path)</span><br><span class="line">if error != OK:</span><br><span class="line">    push_error(&quot;无法打开路径以保存 ZIP 压缩包（错误代码：%s）。&quot; % error_string(error))</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"># 复用上面创建的 ZIPReader 实例，读取已有压缩包中的文件内容</span><br><span class="line">for file in zip_reader.get_files():</span><br><span class="line">    zip_packer.start_file(file)                    # 开始向压缩包中添加一个新文件</span><br><span class="line">    zip_packer.write_file(zip_reader.read_file(file))  # 写入文件数据</span><br><span class="line">    zip_packer.close_file()                        # 结束当前文件的写入</span><br><span class="line"></span><br><span class="line">zip_packer.close()  # 关闭压缩包，完成写入操作</span><br></pre></td></tr></table></figure>


<h3 id="二进制序列化-API"><a href="#二进制序列化-API" class="headerlink" title="二进制序列化 API"></a>二进制序列化 API</h3><p>Godot 有一个基于 Variant 的序列化 API，用于高效地将数据类型转换为字节数组。<br>该 API 通过全局 bytes_to_var() 和 var_to_bytes() 函数公开，但它也用在 FileAccess 的 get_var 和 store_var 方法中以及 PacketPeer 的数据包 API。<br>该格式并不用于二进制场景和资源。</p>
<p>完整对象 vs 对象实例 ID<br>如果序列化变量时使用了 full_objects &#x3D; true，则该变量中所包含的 Object 都会进行序列化、包含在结果中。这个过程是递归的。<br>如果 full_objects &#x3D; false，则只会对该变量中所包含的 Object 的实例 ID 进行序列化。</p>
<p>数据包规格<br>根据设计，数据包总是会被填充到 4 个字节。<br>所有的值都是小端编码的。<br>所有数据包都有一个 4 字节的头，代表一个整数，指定数据的类型。<br>最小值 two 字节用于确定类型，而最高值 two 字节包含标志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base_type = val &amp; 0xFFFF;</span><br><span class="line">flags = val &gt;&gt; 16;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">null 零</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">bool 布尔语</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">integer 整数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">float 浮</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">字符串</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">vector2 矢量2</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">rect2 矩形2</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">vector3 矢量3</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">transform2d 变换 2D</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">plane 飞机</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">四元数</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">aabb 亚伯</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">basis 基础</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">transform3d 变形 3D</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">颜色</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">节点路径</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">rid 摆脱</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">对象</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">字典</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">数组</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">原始数组</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">int32 数组</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">int64 数组</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">float32 数组</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">float64 数组</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">字符串数组</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">vector2 数组</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">vector3 数组</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">颜色数组</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">max 麦克斯</td>
</tr>
<tr>
<td align="left">在此之后是实际的数据包内容，每种类型的数据包内容都不同。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">请注意，这里假设 Godot 是用单精度浮点数编译的，这也是默认的。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">如果 Godot 是用双精度浮点数编译的，那么数据结构中“浮点数”字段的长度应该是 8，偏移量应该是 (offset - 4) * 2 + 4。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">浮点数“float”类型本身总是使用双精度。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><h3 id="游戏的国际化"><a href="#游戏的国际化" class="headerlink" title="游戏的国际化"></a>游戏的国际化</h3><p>资源的本地化<br>还可以指示 Godot 根据当前语言使用资产（资源）的替代版本。<br>这可用于本地化诸如游戏内广告牌之类的图像或者语音。<br>重定向选项卡便可用于此：</p>
<p>自动设置语言<br>建议默认使用用户的首选语言，可以通过 <code>OS.get_locale_language()</code> 获取。<br>如果你的游戏不支持该语言，则会回退到 项目设置 &gt; 国际化 &gt; 区域 中的 回退语言，如果为空则回退到 en。<br>不过，出于各种原因（例如翻译质量或玩家偏好），建议让玩家能够在游戏中更改语言。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var language = &quot;automatic&quot;</span><br><span class="line"># Load here language from the user settings file</span><br><span class="line">if language == &quot;automatic&quot;:</span><br><span class="line">   var preferred_language = OS.get_locale_language()</span><br><span class="line">   TranslationServer.set_locale(preferred_language)</span><br><span class="line">else:</span><br><span class="line">   TranslationServer.set_locale(language)</span><br></pre></td></tr></table></figure>

<p>区域设置 vs 语言<br>示例：<br>en：英语语言<br>en_GB：英国的英语 &#x2F; 英式英语<br>en_US：美国的英语 &#x2F; 美式英语<br>en_DE：德国的英语<br>甚至可以变得更加复杂。可以想象一下在欧洲和中国提供不同的内容（例如在 MMO 中）。<br>你需要把每种内容变体都翻译成多种语言，进行相应的存储和加载。</p>
<p>将键转换为文本<br>对于 Button、Label 等部分控件，如果它们的文本与某个翻译键名相匹配，则将自动获取翻译内容。<br>例如，如果标签的文本为“MAIN_SCREEN_GREETING1”，并且该键存在于当前翻译中，则该文本将被自动翻译。<br>这种自动翻译行为在某些情况下可能是不可取的。<br>例如，当使用 Label 来显示玩家的名字时，如果玩家的名字与翻译键相匹配，你很可能不希望进行翻译。<br>要禁用某个节点的自动翻译，请在检查器中禁用Localization &gt; Auto Translate（本地化 &gt; 自动翻译）。<br>在代码中，可以使用 Object.tr() 函数。这将只在翻译中查找文本，并在找到后进行转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">level.text = tr(&quot;LEVEL_5_NAME&quot;)</span><br><span class="line">status.text = tr(&quot;GAME_STATUS_%d&quot; % status_index)</span><br></pre></td></tr></table></figure>

<p>备注<br>如果更改语言后不显示任何文字，请尝试换一个字体。<br>默认项目字体仅支持 Latin-1 字符集的子集，无法用于显示俄语、汉语等文字。<br>Noto Fonts 是一系列不错的多语言字体资源。如果你使用的是不太常见的语言，请确保下载正确的变体。<br>下载字体后，将 TTF 文件加载到 DynamicFont 资源中，并将其用作 Control 节点的自定义字体。<br>为了获得更好的可重用性，请将新的主题资源关联到根 Control 节点，并将 DynamicFont 定义为主题中的默认字体。</p>
<p>占位符<br>若要在翻译的字符串中使用占位符，请使用 GDScript 格式字符串 或 C# 中的等效功能。<br>这使得翻译者可以自由移动字符串中占位符的位置，使得翻译听起来更自然。<br>为了允许翻译人员决定占位符出现的顺序，应尽可能使用搭配使用带命名的占位符和 String.format() 的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 占位符的位置可以更改，但它们的顺序不能改变。</span><br><span class="line"># 这种方式可能无法满足某些目标语言的翻译需求（因为语序受限）。</span><br><span class="line">message.text = tr(&quot;%s picked up the %s&quot;) % [&quot;Ogre&quot;, &quot;Sword&quot;]</span><br><span class="line"></span><br><span class="line"># 占位符的位置和顺序都可以自由调整。</span><br><span class="line"># 此外，这种格式为翻译人员提供了更清晰的上下文，便于准确翻译。</span><br><span class="line">message.text = tr(&quot;&#123;character&#125; picked up the &#123;weapon&#125;&quot;).format(&#123;character = &quot;Ogre&quot;, weapon = &quot;Sword&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>翻译上下文<br>如果你使用普通的英文作为源字符串（而不是类似于 LIKE_THIS 的消息代码），那么就有可能会遇到歧义的情况，同一个英文字符串可能需要在某些目标语言中翻译为不同的字符串。你可以通过指定可选的翻译上下文来消除歧义，即便源字符串是相同的，也能够让目标语言能够使用不同的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># &quot;Close&quot;, as in an action (to close something).</span><br><span class="line">button.set_text(tr(&quot;Close&quot;, &quot;Actions&quot;))</span><br><span class="line"></span><br><span class="line"># &quot;Close&quot;, as in a distance (opposite of &quot;far&quot;).</span><br><span class="line">distance_label.set_text(tr(&quot;Close&quot;, &quot;Distance&quot;))</span><br></pre></td></tr></table></figure>

<p>复数<br>很多语言会根据对象的单复数使用不同的字符串。但是把“是否为复数”的条件硬编码为“对象数量是否大于 1 ”并不是对所有语言都有效。<br>有些语言有两种以上的复数形式，不同的复数需要的对象数量也各不相同。Godot 提供了对复数的支持，目标地区可以自动进行处理。<br>复数应该只用于正整数（或零）的情况。负数和浮点数所代表的物理实体数量是单数还是复数一般无法明确区分。</p>
<p>使控件的大小可调<br>Container 可能很有用，Label 的文本换行选项应该也能帮上忙。<br>要检查您的 UI 是否可以容纳字符串比原始字符串更长的翻译，您可以启用伪本地化 在高级项目设置中。<br>这将替换所有可本地化的字符串 使用更长的版本，同时还替换了 带有重音版本的原始字符串（同时仍然可读）。<br>占位符保持原样，以便在伪本地化时继续工作 已启用。</p>
<p>翻译服务器<br>Godot 中负责底层翻译管理的服务器叫作 TranslationServer。可以在运行时添加或删除翻译；当前语言也可以在运行时更改。</p>
<p>测试翻译<br>在发布前测试项目的翻译。Godot 为此提供了三种方法。<br>首先，在项目设置中的国际化 &gt; 区域设置（启用高级设置）下有一个测试属性。<br>将这个属性设置为你想测试的语言的区域设置代码。<br>Godot 将在项目运行时使用该区域设置运行该项目（无论是从编辑器运行还是导出后运行）。<br>请记住，因为这是一个项目设置，设为非空时它会在版本控制中显示。因此，将修改提交到版本控制之前，应该将其设回空值。<br>其次，在编辑器中点击顶部工具栏的视图，然后在预览翻译中选择要预览的语言。<br>编辑器场景中的所有文本现在都会以所选语言显示。<br>还可以在从命令行运行 Godot 时测试翻译。例如，要使用法语测试游戏，可以提供以下参数：<br><code>godot --language fr</code></p>
<p>翻译项目名称<br>项目名称将在导出到不同的操作系统和平台时成为应用名称。<br>要以多种语言指定项目名称，请转到项目 &gt; 项目设置 &gt; 应用 &gt; 配置。<br>从这里点击可本地化字符串（大小 0）按钮。<br>现在下面应该有一个标有添加翻译按钮。<br>点击该按钮，它将带你到一个页面，可以在其中为项目名称翻译选择语言（如果需要，还可以选择地区）。<br>完成后，你现在可以输入本地化的名称。</p>
<h3 id="使用电子表格进行本地化"><a href="#使用电子表格进行本地化" class="headerlink" title="使用电子表格进行本地化"></a>使用电子表格进行本地化</h3><p>Godot 使用 CSV 格式来支持电子表格。<br>CSV 文件必须使用 UTF-8 编码保存，不带字节序标记。<br>CSV 文件必须使用以下格式：</p>
<table>
<thead>
<tr>
<th align="left">keys</th>
<th align="left"><lang1></th>
<th align="left"><lang2></th>
<th align="left"><langN></th>
</tr>
</thead>
<tbody><tr>
<td align="left">KEY1</td>
<td align="left">字符串</td>
<td align="left">字符串</td>
<td align="left">字符串</td>
</tr>
<tr>
<td align="left">KEY2</td>
<td align="left">字符串</td>
<td align="left">字符串</td>
<td align="left">字符串</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">KEYN</td>
<td align="left">字符串</td>
<td align="left">字符串</td>
<td align="left">字符串</td>
</tr>
</tbody></table>
<p>CSV 导入器<br>Godot 默认会将 CSV 文件作为翻译导入，在同一文件夹中生成一个或多个压缩后的翻译资源文件。<br>导入还会将翻译添加到要在游戏运行时加载的翻译列表中，在 project.godot（或项目设置）中指定。Godot 还允许在运行时加载和删除翻译。<br>选择 .csv 文件并访问导入停靠面板，以定义导入选项。你可以切换是否压缩导入的翻译，并选择在解析 CSV 文件时使用的定界符。</p>
<h3 id="使用-gettext（PO-文件）进行本地化"><a href="#使用-gettext（PO-文件）进行本地化" class="headerlink" title="使用 gettext（PO 文件）进行本地化"></a>使用 gettext（PO 文件）进行本地化</h3><p>Godot 还支持加载使用 GNU gettext 格式的翻译文件（基于文本的 .po 文件，Godot 4.0 开始还支持编译后的 .mo 文件）。</p>
<mark class="hl-label red">暂不考虑</mark>


<h3 id="区域设置代码"><a href="#区域设置代码" class="headerlink" title="区域设置代码"></a>区域设置代码</h3><p>区域设置代码的格式为 language_Script_COUNTRY_VARIANT，其中：<br>language - 2 到 3 个字母的语言代码，小写。<br>Script - 可选，4 个字母的文字代码，首字母大写。<br>COUNTRY - 可选，2 个字母的地区代码，大写。<br>VARIANT - 可选，语言变体、区域、排序等。变体中可以包含任意数量使用下划线的关键词。</p>
<h3 id="伪本地化"><a href="#伪本地化" class="headerlink" title="伪本地化"></a>伪本地化</h3><p>启用伪本地化及其相关配置非常简单，只需在项目设置中勾选勾选框即可。<br>在项目设置对话框中启用高级设置切换后，可以在项目 → 项目设置 → 常规 → 国际化 → 伪本地化中找到这些设置：</p>
<p>伪本地化配置<br>Godot 中的伪本地化可以根据项目的具体用例进行设置。以下是可以通过项目设置配置的伪本地化属性：</p>
<ul>
<li>replace_with_accents：将字符串中的所有字符替换为对应的重音变体。<br>  启用该设置后，”The quick brown fox jumped over the lazy dog” 会被转换为 “Ŧh̀é q́üíćḱ ḅŕôŵή f́ôx́ ǰüm̀ṕéd́ ôṽéŕ ŧh̀é łáźý d́ôǵ”。<br>  可以用来发现没有重音的未翻译字符串，也适用于检查项目使用的字体是否缺失字形。</li>
<li>double_vowels：将字符串中的所有元音加倍。这是在本地化过程中模拟文本扩充的一个很好的近似方法。这可用于检查会溢出其容器的文本（例如按钮）。</li>
<li>fake_bidi：假双向文字（模拟从右到左的文字）。这对于模拟从右到左的书写系统非常有用，以检查使用从右到左脚本的语言中可能出现的潜在布局问题。</li>
<li>override：用星号（*）替换字符串中的所有字符。这对于快速查找未本地化的文本很有用。</li>
<li>expansion_ratio：可用于将元音加倍不足以近似的情况。该设置用下划线（_）填充字符串，并按给定比率扩展它。<br>  对于大多数实际情况来说，扩展比率为 0.3 就足够了；它将使字符串的长度增加 30%。</li>
<li>prefix 和 suffix：这些属性可用于指定包装文本的前缀和后缀。</li>
<li>skip_placeholders：跳过字符串格式化的占位符，如 %s 和 %f。这对于识别需要更多参数才能正确显示格式化字符串的位置很有用。<br>所有这些属性都可以根据项目的用例按需进行切换。</li>
</ul>
<p>伪本地化可以在运行时使用 <code>pseudolocalization_enabled</code> 属性在 TranslationServer 中。<br>但是，如果需要伪本地化属性的运行时配置， 它们可以直接使用 ProjectSettings.set_setting（属性，值）<br>然后调用 TranslationServer.reload_pseudolocalization（） 它会重新解析伪本地化属性并重新加载伪本地化。<br>以下代码片段应打开 replace_with_accents 和 double_vowels 属性，然后调用 reload_pseudolocalization（） 以反映更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProjectSettings.set_setting(&quot;internationalization/pseudolocalization/replace_with_accents&quot;, true)</span><br><span class="line">ProjectSettings.set_setting(&quot;internationalization/pseudolocalization/double_vowels&quot;, true)</span><br><span class="line">TranslationServer.reload_pseudolocalization()</span><br></pre></td></tr></table></figure>


<h2 id="输入处理"><a href="#输入处理" class="headerlink" title="输入处理"></a>输入处理</h2><h3 id="使用-InputEvent"><a href="#使用-InputEvent" class="headerlink" title="使用 InputEvent"></a>使用 InputEvent</h3><p>按下 ESC 键时关闭你的游戏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func _unhandled_input(event):</span><br><span class="line">	if event is InputEventKey:</span><br><span class="line">		if event.pressed and event.keycode == KEY_ESCAPE:</span><br><span class="line">			get_tree().quit()</span><br></pre></td></tr></table></figure>
<p>使用 InputMap 功能将更简洁灵活。<br>你可以在项目 &gt; 项目设置 &gt; 按键映射下设置你的输入映射，这些动作的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func _process(delta):</span><br><span class="line">	if Input.is_action_pressed(&quot;ui_right&quot;):</span><br></pre></td></tr></table></figure>

<p>InputEvent 只是一个基本的内置类型，它不代表任何东西，只包含一些基本信息，例如事件 ID（每个事件都会增加）、设备索引等。</p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">InputEvent</td>
<td align="left">空输入事件。</td>
</tr>
<tr>
<td align="left">InputEventKey</td>
<td align="left">包含键码和 Unicode 值以及修饰键。</td>
</tr>
<tr>
<td align="left">InputEventMouseButton</td>
<td align="left">包含点击信息，例如按钮、修饰键等。</td>
</tr>
<tr>
<td align="left">InputEventMouseMotion</td>
<td align="left">包含运动信息，例如相对位置、绝对位置和速度。</td>
</tr>
<tr>
<td align="left">InputEventJoypadMotion</td>
<td align="left">包含操纵杆&#x2F;操纵手柄模拟轴信息。</td>
</tr>
<tr>
<td align="left">InputEventJoypadButton</td>
<td align="left">包含操纵杆&#x2F;操纵手柄按钮信息。</td>
</tr>
<tr>
<td align="left">InputEventScreenTouch</td>
<td align="left">包含多点触控按下&#x2F;释放信息。（仅适用于移动设备）</td>
</tr>
<tr>
<td align="left">InputEventScreenDrag</td>
<td align="left">包含多点触控拖动信息。（仅适用于移动设备）</td>
</tr>
<tr>
<td align="left">InputEventMagnifyGesture</td>
<td align="left">包含位置、系数以及修饰键。</td>
</tr>
<tr>
<td align="left">InputEventPanGesture</td>
<td align="left">包含位置、增量以及修饰键。</td>
</tr>
<tr>
<td align="left">InputEventMIDI</td>
<td align="left">包含 MIDI 相关的信息。</td>
</tr>
<tr>
<td align="left">InputEventShortcut</td>
<td align="left">包含快捷键。</td>
</tr>
<tr>
<td align="left">InputEventAction</td>
<td align="left">包含通用动作。这些事件通常由程序员生成作为反馈。（更多信息见下文）</td>
</tr>
</tbody></table>
<p>输入动作<br>输入动作是对若干 InputEvent 的分组，为每一组事件赋予能够普遍理解标题（例如默认的“ui_left”动作将手柄向左的输入和键盘上的左方向键分到了一组）。<br>使用输入动作来代表 InputEvent 不是必须的，但之所以有用，是因为输入动作对游戏逻辑编程时的各种输入进行了抽象。<br>这样就可以：</p>
<ul>
<li>用相同的代码在不同的设备上处理不同的输入（例如，PC 上的键盘、主机上的游戏手柄）。</li>
<li>在运行时重新配置输入。</li>
<li>在运行时以编程的方式触发动作。</li>
<li>动作可以从“项目设置”菜单中的输入映射选项卡创建并分配输入事件。<br>任何事件都有 <code>InputEvent.is_action（）</code> 的方法， <code>InputEvent.is_pressed（）</code> 和 <code>InputEvent.is_echo（）</code>。<br>或者，可能需要从游戏代码中向游戏提供一个动作（一个很好的例子是检测手势）。Input 单例有一个方法 <code>Input.parse_input_event()</code> 来用于此。<br>通常会像这样使用它：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ev = InputEventAction.new()</span><br><span class="line"># Set as ui_left, pressed.</span><br><span class="line">ev.action = &quot;ui_left&quot;</span><br><span class="line">ev.pressed = true</span><br><span class="line"># Feedback.</span><br><span class="line">Input.parse_input_event(ev)</span><br></pre></td></tr></table></figure>

<p>InputMap<br>通常需要从代码中自定义输入和重新映射输入。<br>如果你的整个工作流程都依赖于动作，则 InputMap 单例非常适合在运行时重新分配或创建不同的动作。<br>该单例不会被保存（必须手动修改），其状态从项目设置（project.godot）运行。<br>因此，任何该类型的动态系统都需要以程序员认为最合适的方式来存储设置。</p>
<h3 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h3><p>输入事件<br>输入事件是从 InputEvent 继承的对象。<br>根据事件类型，对象将包含与该事件相关的特定属性。<br>要查看事件的实际样子，请添加一个节点并附加以下脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extends Node</span><br><span class="line">func _input(event):</span><br><span class="line">	print(event.as_text())</span><br></pre></td></tr></table></figure>
<p>按键事件会打印为其按键符号。以 InputEventMouseButton 为例，它继承自以下类：</p>
<ul>
<li>InputEvent——所有输入事件的基类</li>
<li>InputEventWithModifiers——增加了检查是否按下 Shift 或 Alt 等修饰键的功能。</li>
<li>InputEventMouse——增加了如 position 等鼠标事件属性</li>
<li>InputEventMouseButton——包含按下的按钮的索引、是否是双击等。<br>如果你尝试访问不包含该属性的输入类型上的属性，则可能会遇到错误——例如在 InputEventKey 上调用 position。<br>为避免这种情况，请务必先测试事件类型：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func _input(event):</span><br><span class="line">	if event is InputEventMouseButton:</span><br><span class="line">		print(&quot;mouse button event at &quot;, event.position)</span><br></pre></td></tr></table></figure>

<p>捕捉动作<br>定义好动作后，你可以通过传递你要查找的动作的名称，使用 is_action_pressed() 和 is_action_released() 在脚本中处理它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func _input(event):</span><br><span class="line">	if event.is_action_pressed(&quot;my_action&quot;):</span><br><span class="line">		print(&quot;my_action occurred!&quot;)</span><br></pre></td></tr></table></figure>

<p>键盘事件<br>键盘事件在 InputEventKey 中被捕获。虽然建议改用输入动作，但在某些情况下，你可能会想专门查看按键事件。对于该示例，让我们检查 T：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func _input(event):</span><br><span class="line">	if event is InputEventKey and event.pressed:</span><br><span class="line">		if event.keycode == KEY_T:</span><br><span class="line">			print(&quot;T was pressed&quot;)</span><br></pre></td></tr></table></figure>

<p>键盘修饰键<br>修饰键属性继承自 InputEventWithModifiers ，可使用布尔属性检查修饰键的组合。<br>试想，如果需要在按下 T 时发生一件事，而按下 Shift + T 时发生不同的事：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func _input(event):</span><br><span class="line">	if event is InputEventKey and event.pressed:</span><br><span class="line">		if event.keycode == KEY_T:</span><br><span class="line">			if event.shift_pressed:</span><br><span class="line">				print(&quot;Shift+T was pressed&quot;)</span><br><span class="line">			else:</span><br><span class="line">				print(&quot;T was pressed&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请参阅 @GlobalScope_Key 以获取键码常量列表。</p>
</blockquote>
<p>鼠标事件<br>鼠标事件继承自 InputEventMouse 并被分成 InputEventMouseButton 和 InputEventMouseMotion 两种类型。<br>注意，这意味着所有鼠标事件都包含 position 属性。</p>
<p>鼠标按钮<br>捕获鼠标按钮与处理按键事件非常相似。<br>@GlobalScope_MouseButton 包含每个可能按钮的 MOUSE_BUTTON_* 常量列表，这些常量将在事件的 button_index 属性中报告。<br>请注意，滚轮也算作一个按钮——准确地说是两个按钮，MOUSE_BUTTON_WHEEL_UP 和 MOUSE_BUTTON_WHEEL_DOWN 都是单独的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func _input(event):</span><br><span class="line">	if event is InputEventMouseButton:</span><br><span class="line">		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:</span><br><span class="line">			print(&quot;Left button was clicked at &quot;, event.position)</span><br><span class="line">		if event.button_index == MOUSE_BUTTON_WHEEL_UP and event.pressed:</span><br><span class="line">			print(&quot;Wheel up&quot;)</span><br></pre></td></tr></table></figure>

<p>鼠标运动<br><code>InputEventMouseMotion</code> 事件在鼠标移动时发生。可以使用 relative 属性找到移动的距离。<br>下面是一个使用鼠标事件拖放 Sprite2D 节点的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">extends Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var dragging = false</span><br><span class="line">var click_radius = 32 # Size of the sprite.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _input(event):</span><br><span class="line">	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:</span><br><span class="line">		if (event.position - $Sprite2D.position).length() &lt; click_radius:</span><br><span class="line">			# Start dragging if the click is on the sprite.</span><br><span class="line">			if not dragging and event.pressed:</span><br><span class="line">				dragging = true</span><br><span class="line">		# Stop dragging if the button is released.</span><br><span class="line">		if dragging and not event.pressed:</span><br><span class="line">			dragging = false</span><br><span class="line"></span><br><span class="line">	if event is InputEventMouseMotion and dragging:</span><br><span class="line">		# While dragging, move the sprite with the mouse.</span><br><span class="line">		$Sprite2D.position = event.position</span><br></pre></td></tr></table></figure>

<p>触摸事件<br>如果你使用的是触摸屏设备，就可以生成触摸事件。<br>InputEventScreenTouch 相当于鼠标点击事件，而 InputEventScreenDrag 的工作原理与鼠标移动一致。</p>
<h3 id="鼠标和输入坐标"><a href="#鼠标和输入坐标" class="headerlink" title="鼠标和输入坐标"></a>鼠标和输入坐标</h3><p>视口显示坐标、<br>Godot 使用视口（Viewport）显示内容，并且视口可以通过若干选项进行缩放（参见《多分辨率》教程）。<br>然后，使用节点中的函数来获得鼠标坐标和视口大小，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func _input(event):</span><br><span class="line">	# Mouse in viewport coordinates.</span><br><span class="line">	if event is InputEventMouseButton:</span><br><span class="line">		print(&quot;Mouse Click/Unclick at: &quot;, event.position)</span><br><span class="line">	elif event is InputEventMouseMotion:</span><br><span class="line">		print(&quot;Mouse Motion at: &quot;, event.position)</span><br><span class="line"></span><br><span class="line">	# Print the size of the viewport.</span><br><span class="line">	print(&quot;Viewport Resolution is: &quot;, get_viewport().get_visible_rect().size)</span><br></pre></td></tr></table></figure>
<p>另外，也可以从视口查询鼠标的位置：<code>get_viewport().get_mouse_position()</code></p>
<p>备注<br>鼠标模式为 Input.MOUSE_MODE_CAPTURED 时，InputEventMouseMotion 中的 event.position 值为屏幕中心。<br>请使用 event.relative 代替 event.position 和 event.velocity 来处理鼠标移动和位置变化。</p>
<h3 id="自定义鼠标光标"><a href="#自定义鼠标光标" class="headerlink" title="自定义鼠标光标"></a>自定义鼠标光标</h3><ol>
<li><p>使用项目设置。这种方式更简单，但功能也更有限。<br>打开项目设置并进入显示 &gt; 鼠标光标。你将看到以下设置：自定义图像、自定义热点图像 和工具提示位置偏移。<br>自定义图像热区是图像中要用作光标检测点的点。<br>自定义图像最多必须为 256×256 像素。为避免呈现问题，建议使用 128×128 或更小的大小。<br>在 web 平台上，允许的最大光标图像大小为 128×128。</p>
</li>
<li><p>使用脚本。这种方式更加可定制化，但需要编写脚本。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extends Node</span><br><span class="line"></span><br><span class="line"># Load the custom images for the mouse cursor.</span><br><span class="line">var arrow = load(&quot;res://arrow.png&quot;)</span><br><span class="line">var beam = load(&quot;res://beam.png&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	# Changes only the arrow shape of the cursor.</span><br><span class="line">	# This is similar to changing it in the project settings.</span><br><span class="line">	Input.set_custom_mouse_cursor(arrow)</span><br><span class="line"></span><br><span class="line">	# Changes a specific shape of the cursor (here, the I-beam shape).</span><br><span class="line">	Input.set_custom_mouse_cursor(beam, Input.CURSOR_IBEAM)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>检查 Input.set_custom_mouse_cursor() 的文档，以获取有关使用和平台特定注意事项的更多信息。</p>
</blockquote>
<p>光标列表<br>你可定义多种鼠标光标，详见 Input.CursorShape 枚举类型。具体选择取决于你的使用场景。</p>
<h3 id="控制器、手柄和摇杆"><a href="#控制器、手柄和摇杆" class="headerlink" title="控制器、手柄和摇杆"></a>控制器、手柄和摇杆</h3><p>Godot 支持数百种开箱即用的控制器模型。<br>Windows、macOS、Linux、Android、iOS 和 Web 支持控制器。<br>从 Godot 4.5 开始，引擎依赖于 SDL 3 在 Windows、macOS 和 Linux 上支持控制器。<br>这意味着 支持的控制器及其行为应与可用的控制器紧密匹配 在使用 SDL 3 的其他游戏和引擎中。请注意，SDL 仅用于输入，不是为了开窗或声音。</p>
<p>当你有两个轴（例如摇杆或 WASD 运动）并且希望两个轴都作为单个输入时，请使用 Input.get_vector()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># `velocity` 将是一个介于 `Vector2(-1.0, -1.0)` 和 `Vector2(1.0, 1.0)` 之间的 Vector2。</span><br><span class="line"># 这种方式在大多数使用场景下能**正确处理摇杆或按键输入的死区（deadzone）**。</span><br><span class="line"># 生成的死区区域是**圆形的**，这是更符合物理直觉和操作体验的理想形状。</span><br><span class="line">var velocity = Input.get_vector(&quot;move_left&quot;, &quot;move_right&quot;, &quot;move_forward&quot;, &quot;move_back&quot;)</span><br><span class="line"></span><br><span class="line"># 下面这行代码的效果与 `get_vector()` 类似，但处理死区的方式**不够理想**。</span><br><span class="line"># 它生成的死区区域是**接近方形的**，而理想情况下应为圆形，可能导致对角线方向响应不均。</span><br><span class="line">var velocity = Vector2(</span><br><span class="line">    Input.get_action_strength(&quot;move_right&quot;) - Input.get_action_strength(&quot;move_left&quot;),</span><br><span class="line">    Input.get_action_strength(&quot;move_back&quot;) - Input.get_action_strength(&quot;move_forward&quot;)</span><br><span class="line">).limit_length(1.0)</span><br></pre></td></tr></table></figure>

<p>当你有一个轴可以双向移动时（比如飞行摇杆上的油门），或者你想单独处理不同的轴时，使用 Input.get_axis() :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># `walk` 将是一个介于 -1.0 和 1.0 之间的浮点数，表示左右移动的轴向输入。</span><br><span class="line"># 正值表示向右，负值表示向左。</span><br><span class="line">var walk = Input.get_axis(&quot;move_left&quot;, &quot;move_right&quot;)</span><br><span class="line"></span><br><span class="line"># 上面这行代码是以下写法的简写形式：</span><br><span class="line">var walk = Input.get_action_strength(&quot;move_right&quot;) - Input.get_action_strength(&quot;move_left&quot;)</span><br></pre></td></tr></table></figure>
<p>对于其他类型的模拟输入，例如处理一个触发器或一次处理一个方向，使用 Input.get_action_strength()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># `strength` will be a floating-point number between `0.0` and `1.0`.</span><br><span class="line">var strength = Input.get_action_strength(&quot;accelerate&quot;)</span><br></pre></td></tr></table></figure>
<p>对于非模拟数字&#x2F;布尔输入（只有 “按下 “ 或 “未按下 “ 的值），如控制器按钮、鼠标按钮或键盘按键，使用 Input.is_action_pressed()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># `jumping` will be a boolean with a value of `true` or `false`.</span><br><span class="line">var jumping = Input.is_action_pressed(&quot;jump&quot;)</span><br></pre></td></tr></table></figure>
<p>备注<br>如果你想要知道上一帧是否刚刚按下了某个输入，请使用 Input.is_action_just_pressed()，不要使用 Input.is_action_pressed()。<br>Input.is_action_pressed() 是只要输入处于按下的状态就会返回 true，而 Input.is_action_just_pressed() 只会在按下按钮后的一帧内返回 true。</p>
<p>振动<br>使用 Input 单例的 <code>start_joy_vibration</code> 方法开启游戏手柄的振动。<br>要提前结束振动，请使用 <code>stop_joy_vibration</code>（尤其适用于启动时未指定时长的情况）。<br>在移动设备上，你还可以使用 <code>vibrate_handheld</code> 来振动设备本身（与游戏手柄的振动是分开的）,这个功能需要在导出项目前启用 Android 导出预设中的 VIBRATE 权限。</p>
<p>键盘&#x2F;鼠标和控制器输入之间的差异</p>
<ol>
<li>死区<br>由于控制器的物理结构，模拟轴的强度永远不会等于 0.0 会徘徊在一个低值。<br>这种现象被称为漂移，在旧的或有问题的控制器上会更加明显。<br>一个理想的死区值是足够高的，可以忽略操纵杆漂移引起的输入，但又足够低，不会忽略玩家的实际输入。<br>Godot 提供了内置的死区系统来解决这个问题。默认值是 0.5，但你可以在“项目设置”的“输入映射”选项卡中针对具体的动作进行调整。<br><code>Input.get_vector()</code>可以在第五个参数中指定死区。如果没有指定，则会计算向量中的所有动作死区的平均值。</li>
<li>“回显”事件<br>与键盘输入不同，按住一个控制器按钮，如十字方向键，不会产生固定间隔的重复输入事件（也被称为“回显”事件）。<br>这是因为操作系统首先不会为控制器输入发送“回显”事件。<br>如果你想让控制器按钮发送回显事件，你将不得不通过代码生成 InputEvent 对象，并使用 Input.parse_input_event() 定期解析它们。<br>这可以在 Timer 节点的帮助下完成。</li>
<li>窗口焦点<br>与键盘输入不同，控制器的输入可以被操作系统中的所有窗口看到，包括未持有焦点的窗口。<br>虽然这对于第三方分屏功能很有用，但也可能产生不利影响。玩家在与另一个窗口互动时可能会意外地将控制器输入传送到正在执行的项目。<br>如果你希望在项目窗口未聚焦时忽略事件，则需要使用以下脚本创建一个名为 Focus 的自动加载，并使用它来检查所有输入：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Focus.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">var focused := true</span><br><span class="line"></span><br><span class="line">func _notification(what: int) -&gt; void:</span><br><span class="line">	match what:</span><br><span class="line">		NOTIFICATION_APPLICATION_FOCUS_OUT:</span><br><span class="line">			focused = false</span><br><span class="line">		NOTIFICATION_APPLICATION_FOCUS_IN:</span><br><span class="line">			focused = true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func input_is_action_pressed(action: StringName) -&gt; bool:</span><br><span class="line">	if focused:</span><br><span class="line">		return Input.is_action_pressed(action)</span><br><span class="line"></span><br><span class="line">	return false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func event_is_action_pressed(event: InputEvent, action: StringName) -&gt; bool:</span><br><span class="line">	if focused:</span><br><span class="line">		return event.is_action_pressed(action)</span><br><span class="line"></span><br><span class="line">	return false</span><br></pre></td></tr></table></figure>
<p>然后，不要使用 Input.is_action_pressed(action)，而是使用 Focus.input_is_action_pressed(action)，其中 action 是输入动作的名称。<br>另外，不要使用 event.is_action_pressed(action)，而是使用 Focus.event_is_action_pressed(event, action)，其中 event 是 InputEvent 引用，action 是输入动作的名称。<br>4. 防止省电模式<br>与键盘和鼠标输入不同，控制器输入不会抑制睡眠和省电措施（例如在经过一定时间后关闭屏幕）。<br>为了解决这个问题，Godot 在项目运行时默认启用预防省电。<br>如果你注意到在使用游戏手柄玩游戏时系统正在关闭其显示屏，请检查项目设置中的显示 &gt; 窗口 &gt; 节能 &gt; 保持屏幕开启的值。<br>在 Linux 上，要防止省电，引擎必须能够使用 D-Bus。如果在 Flatpak 中运行项目，请检查 D-Bus 是否已安装且可以访问，因为沙盒限制默认可能会导致无法实现这一点。</p>
<h3 id="处理退出请求"><a href="#处理退出请求" class="headerlink" title="处理退出请求"></a>处理退出请求</h3><p>处理通知<br>在桌面及 Web 平台上, Node 会在窗口管理器发出退出请求时接受到 MainLoop.NOTIFICATION_WM_QUIT_REQUEST 通知.<br>处理通知的方法如下(在任何节点上):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func _notification(what):</span><br><span class="line">	if what == NOTIFICATION_WM_CLOSE_REQUEST:</span><br><span class="line">		get_tree().quit() # default behavior</span><br></pre></td></tr></table></figure>
<p>值得注意的是，默认情况下，当窗口管理器请求退出时，Godot 应用程序具有退出的内置行为。这可以更改，以便用户可以处理完整的退出过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_tree().set_auto_accept_quit(false)</span><br></pre></td></tr></table></figure>

<p>移动设备<br>移动平台上并没有与 NOTIFICATION_WM_CLOSE_REQUEST 等价的东西。<br>由于移动操作系统的特性，退出前运行代码的时机只能是在应用被挂起到后台时。<br>Android 和 iOS 平台上，处于挂起状态的应用随时都可能被用户或操作系统杀死。<br>为了应对这种可能性，一种提前计划的方法是利用 NOTIFICATION_APPLICATION_PAUSED 在应用程序暂停时执行需要的操作。<br>在 Android 上，如果出现以下情况，按“返回”按钮将退出应用程序 应用程序 &gt; 配置 &gt; 退出时返回（退出时返回） 在项目设置（默认设置）中被选中。<br>这将触发 NOTIFICATION_WM_GO_BACK_REQUEST 。</p>
<p>发送你自己的退出通知<br>强制关闭应用程序可以通过调用 SceneTree.quit，这样做不会将 NOTIFICATION_WM_CLOSE_REQUEST 发送到场景树中的节点。<br>通过调用 SceneTree.quit 退出将不允许完成自定义作（例如保存、确认退出或调试），即使您尝试延迟强制退出的行也是如此。<br>作为替代，如果你想通知节点以及场景树应用程序即将终止，你应当自己发送对应的通知：<br><code>get_tree().root.propagate_notification(NOTIFICATION_WM_CLOSE_REQUEST)</code><br>如此做将会通知所有的节点应用程序即将终止，但是不会关闭应用程序本身 （与3.X版本不同） 。<br>如果需要达到之前的效果，则应当在发送通知后调用 SceneTree.quit 。</p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="向量数学"><a href="#向量数学" class="headerlink" title="向量数学"></a>向量数学</h3><p>实际应用</p>
<ol>
<li>移动<br> pos2 &#x3D; pos1 + vel</li>
<li>指向目标<br> 要找到从 A 指向 B 的向量，请使用 B-A</li>
</ol>
<p>归一化<br>对向量进行归一化就是将其长度缩减到 1 方向不变。<br>提供了专门的 normalized() 方法：<code>a = a.normalized()</code></p>
<p>反射<br>有一个 bounce() 方法来处理这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var collision: KinematicCollision2D = move_and_collide(velocity * delta)</span><br><span class="line">if collision:</span><br><span class="line">	var reflect = collision.get_remainder().bounce(collision.get_normal())</span><br><span class="line">	velocity = velocity.bounce(collision.get_normal())</span><br><span class="line">	move_and_collide(reflect)</span><br></pre></td></tr></table></figure>

<p>点积<br>内置的 dot() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var c = a.dot(b)</span><br><span class="line">var d = b.dot(a)  # 等效</span><br></pre></td></tr></table></figure>

<p>叉积<br>使用内置方法 Vector3.cross() 完成叉积计算：<br>var c &#x3D; a.cross(b)</p>
<p>法线计算<br>计算三角形法线的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func get_triangle_normal(a, b, c):</span><br><span class="line">	# Find the surface normal given 3 vertices.</span><br><span class="line">	var side1 = b - a</span><br><span class="line">	var side2 = c - a</span><br><span class="line">	var normal = side1.cross(side2)</span><br><span class="line">	return normal</span><br></pre></td></tr></table></figure>

<p>指向目标<br>在上面的点积部分，我们看到如何用它来查找两个向量之间的角度。<br>然而在 3D 中，这些信息还不够。我们还需要知道在围绕什么轴旋转。<br>我们可以通过计算当前面对的方向和目标方向的叉积来查找。由此得到的垂直向量就是旋转轴。</p>
<h3 id="高等向量数学"><a href="#高等向量数学" class="headerlink" title="高等向量数学"></a>高等向量数学</h3><p>平面<br>到平面的距离<br>现在平面是什么就很清楚了，让我们再回到点积上。<br>单位向量和任何空间点之间的点积（是的，这次我们在向量和位置之间进行点乘），将返回从该点到平面的距离：<br><code>var distance = normal.dot(point)</code><br>但返回的不止是距离的绝对值，如果点位于负半空间，那么这个距离也是负的：这样我们就能够知道点位于平面的哪一侧。</p>
<p>脱离原点<br>将完整的平面描述为法线 N 和与原点的距离标量 D。这样用 N 和 D 就可以表示我们的平面了。例如：<br>对于 3D 空间中的平面，Godot 提供了 Plane 内置类型来处理这些计算。<br>基本上，N 和 D 可以表示空间中的任何平面，无论是 2D 还是 3D（取决于 N 的维数），两者的数学运算相同。它与之前相同，但 D 是从原点到平面的距离，沿 N 方向行进。例如，假设你想要到达平面上的某个点，只需执行以下操作：<br><code>var point_in_plane = N*D</code><br>这将拉伸（调整大小）法线向量并使其接触平面。<br>这个数学运算可能看起来很混乱，但实际上比看起来要简单得多。<br>如果我们想再次知道从点到平面的距离，可以以相同方法，但要调整距离：<br><code>var distance = N.dot(point) - D</code><br>也可以用内置函数执行同样的计算：<br><code>var distance = plane.distance_to(point)</code><br>这同样会返回一个正或负的距离。<br>还可以通过同时对 N 和 D 取负来反转平面的极性。这样，平面的位置不变，但正负半空间倒置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">N = -N</span><br><span class="line">D = -D</span><br></pre></td></tr></table></figure>
<p>Godot 还在 Plane 中实现了该运算。因此，使用以下格式将按预期工作：<br><code>var inverted_plane = -plane</code><br>平面的主要实际用途是我们可以计算到平面的距离。</p>
<p>在 2D 中构造平面<br>平面不会凭空出现，必须先进行构造。<br>在 2D 空间中构造平面很简单：只需要法线（单位向量）和某一个点，或者空间中任意两点都可以完成。<br>在法线和点的情况下，由于法线已经被计算出来，大部分计算工作都已完成。因此，只需根据法线和点的点积计算 D 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var N = normal</span><br><span class="line">var D = normal.dot(point)</span><br></pre></td></tr></table></figure>
<p>对于空间中的两个点，实际上有两个平面穿过它们，共享相同的空间，但正常指向相反的方向。<br>要从两点计算法线，必须先获得方向矢量，然后需要将其向两侧旋转 90 度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 计算从点 a 指向点 b 的方向向量</span><br><span class="line">var dvec = point_a.direction_to(point_b)</span><br><span class="line"></span><br><span class="line"># 将该方向向量顺时针旋转 90 度，得到法向量（垂直于原向量）</span><br><span class="line">var normal = Vector2(dvec.y, -dvec.x)</span><br><span class="line"></span><br><span class="line"># 或者，根据所需法向量的方向不同，也可以逆时针旋转 90 度：</span><br><span class="line"># var normal = Vector2(-dvec.y, dvec.x)</span><br></pre></td></tr></table></figure>
<p>剩余步骤与前例相同。point_a 和 point_b 都可以用于计算，毕竟两者位于同一个平面内：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var N = normal</span><br><span class="line">var D = normal.dot(point_a)</span><br><span class="line"># this works the same</span><br><span class="line"># var D = normal.dot(point_b)</span><br></pre></td></tr></table></figure>

<p>平面的一些示例<br>以下是平面的用途示例。假设有一个凸多边形。比如矩形、梯形、三角形或任何没有面向内弯曲的多边形。<br>对于多边形的每段，我们计算经过该段的平面。一旦我们有了平面列表，我们就可以做一些有趣的事情，例如检查某个点是否在多边形内。<br>我们遍历所有平面，如果我们能找到一个到该点的距离为正的平面，那么该点就在多边形外部。如果我们找不到，那么该点就在多边形内部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var inside = true</span><br><span class="line">for p in planes:</span><br><span class="line">	# check if distance to plane is positive</span><br><span class="line">	if (p.distance_to(point) &gt; 0):</span><br><span class="line">		inside = false</span><br><span class="line">		break # with one that fails, it&#x27;s enough</span><br></pre></td></tr></table></figure>
<p>很酷吧？但还会更好！再多花点功夫，类似的逻辑也会让我们知道两个凸多边形何时重叠。这被称为分离轴定理（或 SAT），大多数物理引擎都使用它来检测碰撞。<br>对于一个点，只要检查是否有一个平面返回正距离，就足以判断该点是否在外部。<br>对于另一个多边形，我们必须找到一个平面，使另一个多边形的所有点到它的距离都返回为正。<br>先使用 A 的平面对 B 的点进行检查，然后使用 B 的平面对 A 的点进行检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var overlapping = true</span><br><span class="line"></span><br><span class="line">for p in planes_of_A:</span><br><span class="line">	var all_out = true</span><br><span class="line">	for v in points_of_B:</span><br><span class="line">		if (p.distance_to(v) &lt; 0):</span><br><span class="line">			all_out = false</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">	if (all_out):</span><br><span class="line">		# a separating plane was found</span><br><span class="line">		# do not continue testing</span><br><span class="line">		overlapping = false</span><br><span class="line">		break</span><br><span class="line"></span><br><span class="line">if (overlapping):</span><br><span class="line">	# only do this check if no separating plane</span><br><span class="line">	# was found in planes of A</span><br><span class="line">	for p in planes_of_B:</span><br><span class="line">		var all_out = true</span><br><span class="line">		for v in points_of_A:</span><br><span class="line">			if (p.distance_to(v) &lt; 0):</span><br><span class="line">				all_out = false</span><br><span class="line">				break</span><br><span class="line"></span><br><span class="line">		if (all_out):</span><br><span class="line">			overlapping = false</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">if (overlapping):</span><br><span class="line">	print(&quot;Polygons Collided!&quot;)</span><br></pre></td></tr></table></figure>

<p>3D 碰撞检测<br>这是另一个奖励，是对耐心坚持看完这篇长篇教程的奖励。这是另一条智慧。这可能不是直接使用案例（Godot 已经很好地完成了碰撞检测），但几乎所有物理引擎和碰撞检测库都在使用它 :)<br>还记得将 2D 凸形转换为 2D 平面数组对于碰撞检测很有用吗？你可以检测某个点是否位于任何凸形内，或者两个 2D 凸形是否重叠。<br>嗯，这在 3D 中也适用，如果两个 3D 多面体发生碰撞，你将无法找到分离平面。如果找到了分离平面，则这两个形状肯定没有发生碰撞。<br>稍微回顾一下，分离平面意味着多边形 A 的所有顶点都在平面的一侧，而多边形 B 的所有顶点都在另一侧。该平面总是多边形 A 或多边形 B 的面平面之一。<br>不过，在 3D 中，这种方法存在问题，因为在某些情况下可能找不到分离平面。以下是这种情况的一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">var overlapping = true</span><br><span class="line"></span><br><span class="line">for p in planes_of_A:</span><br><span class="line">	var all_out = true</span><br><span class="line">	for v in points_of_B:</span><br><span class="line">		if (p.distance_to(v) &lt; 0):</span><br><span class="line">			all_out = false</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">	if (all_out):</span><br><span class="line">		# a separating plane was found</span><br><span class="line">		# do not continue testing</span><br><span class="line">		overlapping = false</span><br><span class="line">		break</span><br><span class="line"></span><br><span class="line">if (overlapping):</span><br><span class="line">	# only do this check if no separating plane</span><br><span class="line">	# was found in planes of A</span><br><span class="line">	for p in planes_of_B:</span><br><span class="line">		var all_out = true</span><br><span class="line">		for v in points_of_A:</span><br><span class="line">			if (p.distance_to(v) &lt; 0):</span><br><span class="line">				all_out = false</span><br><span class="line">				break</span><br><span class="line"></span><br><span class="line">		if (all_out):</span><br><span class="line">			overlapping = false</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">if (overlapping):</span><br><span class="line">	for ea in edges_of_A:</span><br><span class="line">		for eb in edges_of_B:</span><br><span class="line">			var n = ea.cross(eb)</span><br><span class="line">			if (n.length() == 0):</span><br><span class="line">				continue</span><br><span class="line"></span><br><span class="line">			var max_A = -1e20 # tiny number</span><br><span class="line">			var min_A = 1e20 # huge number</span><br><span class="line"></span><br><span class="line">			# we are using the dot product directly</span><br><span class="line">			# so we can map a maximum and minimum range</span><br><span class="line">			# for each polygon, then check if they</span><br><span class="line">			# overlap.</span><br><span class="line"></span><br><span class="line">			for v in points_of_A:</span><br><span class="line">				var d = n.dot(v)</span><br><span class="line">				max_A = max(max_A, d)</span><br><span class="line">				min_A = min(min_A, d)</span><br><span class="line"></span><br><span class="line">			var max_B = -1e20 # tiny number</span><br><span class="line">			var min_B = 1e20 # huge number</span><br><span class="line"></span><br><span class="line">			for v in points_of_B:</span><br><span class="line">				var d = n.dot(v)</span><br><span class="line">				max_B = max(max_B, d)</span><br><span class="line">				min_B = min(min_B, d)</span><br><span class="line"></span><br><span class="line">			if (min_A &gt; max_B or min_B &gt; max_A):</span><br><span class="line">				# not overlapping!</span><br><span class="line">				overlapping = false</span><br><span class="line">				break</span><br><span class="line"></span><br><span class="line">		if (not overlapping):</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">if (overlapping):</span><br><span class="line">   print(&quot;Polygons collided!&quot;)</span><br></pre></td></tr></table></figure>


<h3 id="矩阵与变换"><a href="#矩阵与变换" class="headerlink" title="矩阵与变换"></a>矩阵与变换</h3><p>变换在大多数情况下应用于平移、旋转、缩放，我们将会重点讲述如何使用矩阵来表示平移、旋转和缩放。<br>我们指定 t.x.y 这样的值时，表示这是 X 列向量的 Y 分量，换言之，就是这个矩阵的左下角。<br>类似地，t.x.x 就是左上角、t.y.x 就是右上角、t.y.y 就是右下角。此处的 t 是一个 Transform2D。</p>
<p>缩放变换矩阵</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var t = Transform2D()</span><br><span class="line"># Scale</span><br><span class="line">t.x *= 2</span><br><span class="line">t.y *= 2</span><br><span class="line">transform = t # Change the node&#x27;s transform to what we calculated.</span><br></pre></td></tr></table></figure>
<p>要从已存在的变换矩阵中计算对象的缩放尺度，可以对该矩阵的每个列向量使用 length() 方法。<br>在实际项目中，你可以使用 scaled() 方法去执行缩放变换操作。</p>
<p>旋转变换矩阵</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var rot = 0.5 # The rotation to apply.</span><br><span class="line">var t = Transform2D()</span><br><span class="line">t.x.x = cos(rot)</span><br><span class="line">t.y.y = cos(rot)</span><br><span class="line">t.x.y = sin(rot)</span><br><span class="line">t.y.x = -sin(rot)</span><br><span class="line">transform = t # Change the node&#x27;s transform to what we calculated.</span><br></pre></td></tr></table></figure>
<p>要从现有的变换矩阵中计算对象的旋转，可以使用 atan2(t.x.y, t.x.x)，其中 t 是 Transform2D。<br>在实际项目中，可以使用 rotated() 方法进行旋转。</p>
<p>变换矩阵的基<br>到目前为止，我们只使用 x 和 y 向量，它们负责表示旋转、缩放和&#x2F;或剪切（高级，会在文末提及）。<br>X 和 Y 向量合称变换矩阵的基（Basis）。“基”和“基向量”都是非常重要的术语。<br>你可能已经注意到 Transform2D 实际上有三个 Vector2 值：x、y、origin。<br>其中 origin 值不是基的一部分，而是变换的一部分，我们需要用它来表示位置。<br>从现在开始，我们将在所有示例中记录原点向量。你可以将原点看作另一列，但把它认为是完全独立的通常更好。<br>请注意在 3D 中，Godot 有一个单独的 Basis 结构，里面包含矩阵基的三个 Vector3 的值。<br>因为代码可能变得复杂，因此将它们从 Transform3D（由一个 Basis 和一个额外的原点 Vector3 组成）中拆分出来是值得的。</p>
<p>变换矩阵的平移<br>更改 origin 向量被称为对变换矩阵的平移。平移其实上是“移动”对象的一个技术术语，但它不会涉及任何旋转。<br>让我们通过一个例子来帮助理解这一点。我们将像上次一样从恒等变换开始，但这次我们将记录原点向量。<br>如果希望对象移动到 (1, 2) 的位置，只需将其 origin 向量设置为 (1, 2)：<br>还有一个 translated_local() 方法，它执行的是与直接增加或更改 origin 不同的操作。这个 translated_local() 方法将让该对象相对于它自己的旋转进行平移。例如，当使用 Vector2.UP 进行 translated_local() 时，顺时针旋转 90 度的对象将向右移动。要相对于全局&#x2F;父帧平移，请使用 translated()。</p>
<p>融会贯通</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var t = Transform2D()</span><br><span class="line"># Translation</span><br><span class="line">t.origin = Vector2(350, 150)</span><br><span class="line"># Rotation</span><br><span class="line">var rot = -0.5 # The rotation to apply.</span><br><span class="line">t.x.x = cos(rot)</span><br><span class="line">t.y.y = cos(rot)</span><br><span class="line">t.x.y = sin(rot)</span><br><span class="line">t.y.x = -sin(rot)</span><br><span class="line"># Scale</span><br><span class="line">t.x *= 3</span><br><span class="line">t.y *= 3</span><br><span class="line">transform = t # Change the node&#x27;s transform to what we calculated.</span><br></pre></td></tr></table></figure>

<p>高级部分暂不考虑</p>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>插值是图形编程中的一种常规操作，可以在两个值之间进行混合或过渡。<br>插值还可以让移动、旋转等运动变得平滑。熟悉插值对拓展游戏开发者的视野大有裨益。<br>基本思想是从 A 转换到 B。t 值是介于两者之间的状态。<br>举个例子，如果 t 是 0，那么他的状态是 A。如果 t 是 1，那么它的状态是 B。任何介于两者之间的状态都是插值。<br>两个实数（浮点数）之间的插值可以描述为：<br><code>interpolation = A * (1 - t) + B * t</code><br>通常简化为:<br><code>interpolation = A + (B - A) * t</code><br>这种以恒定速度将一个值转换为另一个值的插值被称为“线性”。因此，当你听到线性插值时，你就知道他们指的是这个公式。</p>
<p>向量插值<br>向量类型（Vector2 和 Vector3）也可以插值，向量自带了相关的便捷函数 Vector2.lerp() 和 Vector3.lerp()。<br>对于三次插值，还有 Vector2.cubic_interpolate() 和 Vector3.cubic_interpolate() ，它们执行 Bezier 式插值。<br>下面是从 A 点插值到 B 点的示例伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var t = 0.0</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	t += delta * 0.4</span><br><span class="line"></span><br><span class="line">	$Sprite2D.position = $A.position.lerp($B.position, t)</span><br></pre></td></tr></table></figure>

<p>变换插值<br>也可以对整个变换进行插值（确保它们具有均一缩放，或者至少有相同的非均一缩放）。<br>为此，可以使用函数 Transform3D.interpolate_with()。<br>下面是将猴子从位置1转换为位置2的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var t = 0.0</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	t += delta</span><br><span class="line"></span><br><span class="line">	$Monkey.transform = $Position1.transform.interpolate_with($Position2.transform, t)</span><br></pre></td></tr></table></figure>

<p>平滑运动<br>插值可用于平滑地跟随移动的目标值，例如位置或旋转。<br>每一帧，lerp（） 将当前值移动到目标值，其比例为值之间剩余差值的固定百分比。<br>当前值将平稳地向目标移动，随着目标的靠近而减慢速度。下面是使用插值平滑跟随鼠标的圆的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const FOLLOW_SPEED = 4.0</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	var mouse_pos = get_local_mouse_position()</span><br><span class="line"></span><br><span class="line">	$Sprite2D.position = $Sprite2D.position.lerp(mouse_pos, delta * FOLLOW_SPEED)</span><br></pre></td></tr></table></figure>
<p>这对于平滑镜头移动、跟随玩家的盟友（确保他们保持在一定范围内）以及许多其他常见的游戏模式非常有用。</p>
<p>尽管使用了 delta，但上面使用的公式与帧速率有关，因为 lerp（） 的权重参数表示剩余值差异的百分比 ，而不是要更改的绝对量 。<br>在 _physics_process（） 中，这通常没问题，因为物理场预计会保持恒定的帧速率，因此增量预计会保持恒定。<br>对于也可以在 process（） 中使用的与帧率无关的插值平滑版本，请改用以下公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const FOLLOW_SPEED = 4.0</span><br><span class="line"></span><br><span class="line">func _process(delta):</span><br><span class="line">	var mouse_pos = get_local_mouse_position()</span><br><span class="line">	var weight = 1 - exp(-FOLLOW_SPEED * delta)</span><br><span class="line">	$Sprite2D.position = $Sprite2D.position.lerp(mouse_pos, weight)</span><br></pre></td></tr></table></figure>
<p>推导此公式超出了本页的范围。有关说明，请参阅改进的插值平滑 或者观看插值平滑被破坏 。</p>
<h3 id="贝塞尔、曲线和路径"><a href="#贝塞尔、曲线和路径" class="headerlink" title="贝塞尔、曲线和路径"></a>贝塞尔、曲线和路径</h3><p>贝塞尔曲线是一种自然几何形状的数学近似.<br>我们用它们来代表一个曲线, 含有尽可能少的信息, 保持高水平的灵活性.<br>不像抽象的数学概念, 贝塞尔曲线是为工业设计. 它们是图形软件行业中的流行工具.<br>它们依赖于 插值, 我们在上一篇文章中看到, 如何结合多个步骤来创建平滑的曲线.<br>为了更好地理解贝塞尔曲线的工作原理, 我们从最简单的形式开始: 二次贝塞尔曲线.</p>
<p>二次贝塞尔曲线<br>取三个点, 这是建立二次贝塞尔曲线所需的最小值:<br>要在它们之间画一条曲线，我们首先使用 0 到 1 之间的值，在由这三个点构成的两个线段的每个顶点上逐步插值。<br>当我们把 t 值从 0 变成 1 时，就得到了两个沿着线段移动的点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func _quadratic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, t: float):</span><br><span class="line">	var q0 = p0.lerp(p1, t)</span><br><span class="line">	var q1 = p1.lerp(p2, t)</span><br></pre></td></tr></table></figure>
<p>然后，我们插值 q0 和 q1，以获得沿着曲线移动的单点 r。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var r = q0.lerp(q1, t)</span><br><span class="line">return r</span><br></pre></td></tr></table></figure>
<p>这种类型的曲线就被称为二次贝塞尔曲线。</p>
<p>三次贝塞尔曲线<br>基于前面的例子, 我们可以通过在四个点之间插值得到更多的控制.<br>首先我们使用一个带有四个参数的函数，以 p0、p1、p2、p3 四个点作为输入：<br>我们对每两个点进行线性插值, 将它们减少到三个:<br>然后我们把这三个点缩减为两个点:<br>然后到一个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func _cubic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2, t: float):</span><br><span class="line">	var q0 = p0.lerp(p1, t)</span><br><span class="line">	var q1 = p1.lerp(p2, t)</span><br><span class="line">	var q2 = p2.lerp(p3, t)</span><br><span class="line"></span><br><span class="line">	var r0 = q0.lerp(q1, t)</span><br><span class="line">	var r1 = q1.lerp(q2, t)</span><br><span class="line"></span><br><span class="line">	var s = r0.lerp(r1, t)</span><br><span class="line">	return s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三次贝塞尔插值在三维中也是一样的，只需使用 Vector3 代替 Vector2。</p>
</blockquote>
<p>添加控制点<br>在三次贝塞尔的基础上，我们可以通过改变两个点的工作方式来自由地控制曲线的形状。我们不使用 p0、p1、p2、p3，而是将它们存储为：<br>point0 &#x3D; p0：是第一个点，即源<br>control0 &#x3D; p1 - p0：是相对于第一个控制点的向量<br>control1 &#x3D; p3 - p2：是相对于第二个控制点的向量<br>point1 &#x3D; p3：是第二个点，即终点<br>使用这种方式, 有两个点和两个控制点, 它们是各自点的相对向量. 如果你以前用过图形或动画软件, 这可能看起来很熟悉:<br>这就是图形软件如何向用户呈现贝塞尔曲线, 以及它们在Godot引擎内的工作原理.</p>
<p>Curve2D、Curve3D、Path 以及 Path2D<br>有两个包含曲线的对象：Curve3D 和 Curve2D（分别用于 3D 和 2D）。<br>它们可以包含几个点，允许更长的路径。也可以将它们设置为节点：Path3D 和 Path2D（分别用于 3D 和 2D）：<br>然而它们的使用方法可能不是很直观，下面是对贝塞尔曲线最常见用例的描述。</p>
<p>估值<br>直接估值也是一种选择，不过在大多数情况下都不是很有用。贝塞尔曲线最大的缺点是，如果你以恒定的速度沿着它走，从 t &#x3D; 0 到 t &#x3D; 1，实际的插值不会以恒定的速度移动。速度也是根据点 p0、p1、p2、p3 之间距离插值出来的，无法使用简单的数学方法以恒定的速度通过曲线。<br>让我们用下面的伪代码举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var t = 0.0</span><br><span class="line"></span><br><span class="line">func _process(delta):</span><br><span class="line">	t += delta</span><br><span class="line">	position = _cubic_bezier(p0, p1, p2, p3, t)</span><br></pre></td></tr></table></figure>
<p>如你所见，即便 t 在匀速递增，圆点的速度还是在不断变化的（以像素每秒为单位）。这也使贝塞尔难以做到任何实际的开箱即用。</p>
<p>绘制<br>绘制贝塞尔(或基于曲线的对象)是很常见的用例，但这也不容易。几乎在任何情况下，贝塞尔曲线需要被转换成某种线段。然而，这通常很困难，除非创建大量线段。<br>原因是曲线的某些部分（具体来说是拐角）可能需要大量的点，而其他部分可能不需要：<br>另外，如果两个控制点都是 0,0（请记住它们是相对向量），贝塞尔曲线就是一条直线（因此绘制大量的点会很浪费）。<br>在绘制贝塞尔曲线之前，需要进行细分。这通常使用递归或分治函数来完成，该函数将曲线分割，直到曲率量小于某个阈值。<br>Curve 类通过 Curve2D.tessellate() 函数（接收可选的递归 stages 和角度 tolerance 参数）提供该功能。这样，基于曲线绘制某些东西就更容易了。</p>
<p>遍历<br>曲线的最后一个常见用途是遍历它们。由于之前提到的恒定速度，这也很困难。<br>为了使这更容易，需要将曲线烘焙成等距点。这样，它们可以用常规插值来近似（可以使用立方选项进一步优化）。为此，只需将 Curve3D.sample_baked() 方法与 Curve2D.get_baked_length() 一起使用。对其中任何一个的第一次调用都会在内部烘焙曲线。<br>那么，可以使用以下伪代码来完成恒定速度的遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var t = 0.0</span><br><span class="line"></span><br><span class="line">func _process(delta):</span><br><span class="line">	t += delta</span><br><span class="line">	position = curve.sample_baked(t * curve.get_baked_length(), true)</span><br></pre></td></tr></table></figure>
<p>然后输出将以恒定速度移动：</p>
<h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><blockquote>
<p>计算机不能产生“真正的”随机数。依赖伪随机数生成器（PRNG）。<br>全局作用域 vs RandomNumberGenerator 类<br>Godot 提供了两种生成随机数的方式：</p>
</blockquote>
<ol>
<li><strong>全局作用域</strong>方法更容易设置，但不能提供太多控制。</li>
<li><strong>RandomNumberGenerator</strong>需要使用更多代码，但允许建立多个实例，每个实例都有自己的种子和状态。<br>本教程使用全局作用域方法, 只存在于RandomNumberGenerator类中的方法除外.<br>randomize() 方法<br>备注<br>自Godot 4.0以来，当项目启动时，随机种子会自动设置为随机值。<br>这意味着你不再需要在 _ready() 中调用 randomize() 来确保项目运行的结果是随机的。<br>但是，如果你想使用特定的种子编号，或者使用不同的方法生成它，你仍然可以使用 randomize()。</li>
</ol>
<p>在全局作用域中，你可以找到一个 randomize() 方法。<br>该方法应该在你的项目开始初始化随机种子时只调用一次。多次调用它是不必要的，且可能会对性能产生负面影响。<br>把它放在你的主场景脚本的 _ready() 方法中是个不错的选择：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func _ready():</span><br><span class="line">	randomize()</span><br></pre></td></tr></table></figure>
<p>你也可以使用 seed() 设置固定的随机种子。这样做会在运行过程中为你提供确定性的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func _ready():</span><br><span class="line">	seed(12345)</span><br><span class="line">	# To use a string as a seed, you can hash it to a number.</span><br><span class="line">	seed(&quot;Hello world&quot;.hash())</span><br></pre></td></tr></table></figure>
<p>当使用RandomNumberGenerator类时，应该在实例上调用 randomize() ，因为它有自己的种子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var random = RandomNumberGenerator.new()</span><br><span class="line">random.randomize()</span><br></pre></td></tr></table></figure>

<p>获得一个随机数</p>
<ol>
<li>函数 randi（） 返回一个介于 0 和 2^32 - 1 之间的随机数。<br>由于最大值很大，您很可能希望使用模运算符 （%） 将结果绑定在 0 和分母之间：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Prints a random integer between 0 and 49.</span><br><span class="line">print(randi() % 50)</span><br><span class="line"></span><br><span class="line"># Prints a random integer between 10 and 60.</span><br><span class="line">print(randi() % 51 + 10)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>randf() 返回一个介于 0 和 1 之间的随机浮点数。在实现 加权随机概率 系统等时很有用。<br>randfn()遵循 正态分布 的随机浮点数。这意味着返回值更有可能在平均值附近（默认为 0.0），随偏差变化（默认为 1.0）:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(randfn(0.0, 1.0))</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>randf_range() 接受两个参数 from 和 to，并返回一个介于 from 和 to 之间的随机浮点数：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(randf_range(-4, 6.5))</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>randi_range() 接受两个参数 from 和 to，并返回一个介于 from 和 to 之间的随机整数：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(randi_range(-10, 10))</span><br></pre></td></tr></table></figure>

<p>获取一个随机数组元素<br>我们可以使用随机整数生成来从数组中获得一个随机元素，或者使用方法 Array.pick_random 来为我们做这件事:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var _fruits = [&quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;banana&quot;]</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	for i in range(100):</span><br><span class="line">		# Pick 100 fruits randomly.</span><br><span class="line">		print(get_fruit())</span><br><span class="line"></span><br><span class="line">	for i in range(100):</span><br><span class="line">		# Pick 100 fruits randomly, this time using the `Array.pick_random()`</span><br><span class="line">		# helper method. This has the same behavior as `get_fruit()`.</span><br><span class="line">		print(_fruits.pick_random())</span><br><span class="line"></span><br><span class="line">func get_fruit():</span><br><span class="line">	var random_fruit = _fruits[randi() % _fruits.size()]</span><br><span class="line">	# Returns &quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, or &quot;banana&quot; every time the code runs.</span><br><span class="line">	# We may get the same fruit multiple times in a row.</span><br><span class="line">	return random_fruit</span><br></pre></td></tr></table></figure>
<p>为了防止连续多次采摘相同的水果，我们可以给上述方法添加更多的逻辑。<br>此时无法使用 Array.pick_random ，因其缺少防重复机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var _fruits = [&quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;banana&quot;]</span><br><span class="line">var _last_fruit = &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	# Pick 100 fruits randomly.</span><br><span class="line">	for i in range(100):</span><br><span class="line">		print(get_fruit())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func get_fruit():</span><br><span class="line">	var random_fruit = _fruits[randi() % _fruits.size()]</span><br><span class="line">	while random_fruit == _last_fruit:</span><br><span class="line">		# The last fruit was picked. Try again until we get a different fruit.</span><br><span class="line">		random_fruit = _fruits[randi() % _fruits.size()]</span><br><span class="line"></span><br><span class="line">	# Note: if the random element to pick is passed by reference,</span><br><span class="line">	# such as an array or dictionary,</span><br><span class="line">	# use `_last_fruit = random_fruit.duplicate()` instead.</span><br><span class="line">	_last_fruit = random_fruit</span><br><span class="line"></span><br><span class="line">	# Returns &quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, or &quot;banana&quot; every time the code runs.</span><br><span class="line">	# The function will never return the same fruit more than once in a row.</span><br><span class="line">	return random_fruit</span><br></pre></td></tr></table></figure>
<p>这种方法可以让随机数生成的感觉不那么重复. 不过, 它仍然不能防止结果在有限的一组值之间 “乒乓反复”. 为了防止这种情况, 请使用 shuffle bag 模式来代替.</p>
<p>获取一个随机字典值<br>我们也可以将数组的类似逻辑应用于字典:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var _metals = &#123;</span><br><span class="line">	&quot;copper&quot;: &#123;&quot;quantity&quot;: 50, &quot;price&quot;: 50&#125;,</span><br><span class="line">	&quot;silver&quot;: &#123;&quot;quantity&quot;: 20, &quot;price&quot;: 150&#125;,</span><br><span class="line">	&quot;gold&quot;: &#123;&quot;quantity&quot;: 3, &quot;price&quot;: 500&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	for i in range(20):</span><br><span class="line">		print(get_metal())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func get_metal():</span><br><span class="line">	var random_metal = _metals.values()[randi() % metals.size()]</span><br><span class="line">	# Returns a random metal value dictionary every time the code runs.</span><br><span class="line">	# The same metal may be selected multiple times in succession.</span><br><span class="line">	return random_metal</span><br></pre></td></tr></table></figure>

<p>加权随机概率<br>randf() 方法返回一个介于 0.0 和 1.0 之间的浮点数。<br>我们可以使用它来创建“加权”概率，其中不同的结果具有不同的可能性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func _ready():</span><br><span class="line">	for i in range(100):</span><br><span class="line">		print(get_item_rarity())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func get_item_rarity():</span><br><span class="line">	var random_float = randf()</span><br><span class="line"></span><br><span class="line">	if random_float &lt; 0.8:</span><br><span class="line">		# 80% chance of being returned.</span><br><span class="line">		return &quot;Common&quot;</span><br><span class="line">	elif random_float &lt; 0.95:</span><br><span class="line">		# 15% chance of being returned.</span><br><span class="line">		return &quot;Uncommon&quot;</span><br><span class="line">	else:</span><br><span class="line">		# 5% chance of being returned.</span><br><span class="line">		return &quot;Rare&quot;</span><br></pre></td></tr></table></figure>
<p>您还可以使用 rand_weighted（） 方法。这将返回一个介于 0 和作为参数传递的数组大小之间的随机整数。<br>数组中的每个值都是一个浮点数，表示它作为索引返回的相对可能性。较高的值意味着该值更有可能作为索引返回，而值为 0 表示它永远不会作为索引返回。<br>例如，如果 [0.5， 1， 1， 2] 作为参数传递，则该方法返回 3（值 2 的索引）的可能性是原来的两倍，返回的可能性是原来的两倍 0（值 0.5 的指数）与指数 1 和 2 相比。由于返回值与数组的大小匹配，因此可以将其用作索引以从另一个数组获取值，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Prints a random element using the weighted index that is returned by `rand_weighted()`.</span><br><span class="line"># Here, &quot;apple&quot; will be returned twice as rarely as &quot;orange&quot; and &quot;pear&quot;.</span><br><span class="line"># &quot;banana&quot; is twice as common as &quot;orange&quot; and &quot;pear&quot;, and four times as common as &quot;apple&quot;.</span><br><span class="line">var fruits = [&quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;banana&quot;]</span><br><span class="line">var probabilities = [0.5, 1, 1, 2];</span><br><span class="line"></span><br><span class="line">var random = RandomNumberGenerator.new()</span><br><span class="line">print(fruits[random.rand_weighted(probabilities)])</span><br></pre></td></tr></table></figure>

<p>使用 shuffle bag 达到“更好”随机性<br>以上面同样的例子为例, 我们希望随机挑选水果.<br>然而, 每次选择水果时依靠随机数生成会导致分布不那么 均匀 .<br>如果玩家足够幸运(或不幸), 他们可能会连续三次或更多次得到相同的水果.<br>您可以使用洗牌袋模式来完成此作。它的工作原理是在选择元素后从数组中删除元素。<br>多次选择后，数组最终为空。发生这种情况时，将其重新初始化为默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var _fruits = [&quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;banana&quot;]</span><br><span class="line"># A copy of the fruits array so we can restore the original value into `fruits`.</span><br><span class="line">var _fruits_full = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	_fruits_full = _fruits.duplicate()</span><br><span class="line">	_fruits.shuffle()</span><br><span class="line"></span><br><span class="line">	for i in 100:</span><br><span class="line">		print(get_fruit())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func get_fruit():</span><br><span class="line">	if _fruits.is_empty():</span><br><span class="line">		# Fill the fruits array again and shuffle it.</span><br><span class="line">		_fruits = _fruits_full.duplicate()</span><br><span class="line">		_fruits.shuffle()</span><br><span class="line"></span><br><span class="line">	# Get a random fruit, since we shuffled the array,</span><br><span class="line">	# and remove it from the `_fruits` array.</span><br><span class="line">	var random_fruit = _fruits.pop_front()</span><br><span class="line">	# Returns &quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, or &quot;banana&quot; every time the code runs, removing it from the array.</span><br><span class="line">	# When all fruit are removed, it refills the array.</span><br><span class="line">	return random_fruit</span><br></pre></td></tr></table></figure>
<p>在运行上面的代码时, 仍有可能连续两次得到同一个水果.<br>我们摘下一个水果时, 它将不再是一个可能的返回值, 但除非数组现在是空的.<br>当数组为空时, 此时我们将其重置回默认值, 这样就导致了能再次获得相同的水果, 但只有这一次.</p>
<p>随机噪音<br>当你需要一个 缓慢 根据输入而变化的值时, 上面显示的随机数生成方式就显示出了它们的局限性.<br>这里的输入可以是位置, 时间或其他任何东西.<br>为了实现这一点，你可以使用随机噪声函数。噪声函数在程序式生成中特别受欢迎，可用于生成逼真的地形。<br>Godot 为此提供了 FastNoiseLite，它支持 1D、2D 和 3D 噪声。以下是 1D 噪声的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var _noise = FastNoiseLite.new()</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	# Configure the FastNoiseLite instance.</span><br><span class="line">	_noise.noise_type = FastNoiseLite.NoiseType.TYPE_SIMPLEX_SMOOTH</span><br><span class="line">	_noise.seed = randi()</span><br><span class="line">	_noise.fractal_octaves = 4</span><br><span class="line">	_noise.frequency = 1.0 / 20.0</span><br><span class="line"></span><br><span class="line">	for i in 100:</span><br><span class="line">		# Prints a slowly-changing series of floating-point numbers</span><br><span class="line">		# between -1.0 and 1.0.</span><br><span class="line">		print(_noise.get_noise_1d(i))</span><br></pre></td></tr></table></figure>

<p>密码安全的伪随机数生成器<br>目前为止提到的方法都无法实现密码安全的伪随机数生成（CSPRNG）。这对于游戏而言没有问题，但是对于涉及加密、认证、签名的场景就显得捉襟见肘。<br>Godot 为此提供了 Crypto 类。这个类可以执行非对称密钥加密、解密、签名和验证，也可以生成密码安全的随机字节块、RSA 密钥、HMAC 摘要、自签名的 X509Certificate。<br>CSPRNG 的缺点是它比标准伪随机数的生成慢得多。其 API 的使用也不太方便。因此，游戏机制应避免使用 CSPRNG。<br>使用 Crypto 类生成 0 到 2^32-1（含）之间的 2 个随机整数的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var crypto := Crypto.new()</span><br><span class="line"># Request as many bytes as you need, but try to minimize the amount</span><br><span class="line"># of separate requests to improve performance.</span><br><span class="line"># Each 32-bit integer requires 4 bytes, so we request 8 bytes.</span><br><span class="line">var byte_array := crypto.generate_random_bytes(8)</span><br><span class="line"></span><br><span class="line"># Use the ``decode_u32()`` method from PackedByteArray to decode a 32-bit unsigned integer</span><br><span class="line"># from the beginning of `byte_array`. This method doesn&#x27;t modify `byte_array`.</span><br><span class="line">var random_int_1 := byte_array.decode_u32(0)</span><br><span class="line"># Do the same as above, but with an offset of 4 bytes since we&#x27;ve already decoded</span><br><span class="line"># the first 4 bytes previously.</span><br><span class="line">var random_int_2 := byte_array.decode_u32(4)</span><br><span class="line"></span><br><span class="line">prints(&quot;Random integers:&quot;, random_int_1, random_int_2)</span><br></pre></td></tr></table></figure>



<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><h3 id="2D-导航概述"><a href="#2D-导航概述" class="headerlink" title="2D 导航概述"></a>2D 导航概述</h3><p>Godot 提供了多种对象、类和服务器，可帮助 2D 和 3D 游戏实现基于栅格（Grid）或网格（Mesh）的导航和寻路。<br>Godot 为 2D 导航提供了如下对象和类：</p>
<ul>
<li><p>Astar2D<br>Astar2D 对象能够在由具有权重的点构成的图中查找最短路径。<br>AStar2D 类最适合的是基于单元格的 2D 游戏，角色不需要到达区域中的任意位置，只需要能够到达一些预先指定的独立位置。</p>
</li>
<li><p>AstarGrid2D<br>AstarGrid2D 是 AStar2D 的变体，专门用于部分 2D 网格。<br>能够使用 AstarGrid2D 的地方 AstarGrid2D 用起来更简单，因为不需要手动创建点，也不需要手动进行连接。</p>
</li>
<li><p>NavigationServer2D<br>NavigationServer2D 提供了强大的服务器 API，能够在区域中查找两个位置之间的最短路径，区域使用导航网格定义。<br>NavigationServer 最适合的是要求角色能够到达区域中任意位置的 2D 实时游戏，区域由导航网格定义。基于网格的导航能够轻松扩展到大型游戏世界，因为大型区域通常能够使用单一多边形定义，如果换成栅格则会需要定义许许多多的单元格。<br>NavigationServer 中存放了不同的导航地图，每一张地图都由若干区块组成，区块中存放的是导航网格数据。在地图上放置代理就能够进行避障计算。与服务器通信时，使用 RID 来引用内部的地图、区块和代理。</p>
</li>
<li><p>NavigationServer 中可用的 RID 类型如下。</p>
<ul>
<li>导航地图 RID<br>  引用指定的导航地图，地图中存放的是区块和代理。地图会尝试将区块中的导航网格根据距离进行合并。<br>  每一个物理帧，地图都会同步区块和代理。</li>
<li>导航区块 RID<br>  引用指定的导航区块，区块中存放的是导航网格数据。<br>  使用导航层位掩码可以对区块进行启用&#x2F;禁用，限制其使用。</li>
<li>导航链接 RID<br>  引用指定的导航链接，能够将两个导航网格上的位置进行连接，无视距离。</li>
<li>导航代理 RID<br>  引用指定的避障代理。避障使用半径值指定。</li>
<li>导航障碍物 RID<br>  引用指定的避障障碍物，会对代理的避障速度产生影响和约束。</li>
</ul>
</li>
</ul>
<p>下列场景树节点可以辅助对 NavigationServer2D API 的使用。</p>
<ul>
<li><p>NavigationRegion2D 节点<br>存放 NavigationPolygon 资源的节点，该资源定义的是 NavigationServer2D 中的导航网格。<br>区块可以启用&#x2F;禁用。<br>通过 navigation_layers 掩码，可以对其在寻路中的使用做进一步的限制。<br>NavigationServer2D 会根据距离将不同区块中的导航网格合并成一个导航网格。</p>
</li>
<li><p>NavigationLink2D 节点<br>将两个导航网格上的位置进行连接的节点，无视距离，可用于寻路。<br>链接可以启用&#x2F;禁用。<br>链接可以设为单向或双向。<br>通过 navigation_layers 掩码，可以对其在寻路中的使用做进一步的限制。<br>链接会告诉寻路存在这样的连接、相关的消耗如何。实际的代理处理以及移动需要在自定义脚本中实现。</p>
</li>
<li><p>NavigationAgent2D 节点<br>可选的辅助节点，用于为继承自 Node2D 的父节点提供寻路和避障所需的常规 NavigationServer2D API 调用。请将这个节点放在继承自 Node2D 的父节点下。</p>
</li>
<li><p>NavigationObstacle2D 节点<br>可用于影响和约束启用躲避的代理的躲避速度的节点。此节点不影响代理的寻路。你需要为此更改导航网格。</p>
</li>
</ul>
<p>2D 导航网格由以下资源定义：</p>
<ul>
<li>NavigationPolygon 资源<br>存放 2D 导航网格数据的资源，提供了多边形绘制工具，既能够在编辑器中定义导航区域，也能够在运行时定义。<br>NavigationRegion2D 节点使用该资源定义其导航区域。<br>NavigationServer2D 使用该资源更新各个区块的导航网格。<br>TileSet 编辑器会定义图块的导航区域时在内部创建并使用该资源。</li>
</ul>
<p>参见<br>可以使用 2D 导航演示项目和使用 AStarGrid2D 进行基于栅格的导航 演示项目了解 2D 导航如何运作。</p>
<p>2D 场景的设置<br>下列步骤演示的是最小可行的 2D 导航的基础设置，使用 NavigationServer2D 和 NavigationAgent2D 进行路径移动。</p>
<ol>
<li>在场景中添加一个 NavigationRegion2D 节点。</li>
<li>单击该区块节点，向该节点添加一个新的 NavigationPolygon 资源。</li>
<li>使用 NavigationPolygon 绘制工具定义可移动导航区域。然后点击工具栏上的 烘焙 NavigationPolygon 按钮。</li>
<li>在场景中添加一个 CharacterBody2D 节点，设置基础的碰撞形状，添加一个精灵或网格方便观察。</li>
<li>在该角色节点下添加一个 NavigationAgent2D 节点。</li>
<li>为 CharacterBody3D 节点添加下面的脚本。场景完全加载后，确保设置移动目标，NavigationServer 有时间进行同步。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">extends CharacterBody2D</span><br><span class="line"></span><br><span class="line">var movement_speed: float = 200.0</span><br><span class="line">var movement_target_position: Vector2 = Vector2(60.0,180.0)</span><br><span class="line"></span><br><span class="line">@onready var navigation_agent: NavigationAgent2D = $NavigationAgent2D</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	# These values need to be adjusted for the actor&#x27;s speed</span><br><span class="line">	# and the navigation layout.</span><br><span class="line">	navigation_agent.path_desired_distance = 4.0</span><br><span class="line">	navigation_agent.target_desired_distance = 4.0</span><br><span class="line"></span><br><span class="line">	# Make sure to not await during _ready.</span><br><span class="line">	actor_setup.call_deferred()</span><br><span class="line"></span><br><span class="line">func actor_setup():</span><br><span class="line">	# Wait for the first physics frame so the NavigationServer can sync.</span><br><span class="line">	await get_tree().physics_frame</span><br><span class="line"></span><br><span class="line">	# Now that the navigation map is no longer empty, set the movement target.</span><br><span class="line">	set_movement_target(movement_target_position)</span><br><span class="line"></span><br><span class="line">func set_movement_target(movement_target: Vector2):</span><br><span class="line">	navigation_agent.target_position = movement_target</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	if navigation_agent.is_navigation_finished():</span><br><span class="line">		return</span><br><span class="line"></span><br><span class="line">	var current_agent_position: Vector2 = global_position</span><br><span class="line">	var next_path_position: Vector2 = navigation_agent.get_next_path_position()</span><br><span class="line"></span><br><span class="line">	velocity = current_agent_position.direction_to(next_path_position) * movement_speed</span><br><span class="line">	move_and_slide()</span><br></pre></td></tr></table></figure>

<p>备注<br>第一帧的时候，NavigationServer 上的地图还没有同步区块数据，请求路径时都会返回空。<br>在脚本中等待一帧就可以让 NavigationServer 进行同步。</p>
<h3 id="3D-导航概述"><a href="#3D-导航概述" class="headerlink" title="3D 导航概述"></a>3D 导航概述</h3><p>Godot 为 3D 导航提供了如下对象和类：</p>
<ul>
<li><p>Astar3D<br>Astar3D 对象能够在由具有权重的点构成的图中查找最短路径。<br>AStar3D 类最适合的是基于单元格的 3D 游戏，角色不需要到达区域中的任意位置，只需要到达预先指定的一些独立位置。</p>
</li>
<li><p>NavigationServer3D<br>NavigationServer3D 提供了强大的服务器 API，能够在区域中查找两个位置之间的最短路径，区域使用导航网格定义。<br>NavigationServer 最适合的是要求角色能够到达区域中任意位置的 3D 实时游戏，区域由导航网格定义。基于网格的导航能够轻松扩展到大型游戏世界，因为大型区域通常能够使用单一多边形定义，如果换成栅格则会需要定义许许多多的单元格。<br>NavigationServer 中存放了不同的导航地图，每一张地图都由若干区块组成，区块中存放的是导航网格数据。在地图上放置代理就能够进行避障计算。与服务器通信时，使用 RID 来引用内部的地图、区块和代理。</p>
</li>
<li><p>NavigationServer 中可用的 RID 类型如下。</p>
<ul>
<li><p>导航地图 RID<br>  引用指定的导航地图，地图中存放的是区块和代理。地图会尝试将区块中的导航网格根据距离进行合并。每一个物理帧，地图都会同步区块和代理。</p>
</li>
<li><p>导航区块 RID<br>  引用指定的导航区块，区块中存放的是导航网格数据。使用导航层位掩码可以对区块进行启用&#x2F;禁用，限制其使用。</p>
</li>
<li><p>导航链接 RID<br>  引用指定的导航链接，能够将两个导航网格上的位置进行连接，无视距离。</p>
</li>
<li><p>导航代理 RID<br>  引用指定的避障代理，避障时使用的是半径值。</p>
</li>
<li><p>导航障碍物 RID<br>  引用指定的避障障碍物，会对代理的避障速度产生影响和约束。</p>
</li>
</ul>
</li>
</ul>
<p>下列场景树节点可以辅助对 NavigationServer3D API 的使用。</p>
<ul>
<li>NavigationRegion3D 节点<br>存放 Navigation Mesh 资源的节点，该资源定义的是 NavigationServer3D 中的导航网格。<br>区块可以启用&#x2F;禁用。<br>通过 navigation_layers 掩码，可以对其在寻路中的使用做进一步的限制。<br>NavigationServer3D 会根据距离将不同的导航网格合并成一个导航网格。</li>
<li>NavigationLink3D 节点<br>将两个导航网格上的位置进行连接的节点，无视距离，可用于寻路。<br>链接可以启用&#x2F;禁用。<br>链接可以设为单向或双向。<br>通过 navigation_layers 掩码，可以对其在寻路中的使用做进一步的限制。<br>链接会告诉寻路存在这样的连接、相关的消耗如何。实际的代理处理以及移动需要在自定义脚本中实现。</li>
<li>NavigationAgent3D 节点<br>方便调用寻路和避障所需的常规 NavigationServer3D API 的辅助节点。该节点的父节点应该继承自 Node3D。</li>
<li>NavigationObstacle3D 节点<br>可用于影响和约束启用躲避的代理的躲避速度的节点。此节点不影响代理的寻路。你需要为此更改导航网格。</li>
</ul>
<p>3D 导航网格由以下资源定义：</p>
<ul>
<li>NavigationMesh 资源<br>  存放 3D 导航网格数据的资源，提供了 3D 几何体的烘焙选项，既能够在编辑器中定义导航区域，也能够在运行时定义。<ul>
<li>NavigationRegion3D 节点使用该资源定义其导航区域。</li>
<li>NavigationServer3D 使用该资源更新各个区块的导航网格。</li>
<li>GridMap 编辑器会在栅格单元格中存在对导航网格的定义时使用该资源。</li>
</ul>
</li>
</ul>
<p>参见<br>可以使用 3D 导航演示项目了解 3D 导航如何运作。</p>
<p>3D 场景的设置<br>下列步骤演示的是最小可行的 3D 导航的基础设置，使用 NavigationServer3D 和 NavigationAgent3D 进行路径移动。</p>
<ol>
<li>在场景中添加一个 NavigationRegion3D 节点。</li>
<li>单击该区块节点，向该节点添加一个新的 NavigationMesh 资源。</li>
<li>将一个新的 MeshInstance3D 节点添加为该区块节点的子节点。</li>
<li>选中该 MeshInstance3D 节点，添加一个新的 PlaneMesh 并将其 XY 大小设为 10。</li>
<li>再次选中该区块节点，点击顶栏中的“烘焙导航网格”按钮。</li>
<li>现在就会显示出透明的导航网格，悬浮在 PlaneMesh 上方。</li>
<li>在场景中添加一个 CharacterBody3D 节点，设置基础的碰撞形状，添加一些网格方便观察。</li>
<li>在该角色节点下添加一个 NavigationAgent3D 节点。</li>
<li>为 CharacterBody3D 节点添加一个脚本，内容如下。场景完全加载后，我们确保设置移动目标，NavigationServer 有时间进行同步。另外，添加一个 Camera3D、一些灯光以及环境，这样才能够看到东西。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">extends CharacterBody3D</span><br><span class="line"></span><br><span class="line">var movement_speed: float = 2.0</span><br><span class="line">var movement_target_position: Vector3 = Vector3(-3.0,0.0,2.0)</span><br><span class="line"></span><br><span class="line">@onready var navigation_agent: NavigationAgent3D = $NavigationAgent3D</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	# These values need to be adjusted for the actor&#x27;s speed</span><br><span class="line">	# and the navigation layout.</span><br><span class="line">	navigation_agent.path_desired_distance = 0.5</span><br><span class="line">	navigation_agent.target_desired_distance = 0.5</span><br><span class="line"></span><br><span class="line">	# Make sure to not await during _ready.</span><br><span class="line">	actor_setup.call_deferred()</span><br><span class="line"></span><br><span class="line">func actor_setup():</span><br><span class="line">	# Wait for the first physics frame so the NavigationServer can sync.</span><br><span class="line">	await get_tree().physics_frame</span><br><span class="line"></span><br><span class="line">	# Now that the navigation map is no longer empty, set the movement target.</span><br><span class="line">	set_movement_target(movement_target_position)</span><br><span class="line"></span><br><span class="line">func set_movement_target(movement_target: Vector3):</span><br><span class="line">	navigation_agent.set_target_position(movement_target)</span><br><span class="line"></span><br><span class="line">func _physics_process(delta):</span><br><span class="line">	if navigation_agent.is_navigation_finished():</span><br><span class="line">		return</span><br><span class="line"></span><br><span class="line">	var current_agent_position: Vector3 = global_position</span><br><span class="line">	var next_path_position: Vector3 = navigation_agent.get_next_path_position()</span><br><span class="line"></span><br><span class="line">	velocity = current_agent_position.direction_to(next_path_position) * movement_speed</span><br><span class="line">	move_and_slide()</span><br></pre></td></tr></table></figure>

<p>备注<br>第一帧的时候，NavigationServer 上的地图还没有同步区块数据，请求路径时都会返回空。在脚本中等待一帧就可以让 NavigationServer 进行同步。</p>
<h3 id="使用-NavigationServer"><a href="#使用-NavigationServer" class="headerlink" title="使用 NavigationServer"></a>使用 NavigationServer</h3><p>NavigationServer 即导航服务器。<br>分别为 NavigationServer2D 和 NavigationServer3D。</p>
<p>与 NavigationServer 通信<br>要使用 NavigationServer 首先就需要为请求准备参数，这个请求会被发送给 NavigationServer，用来进行更新和数据的请求。<br>地图、区块、代理等 NavigationServer 内部的对象使用 RID 来进行引用，这是一种用作标识符的数字。<br>场景树中每个导航相关的节点都提供了返回该节点 RID 的函数。</p>
<p>线程与同步<br>NavigationServer 不会立即为所有更改执行更新，而是会等到物理帧的结尾再同步所有更改。</p>
<p>对地图、区块、代理进行更改都需要等待同步。之所以要进行同步，是因为部分更新的开销非常大，并且需要所有其他对象更新后的数据，例如重新计算整个导航地图。另外 NavigationServer 的部分功能默认会使用线程池，例如代理之间的避障计算。</p>
<p>大多数 get() 函数都不需要等待，因为这些函数只会从 NavigationServer 请求数据，不会进行修改。请注意，并不是所有数据都会考虑到同一帧里做出的更改。比如避障代理在当前帧更改了导航地图的话，那么 agent_get_map() 函数在同步之前就仍然会返回旧的地图。部分节点会在向 NavigationServer 发送更新前在内部存储对应的值，所以这些节点属于例外。在这种节点上使用某个值的 getter 时，如果同一帧存在更新，那么返回的就是存储在该节点上的更新后的值。</p>
<p>NavigationServer 是线程安全的，因为它会把所有需要执行更改的 API 调用放在队列中，在同步阶段再执行。NavigationServer 的同步发生在物理帧，在脚本以及节点的场景输入之后。</p>
<p>备注</p>
<p>划重点：大多数对 NavigationServer 的更改都会在下一个物理帧之后生效，不会立即生效。包括场景树中导航相关节点做出的更改，以及脚本做出的更改。</p>
<p>备注</p>
<p>Setter 和删除函数都需要同步。</p>
<p>2D 和 3D NavigationServer 的区别<br>NavigationServer2D and NavigationServer3D are equivalent in functionality for their dimension.</p>
<p>从技术上讲，可以使用工具在一个维度上为另一个维度创建导航网格，例如，当使用平面三维源几何体时，使用3D NavigationMesh烘焙二维导航网格，或者使用NavigationRegion2D和NavigationPolygons的多边形轮廓绘制工具创建三维平面导航网格。</p>
<p>等待同步<br>在游戏开始时，新场景或程序导览发生变化，对导览服务器的任何路径查询都将传回空或错误。</p>
<p>此时导航地图仍然为空或未更新。场景树中的所有节点都需要首先将其导航相关数据上传到NavigationServer。每个添加或更改的地图、区域或代理都需要在NavigationServer中注册。之后，NavigationServer需要<strong>物理帧</strong>进行同步，以更新地图、区域和代理。</p>
<p>一种解决方法是延迟调用自定义设置函数（这样所有节点都准备好了）。设置功能进行所有导航更改，例如添加程序性内容。之后，函数在继续路径查询之前等待下一个物理帧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">extends Node3D</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	# Use call deferred to make sure the entire scene tree nodes are setup</span><br><span class="line">	# else await on &#x27;physics_frame&#x27; in a _ready() might get stuck.</span><br><span class="line">	custom_setup.call_deferred()</span><br><span class="line"></span><br><span class="line">func custom_setup():</span><br><span class="line"></span><br><span class="line">	# Create a new navigation map.</span><br><span class="line">	var map: RID = NavigationServer3D.map_create()</span><br><span class="line">	NavigationServer3D.map_set_up(map, Vector3.UP)</span><br><span class="line">	NavigationServer3D.map_set_active(map, true)</span><br><span class="line"></span><br><span class="line">	# Create a new navigation region and add it to the map.</span><br><span class="line">	var region: RID = NavigationServer3D.region_create()</span><br><span class="line">	NavigationServer3D.region_set_transform(region, Transform3D())</span><br><span class="line">	NavigationServer3D.region_set_map(region, map)</span><br><span class="line"></span><br><span class="line">	# Create a procedural navigation mesh for the region.</span><br><span class="line">	var new_navigation_mesh: NavigationMesh = NavigationMesh.new()</span><br><span class="line">	var vertices: PackedVector3Array = PackedVector3Array([</span><br><span class="line">		Vector3(0, 0, 0),</span><br><span class="line">		Vector3(9.0, 0, 0),</span><br><span class="line">		Vector3(0, 0, 9.0)</span><br><span class="line">	])</span><br><span class="line">	new_navigation_mesh.set_vertices(vertices)</span><br><span class="line">	var polygon: PackedInt32Array = PackedInt32Array([0, 1, 2])</span><br><span class="line">	new_navigation_mesh.add_polygon(polygon)</span><br><span class="line">	NavigationServer3D.region_set_navigation_mesh(region, new_navigation_mesh)</span><br><span class="line"></span><br><span class="line">	# Wait for NavigationServer sync to adapt to made changes.</span><br><span class="line">	await get_tree().physics_frame</span><br><span class="line"></span><br><span class="line">	# Query the path from the navigation server.</span><br><span class="line">	var start_position: Vector3 = Vector3(0.1, 0.0, 0.1)</span><br><span class="line">	var target_position: Vector3 = Vector3(1.0, 0.0, 1.0)</span><br><span class="line">	var optimize_path: bool = true</span><br><span class="line"></span><br><span class="line">	var path: PackedVector3Array = NavigationServer3D.map_get_path(</span><br><span class="line">		map,</span><br><span class="line">		start_position,</span><br><span class="line">		target_position,</span><br><span class="line">		optimize_path</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	print(&quot;Found a path!&quot;)</span><br><span class="line">	print(path)</span><br></pre></td></tr></table></figure>

<p>服务器避障回调<br>如果 RVO 避障代理注册了避障回调，NavigationServer 会在 PhysicsServer 同步前发送对应的 velocity_computed 信号。<br>更多 NavigationAgent 相关的信息见 使用 NavigationAgent。<br>使用避障的 NavigationAgent 的简化执行顺序如下：<br>物理帧开始。<br>_physics_process(delta)。<br>设置 NavigationAgent 节点的 velocity 属性。<br>代理向 NavigationServer 发送速度和位置。<br>NavigationServer 等待同步。<br>NavigationServer 同步并为所有注册的避障代理计算避障速度。<br>NavigationServer 通过信号为每个注册的避障代理发送安全速度向量。</p>
<p>代理收到信号并移动父节点，例如通过 move_and_slide 或 linear_velocity 移动。<br>PhysicsServer 同步。<br>物理帧结束。<br>因此，在回调函数中使用安全速度来移动角色物理体无论从线程还是物理的角度看都是安全的，因为相关的操作都在同一个物理帧中进行，之后 PhysicsServer 才会提交更改并进行计算。</p>
<h3 id="使用导航地图"><a href="#使用导航地图" class="headerlink" title="使用导航地图"></a>使用导航地图</h3><p>NavigationMap 即导航地图，是抽象的导航世界，位于 NavigationServer 中，使用 NavigationServer 的 RID 标识。<br>地图中可以存放并连接几乎无限数量的导航区块，区块中的导航网格可以用来构建游戏世界中的可达区域，用于寻路操作。<br>地图中可以包含避障代理。碰撞躲避是根据地图中存在的代理来计算的。</p>
<p>备注<br>不同 NavigationMap 之间是相互独立的，但是导航区块和避障代理可以在不同地图之间进行切换。切换会在 NavigationServer 同步后生效。<br>默认导航地图<br>Godot 默认会为根视口的每个 World2D 和 World3D 创建一个导航地图。<br>默认的 2D 导航地图 RID 可以从继承自 Node2D 的任何 Node 的 get_world_2d().get_navigation_map() 获取。<br>默认的 3D 导航地图 RID 可以从继承自 Node3D 的任何 Node 的 get_world_3d().get_navigation_map() 获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">func _ready() -&gt; void:</span><br><span class="line">	var default_navigation_map_rid: RID = get_world_2d().get_navigation_map()</span><br></pre></td></tr></table></figure>

<p>新建导航地图<br>导航服务器可根据特定游戏的需要创建和支持尽可能多的导航地图。其他导航地图可通过直接使用导航服务器应用程序接口来创建和处理，例如支持不同的避障代理或演员运动类型。</p>
<p>有关使用不同导航地图的示例，请参阅 支持不同角色类型 和 支持不同角色运动。</p>
<p>每个导航地图都会单独同步其导航区块和避障代理的更改队列。未收到更改通知的导航地图几乎不会消耗任何处理时间。导航区块和避障代理只能是单个导航地图的一部分，但它们可以随时切换所属地图。</p>
<p>备注<br>导航地图切换只有在下一次同步导航服务器后才会生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">func _ready() -&gt; void:</span><br><span class="line">	var new_navigation_map: RID = NavigationServer2D.map_create()</span><br><span class="line">	NavigationServer2D.map_set_active(new_navigation_map, true)</span><br></pre></td></tr></table></figure>
<p>备注<br>使用 NavigationServer2D API 和 NavigationServer3D API 创建的导航地图没有任何区别。</p>
<h3 id="使用导航区块"><a href="#使用导航区块" class="headerlink" title="使用导航区块"></a>使用导航区块</h3><p>NavigationRegion 即导航区块，是对 NavigationServer 的导航地图中某个区块的可视化 Node 表示。<br>每个 NavigationRegion 节点中都存放着导航网格数据资源。</p>
<p>2D 和 3D 版本分别为 NavigationRegion2D 和 NavigationRegion3D。</p>
<p>各个导航区域将其二维导航多边形或三维导航网格资源数据上传到导航服务器。导航服务器地图会将这些信息转化为用于寻路的组合导航地图。</p>
<p>要使用场景树创建导航区块，请在场景中添加一个 NavigationRegion2D 或 NavigationRegion3D 节点。所有区块都需要导航网格资源才能正常工作。导航网格的创建和应用见 使用导航网格。</p>
<p>NavigationRegion 会自动将 global_transform 的变化推送到导航服务器上的对应区块，因此可用于移动的平台。当各个区块的导航网格足够接近时，NavigationServer 就会尝试将它们连接起来，详见 连接导航网格。NavigationLink 可以连接任意距离的 NavigationRegion，如何创建和使用见 使用 NavigationLink。</p>
<p>警告<br>虽然修改 NavigationRegion 节点的变换能够更新 NavigationServer 中对应区块的位置，但是修改缩放却不会。导航网格资源不具备缩放，所以来源几何体的缩放发生改变时需要进行完整的更新。</p>
<p>区块可以启用&#x2F;禁用，如果禁用，则不会参与寻路查询。</p>
<p>备注<br>启用&#x2F;禁用区块时，现有路径不会自动更新。</p>
<p>新建导航区块<br>新的导航区块节点会在2D&#x2F;3D 尺寸的默认世界导航地图上自动注册。</p>
<p>然后就可以通过 NavigationRegion 节点的 <code>get_rid()</code> 获取区块 RID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extends NavigationRegion2D</span><br><span class="line"></span><br><span class="line">var navigationserver_region_rid: RID = get_rid()</span><br></pre></td></tr></table></figure>
<p>还可以使用导航服务器接口创建新区块，并将其添加到任何现有地图中。<br>如果直接使用导航服务器接口创建区块，则需要手动为其分配导航地图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line">func _ready() -&gt; void:</span><br><span class="line">	var new_region_rid: RID = NavigationServer2D.region_create()</span><br><span class="line">	var default_map_rid: RID = get_world_2d().get_navigation_map()</span><br><span class="line">	NavigationServer2D.region_set_map(new_region_rid, default_map_rid)</span><br></pre></td></tr></table></figure>
<p>备注<br>导航区块只能分配给一个导航地图。如果将现有区块分配到新的导航地图，它就不属于旧地图了。</p>
<h3 id="使用导航网格"><a href="#使用导航网格" class="headerlink" title="使用导航网格"></a>使用导航网格</h3><p>2D 和 3D 版本的导航网格分别为 NavigationPolygon 和 NavigationMesh。<br>备注<br>导航网格描述的只是代理中心位置的可达区域，会忽略代理可能存在的半径值。如果你想要让寻路考虑代理的（碰撞）尺寸，就需要让导航网格收缩对应的量。</p>
<p>导航系统的工作独立于渲染或物理等其他引擎部分。导航系统在寻路时只考虑导航网格，视觉效果和碰撞形状等会被导航系统完全忽略。如果在寻路时需要考虑其他数据（例如视觉效果），则需要对导航网格进行相应调整。在导航网格中考虑导航限制的过程通常称为导航网格烘焙。</p>
<p>如果你在遵循导航路径时遇到剪切或碰撞问题，请务必记住，你需要通过合适的导航网格告诉导航系统你的意图。<br>导航系统本身永远不会知道 “这是树木&#x2F;岩石&#x2F;墙壁碰撞形状或可视化网格”，因为它只知道 “我被告知在这里可以安全通过，因为它在导航网格上”。</p>
<p>导航网格的烘焙可以使用 NavigationRegion2D 或 NavigationRegion3D 实现，也可以直接使用 NavigationServer2D 和 NavigationServer3D 的 API。<br>使用导航区块 NavigationRegion 烘焙导航网格</p>
<h3 id="使用-NavigationPath"><a href="#使用-NavigationPath" class="headerlink" title="使用 NavigationPath"></a>使用 NavigationPath</h3><h3 id="使用-NavigationPathQueryObject"><a href="#使用-NavigationPathQueryObject" class="headerlink" title="使用 NavigationPathQueryObject"></a>使用 NavigationPathQueryObject</h3><h3 id="使用-NavigationAgent"><a href="#使用-NavigationAgent" class="headerlink" title="使用 NavigationAgent"></a>使用 NavigationAgent</h3><h3 id="使用-NavigationObstacle"><a href="#使用-NavigationObstacle" class="headerlink" title="使用 NavigationObstacle"></a>使用 NavigationObstacle</h3><h3 id="使用-NavigationLink"><a href="#使用-NavigationLink" class="headerlink" title="使用 NavigationLink"></a>使用 NavigationLink</h3><h3 id="使用-NavigationLayer"><a href="#使用-NavigationLayer" class="headerlink" title="使用 NavigationLayer"></a>使用 NavigationLayer</h3><h3 id="导航调试工具"><a href="#导航调试工具" class="headerlink" title="导航调试工具"></a>导航调试工具</h3><h3 id="连接导航网格"><a href="#连接导航网格" class="headerlink" title="连接导航网格"></a>连接导航网格</h3><h3 id="支持不同角色类型"><a href="#支持不同角色类型" class="headerlink" title="支持不同角色类型"></a>支持不同角色类型</h3><h3 id="支持不同角色运动"><a href="#支持不同角色运动" class="headerlink" title="支持不同角色运动"></a>支持不同角色运动</h3><h3 id="支持不同角色区域权限"><a href="#支持不同角色区域权限" class="headerlink" title="支持不同角色区域权限"></a>支持不同角色区域权限</h3><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="高级多人游戏"><a href="#高级多人游戏" class="headerlink" title="高级多人游戏"></a>高级多人游戏</h3><ol>
<li><p>高层API vs 底层 API<br>Godot 始终支持通过 UDP、 TCP 和一些更高级别的协议（如 SSL 和 HTTP ）进行标准的低级网络连接。<br>使用 Godot 的高级网络 API，牺牲了对低级网络的一些细度控制，有更强的易用性。</p>
</li>
<li><p>中层抽象<br>Godot 使用了一个中间层级的 MultiplayerPeer 对象。不应直接创建这种对象，它被设计为由多个 C++ 实现所提供。</p>
</li>
</ol>
<p>这个对象扩展自 PacketPeer 类，继承了所有用于序列化、发送和接收数据的方法。<br>此外，该对象还添加了设置对等体、传输模式等方法。它还包括让你知道对等体何时连接或断开的信号。</p>
<p>这个类接口可以抽象出大多数类型的网络层、拓扑结构和库。<br>默认情况下，Godot 会提供一个基于 ENet 的实现（ENetMultiplayerPeer）、一个基于 WebRTC 的实现（WebRTCMultiplayerPeer）以及一个基于WebSocket的实现（WebSocketPeer），而该类接口可以用来实现移动 API（用于特设的 WiFi、蓝牙等）或自定义设备&#x2F;控制台中特定的网络 API。</p>
<p>但大多数常见情况下，不鼓励直接使用这个对象，因为 Godot 提供了更高级别的网络使用方法。<br>只有当游戏对较低级别的API有特殊需求的情况下，才使用该对象。</p>
<ol start="3">
<li>服务器托管的注意事项<br>托管服务器时，LAN 上的客户端可以使用内网 IP 地址进行连接，该地址的格式通常是 192.168.<em>.</em>。 非 LAN&#x2F;Internet 客户端无法访问此内部 IP 地址。</li>
</ol>
<p>在 Windows 中， 你可以在命令提示符中输入 ipconfig 命令， 在 macOS 中，你可以在终端中输入 ifconfig 命令，在 Linux 中，你可以在终端中输入 ip addr 命令，来找到你的内网 IP 地址。</p>
<p>如果你在自己的机器上托管了服务器，并且想让非内网客户端连接，那么你可能需要将服务器端口 转发 到你的路由器，由于大多数家用网络都使用 NAT 技术，因此转发服务器端口是让你的服务器能通过互联网访问的必经步骤。Godot 的高级多人 API 只使用 UDP 协议，所以你的端口转发也必须是 UDP 协议的端口，不能只转发 TCP 协议的端口。</p>
<p>在转发了 UDP 端口之后，你需要确保你的服务器使用这个端口。可以前往这个网站 <a target="_blank" rel="noopener" href="https://icanhazip.com/">https://icanhazip.com/</a>去查询你的公网 IP 地址，然后把这个公网 IP 地址发送给想联机到你服务器的互联网客户端即可。</p>
<p>Godot 的高级多人联机 API 使用的是一个修改过的 ENet，包含全 IPv6 支持。</p>
<p>网络初始化</p>
<h3 id="进行-HTTP-请求"><a href="#进行-HTTP-请求" class="headerlink" title="进行 HTTP 请求"></a>进行 HTTP 请求</h3><h3 id="HTTP-客户端类"><a href="#HTTP-客户端类" class="headerlink" title="HTTP 客户端类"></a>HTTP 客户端类</h3><h3 id="TLS-SSL-证书"><a href="#TLS-SSL-证书" class="headerlink" title="TLS&#x2F;SSL 证书"></a>TLS&#x2F;SSL 证书</h3><h3 id="Using-WebSockets"><a href="#Using-WebSockets" class="headerlink" title="Using WebSockets"></a>Using WebSockets</h3><h3 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><p>要达到最佳效果, 我们有两种方法:</p>
<ol>
<li>工作更快 </li>
<li>工作更智能<br>我们最好将两者混合使用</li>
</ol>
<p>测量性能<br>对于优化来说, 最重要的工具可能是衡量性能的能力–找出瓶颈所在, 并衡量我们突破瓶颈的尝试是否成功.<br>有几种衡量性能的方法, 包括:</p>
<ol>
<li>在感兴趣的代码周围放置一个<strong>开启&#x2F;停止</strong>的计时器.</li>
<li>使用 Godot 分析器。</li>
<li>使用 外部 CPU 分析器。</li>
<li>使用外部 GPU 分析器&#x2F;调试器，例如 NVIDIA Nsight 显卡 ， Radeon GPU 分析器 ， PIX（仅限 Direct3D 12）、 Xcode（仅限 Metal），或 Arm 性能工作室 。</li>
<li>检查帧速率（禁用垂直同步）。第三方实用程序，例如 RivaTuner 统计服务器 （Windows）， Special K（Windows）或 MangoHud （Linux） 在这里也很有用。</li>
<li>使用一个非官方的<code>调试菜单附加组件 &lt;https://github.com/godot-extended-libraries/godot-debug-menu&gt;</code>.<br>在一个以上的设备上测量计时通常是个好主意. 如果你的目标是移动设备, 情况尤其如此.</li>
</ol>
<p>限制<br>CPU分析器通常是测量性能的常用方法. 然而, 它们并不总是能反映全部情况.<br>瓶颈往往在GPU上,”由于”CPU给出的指令.<br>由于在Godot中使用的指令(例如, 动态内存分配)”导致” 操作系统进程(在Godot之外)可能出现巅峰.<br>由于需要进行初始设置, 你可能并不总是能够对特定设备进行配置, 例如手机.<br>你可能需要解决你无法访问的硬件上出现的性能问题.<br>由于这些限制, 你经常需要使用侦测工作来找出瓶颈所在.</p>
<p>侦查工作<br>侦测工作对于开发人员来说是一项至关重要的技能(无论是在性能方面, 还是在错误修复方面).<br>这可以包括假设测试和二进制搜索.</p>
<ul>
<li>假设检验<ul>
<li>精灵</li>
</ul>
</li>
<li>二分查找<ul>
<li>帧</li>
</ul>
</li>
</ul>
<p>分析器<br>分析器允许你在运行程序时对其进行计时.<br>分析器提供结果, 告诉你在不同的功能和区域所花费的时间百分比, 以及功能被调用的频率<br>这对于确定瓶颈和衡量改进的结果都非常有用.<br>有时, 改善性能的尝试可能会适得其反, 导致性能变慢. 始终使用分析器和时长来指导你的工作</p>
<p>原则<br>开发者时间有限. 与其盲目地试图加快一个程序的所有方面, 应该集中精力在真正重要的方面.<br>虽然过早的优化是不可取的, 但高性能的软件是高性能设计的结果.</p>
<p>高性能的设计<br>鼓励人们在必要时再考虑优化的危险在于，它很容易忽略了考虑性能的最重要时间是在设计阶段，甚至在按下键盘按键之前。如果一个程序的设计或算法是低效的，那么以后再多的细节修饰也不会使它运行得很快。它可能运行得更快，但永远不会像一个以性能为设计目标的程序那样快。</p>
<p>这在游戏或图形编程中往往比在一般编程中更为重要. 一个高性能的设计, 即使没有低水平的优化, 通常也会比一个低水平优化的平庸设计快很多倍.</p>
<p>渐进式设计<br>当然, 在实践中, 除非你事先有知识, 否则你不可能在第一次就拿出最好的设计. 相反, 你往往会对某一特定区域的代码做出一系列版本, 每一个版本都采取不同的方法来解决这个问题, 直到你得出一个满意的解决方案. 重要的是, 在你最终确定整体设计之前, 在这个阶段不要在细节上花费太多时间. 否则, 你的很多工作都会被淘汰.</p>
<p>很难给出高性能设计的一般规范，因为这与问题本身有很大关系。不过有一点值得一提，在 CPU 方面，现代 CPU 几乎总是受到内存带宽的限制。这导致了面向数据的设计的重新兴起，涉及到围绕数据的缓存本地性（cache locality）和线性访问进行数据结构和算法的设计，避免在内存中进行跳转。</p>
<p>优化过程<br>假设我们有一个合理的设计, 优化的第一步应该是找出最大的瓶颈–最慢的功能, 可轻松实现的目标.<br>一旦我们成功地提高了最慢区域的速度, 它可能就不再是瓶颈了. 因此, 我们应该再次进行测试&#x2F;分析, 找到下一个需要关注的瓶颈.</p>
<p>因此, 该过程是:<br>分析和确定瓶颈.<br>优化瓶颈.<br>返回步骤1.</p>
<p>优化瓶颈<br>有些分析器甚至会告诉你一个函数的哪个部分在减慢速度(哪些数据访问, 计算).<br>与设计一样，您应该首先集中精力确保算法和数据结构达到最佳状态。数据访问应该是本地的（以充分利用 CPU 缓存），并且使用紧凑的数据存储通常会更好（同样，始终分析以测试结果）。通常，您会提前预先计算繁重的计算。这可以通过在加载关卡时执行计算、加载包含预计算数据的文件或将复杂计算的结果存储到脚本常量中并读取其值来完成。</p>
<p>如果确认算法和数据没有问题，你通常可以在例程中做一些小的改变来提高性能。例如，可以将一些计算移到循环之外，或者将嵌套的 for 循环转化为非嵌套的循环。（如果你事先知道 2D 数组的宽和高，应该就是可行的。）</p>
<p>每次更改后, 一定要重新测试你的时长和瓶颈. 有些改变会提高速度, 有些则可能会产生负面效果. 有时, 一个小的积极效果会被更复杂的代码的负面效果所抵消, 可以选择不做这种优化.</p>
<p>利用服务器进行优化<br>服务器<br>Godot 有许多非常有趣的设计决定，其中之一就是整个场景系统都是可选的。<br>虽然目前还不能在编译时去除，但你完全可以绕过它。</p>
<p>Godot 在核心中使用了“服务器”的概念。<br>它们是非常底层的 API，用来控制渲染、物理、声音等。<br>场景系统建立在它们之上，直接使用它们。最常见的服务器有：</p>
<ul>
<li>RenderingServer: 处理所有与图形相关的内容。</li>
<li>PhysicsServer3D: 处理所有与 3D 物理相关的内容。</li>
<li>PhysicsServer2D: 处理所有与 2D 物理相关的内容。</li>
<li>AudioServer: 处理与音频相关的一切.<br>你只需研究它们的 API 就会意识到，它们所提供的函数全部都是 Godot 允许你所进行的操作的底层实现。</li>
</ul>
<p>RID<br>使用服务器的关键是理解资源 ID（Resource ID，即 RID）对象。<br>这些对象是服务器实现的非公开的句柄。它们是手动分配和释放的。<br>几乎服务器中的每个功能都需要 RID 来访问实际的资源。</p>
<p>大多数 Godot 节点和资源都包含这些来自服务内部的 RID，它们可以通过不同的函数获得。<br>事实上，任何继承 <code>Resource</code> 的东西都可以直接转换成 RID。<br>不过并不是所有资源都包含 RID：在这种情况下，RID 为空。可以用 RID 的形式将资源传递给服务器 API。</p>
<p>警告<br>资源是引用计数的（见 RefCounted），对资源 RID 的引用在确定资源仍在使用时不进行计数。请确保在服务器外部保持对资源的引用，否则将删除资源及其 RID。</p>
<p>对于节点来说, 有很多函数功能可以使用:</p>
<ol>
<li><p>对于 CanvasItem，CanvasItem.get_canvas_item() 方法将在服务器中返回该画布项目的 RID。</p>
</li>
<li><p>对于CanvasLayer来说, CanvasLayer.get_canvas() 方法将返回服务器中的canvas RID.</p>
</li>
<li><p>对于 CanvasLayer 来说, CanvasLayer.get_canvas() 方法将返回服务器中的 canvas RID.</p>
</li>
<li><p>对于视口, Viewport.get_viewport_rid() 方法将返回服务器中的视口RID.</p>
</li>
<li><p>对于视口, Viewport.get_viewport_rid() 方法将返回服务器中的视口 RID.</p>
</li>
<li><p>对于 3D，World3D 资源（可在 Viewport 和 Node3D 节点中获取）包含获取 RenderingServer 场景和 PhysicsServer 空间的函数。这允许直接使用服务器 API 创建 3D 对象并使用它们。</p>
</li>
<li><p>对于 3D，World3D 资源（可在 Viewport 和 Node3D 节点中获取）包含获取 RenderingServer 场景和 PhysicsServer 空间的函数。 这允许直接使用服务器 API 创建 3D 对象并使用它们。</p>
</li>
<li><p>对于 2D，World2D 资源（可在 Viewport 和 CanvasItem 节点中获取）包含获取 RenderingServer 画布和 Physics2DServer 空间的函数。这允许直接使用服务器 API 创建 2D 对象并使用它们。</p>
</li>
<li><p>于 2D，World2D 资源（可在 Viewport 和 CanvasItem 节点中获取）包含获取 RenderingServer 画布和 Physics2DServer 空间的函数。 这允许直接使用服务器 API 创建 2D 对象并使用它们。</p>
</li>
<li><p>VisualInstance3D 类允许分别通过 VisualInstance3D.get_instance() 和 VisualInstance3D.get_base() 获取场景 instance 和 instance base。</p>
</li>
<li><p>VisualInstance3D 类允许分别通过 VisualInstance3D.get_instance（） 和 VisualInstance3D.get_base（） 获取场景 实例和 实例 base。</p>
</li>
</ol>
<p>请尝试探索你所熟悉的节点和资源，找到获得服务器 RID 的功能。<br>不建议控制已经有节点关联的对象的 RID。服务器函数应始终用于创建和控制新的对象、与现有对象进行交互。</p>
<p>创建精灵<br>这是一个如何从代码创建精灵并使用低级 CanvasItem API 移动它的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extends Node2D</span><br><span class="line"></span><br><span class="line"># 渲染服务器期望引用被持续保留。var texture</span><br><span class="line">func _ready():</span><br><span class="line">	# Create a canvas item, child of this node.</span><br><span class="line">	var ci_rid = RenderingServer.canvas_item_create()</span><br><span class="line">	# Make this node the parent.</span><br><span class="line">	RenderingServer.canvas_item_set_parent(ci_rid, get_canvas_item())</span><br><span class="line">	# Draw a texture on it.</span><br><span class="line">	# Remember, keep this reference.</span><br><span class="line">	texture = load(&quot;res://my_texture.png&quot;)</span><br><span class="line">	# Add it, centered.</span><br><span class="line">	RenderingServer.canvas_item_add_texture_rect(ci_rid, Rect2(-texture.get_size() / 2, texture.get_size()), texture)</span><br><span class="line">	# Add the item, rotated 45 degrees and translated.</span><br><span class="line">	var xform = Transform2D().rotated(deg_to_rad(45)).translated(Vector2(20, 30))</span><br><span class="line">	RenderingServer.canvas_item_set_transform(ci_rid, xform)</span><br></pre></td></tr></table></figure>
<p>服务器中的 Canvas Item API 允许你向其添加绘制图元。一旦添加，它们就不能被修改。需要清除 Item，并重新添加图元（设置变换时则不然，变换可根据需要多次进行）。</p>
<p>图元的清除方式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RenderingServer.canvas_item_clear(ci_rid)</span><br></pre></td></tr></table></figure>

<p>将网格实例化到 3D 空间<br>3D API 与 2D API 不同，所以必须使用实例化 API。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extends Node3D</span><br><span class="line"></span><br><span class="line"># 渲染服务器期望引用被持续保留。var mesh</span><br><span class="line">func _ready():</span><br><span class="line">	# Create a visual instance (for 3D).</span><br><span class="line">	var instance = RenderingServer.instance_create()</span><br><span class="line">	# Set the scenario from the world, this ensures it</span><br><span class="line">	# appears with the same objects as the scene.</span><br><span class="line">	var scenario = get_world_3d().scenario</span><br><span class="line">	RenderingServer.instance_set_scenario(instance, scenario)</span><br><span class="line">	# Add a mesh to it.</span><br><span class="line">	# Remember, keep the reference.</span><br><span class="line">	mesh = load(&quot;res://mymesh.obj&quot;)</span><br><span class="line">	RenderingServer.instance_set_base(instance, mesh)</span><br><span class="line">	# Move the mesh around.</span><br><span class="line">	var xform = Transform3D(Basis(), Vector3(20, 100, 0))</span><br><span class="line">	RenderingServer.instance_set_transform(instance, xform)</span><br></pre></td></tr></table></figure>

<p>创建 2D 刚体并使用它移动精灵<br>这段代码使用 <code>PhysicsServer2D</code> API 创建了一个 <code>RigidBody2D</code>，并在该物体移动时移动 <code>CanvasItem</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Physics2DServer expects references to be kept around.</span><br><span class="line">var body</span><br><span class="line">var shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _body_moved(state, index):</span><br><span class="line">	# Created your own canvas item, use it here.</span><br><span class="line">	RenderingServer.canvas_item_set_transform(canvas_item, state.transform)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	# Create the body.</span><br><span class="line">	body = Physics2DServer.body_create()</span><br><span class="line">	Physics2DServer.body_set_mode(body, Physics2DServer.BODY_MODE_RIGID)</span><br><span class="line">	# Add a shape.</span><br><span class="line">	shape = Physics2DServer.rectangle_shape_create()</span><br><span class="line">	# Set rectangle extents.</span><br><span class="line">	Physics2DServer.shape_set_data(shape, Vector2(10, 10))</span><br><span class="line">	# Make sure to keep the shape reference!</span><br><span class="line">	Physics2DServer.body_add_shape(body, shape)</span><br><span class="line">	# Set space, so it collides in the same space as current scene.</span><br><span class="line">	Physics2DServer.body_set_space(body, get_world_2d().space)</span><br><span class="line">	# Move initial position.</span><br><span class="line">	Physics2DServer.body_set_state(body, Physics2DServer.BODY_STATE_TRANSFORM, Transform2D(0, Vector2(10, 20)))</span><br><span class="line">	# Add the transform callback, when body moves</span><br><span class="line">	# The last parameter is optional, can be used as index</span><br><span class="line">	# if you have many bodies and a single callback.</span><br><span class="line">	Physics2DServer.body_set_force_integration_callback(body, self, &quot;_body_moved&quot;, 0)</span><br></pre></td></tr></table></figure>
<p>3D 版本应该非常相似，因为 2D 和 3D 物理服务器是相同的（分别使用 RigidBody3D 和 PhysicsServer3D）。</p>
<p>从服务器获取数据<br>除非你知道自己在做什么，否则请尽量永远不要通过调用函数从 RenderingServer、PhysicsServer2D 或 PhysicsServer3D 请求任何信息。这些服务器通常会异步运行以提高性能，调用任何返回值的函数都会使它们停滞，并迫使它们处理任何待处理的内容，直到实际调用该函数。如果你每帧都调用它们，这将严重降低性能（而且原因并不明显）。</p>
<p>正因为如此, 这类服务器中的大部分API都被设计成连信息都无法请求回来, 直到这是可以保存的实际数据.</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>对于 CPU 来说，找出瓶颈的最简单方法就是使用性能剖析器。</p>
<p>CPU 分析器<br>剖析器与你的程序一起运行, 并进行时间测量, 以计算出每个功能所花费的时间比例.<br>Godot集成开发环境有一个方便的内置剖析器. 它不会在每次启动项目时运行: 必须手动启动和停止. 这是因为, 与大多数剖析器一样, 记录这些时序测量会大大减慢你的项目速度.<br>剖析后, 你可以回看一帧的结果.</p>
<p>备注<br>我们可以看到物理, 音频等内置流程的消耗, 也可以在底部看到自己脚本功能的消耗.<br>等待各种内置服务器的时间可能不会被计算在剖析器中. 这是一个已知的错误.</p>
<p>外部分析器<br>虽然Godot IDE剖析器非常方便有用, 但有时你需要更强大的功能, 以及对Godot引擎源代码本身进行剖析的能力.<br>你可以 使用若干个第三方 C++ 分析器 来实现。</p>
<p>手动计时函数<br>另一个方便的技术, 特别是当你使用分析器确定了瓶颈后, 就是手动为功能或被测区域计时. 具体细节因语言而异, 但在GDScript中, 你可以做如下操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var time_start = Time.get_ticks_usec()</span><br><span class="line"></span><br><span class="line"># Your function you want to time</span><br><span class="line">update_enemies()</span><br><span class="line"></span><br><span class="line">var time_end = Time.get_ticks_usec()</span><br><span class="line">print(&quot;update_enemies() took %d microseconds&quot; % time_end - time_start)</span><br></pre></td></tr></table></figure>
<p>当手动为函数计时时, 通常最好是多次(1000次或更多次)运行该函数, 而不是只运行一次(除非是非常慢的函数). 这样做的原因是, 定时器的精度往往有限. 此外,CPU会以一种无序的方式调度进程. 因此, 一系列运行的平均值比单次测量更准确.<br>当你尝试优化功能时, 一定要反复对它们进行剖析或计时. 这将为你提供关键的反馈, 说明优化是否有效(或无效).</p>
<p>缓存<br>CPU缓存是另外一个需要特别注意的东西, 特别是在比较一个函数的两个不同版本的时序结果时. 其结果可能高度依赖于数据是否在CPU缓存中.CPU不会直接从系统RAM中加载数据, 尽管它与CPU缓存相比非常巨大(几千兆字节而不是几兆字节). 这是因为系统RAM的访问速度非常慢. 相反,CPU从一个较小, 较快的内存库中加载数据, 称为cache. 从缓存中加载数据的速度非常快, 但每次你试图加载一个没有存储在缓存中的内存地址时, 缓存必须前往主内存并缓慢地加载一些数据. 这种延迟会导致CPU长时间闲置, 被称为 “cache miss”.</p>
<p>这意味着, 第一次运行一个函数时, 由于数据不在CPU缓存中, 它可能运行得很慢. 第二次和以后的时间, 可能运行得更快, 因为数据在缓存中. 由于这个原因, 在计时时一定要使用平均数, 并且要注意缓存的影响.</p>
<p>了解缓存对于CPU优化也是至关重要的. 如果你有一个算法(例程), 从主内存随机分布的区域加载小数据位, 这可能会导致大量的缓存失误, 很多时候,CPU会在附近等待数据, 而不是做别的工作. 相反, 如果你能使你的数据访问本地化, 或者更好的是以线性方式访问内存(像一个连续的列表), 那么缓存将以最佳方式工作,CPU将能够尽可能快地工作.</p>
<p>Godot 通常会为你处理这些底层细节。例如，服务器 API 会确保数据已经针对渲染和物理等方面的缓存进行了优化。不过在编写 GDExtensions 时，你还是需要格外留意缓存问题。</p>
<p>线程<br>在进行大量的计算时, 考虑使用线程, 这些计算可以相互并行运行. 现代CPU有多个核心, 每个核心能做的工作量有限. 通过将工作分散在多个线程上, 你可以进一步向CPU的峰值效率迈进.</p>
<p>线程的缺点是，你必须非常小心。由于每个 CPU 核心都是独立运行的，它们最终可能会在同一时间试图访问相同的内存。一个线程可以在另一个线程在写入变量的时候读取该变量：这被称为竞态条件。在你使用线程之前，请确保你了解这些危险以及如何尝试和防止这些竞态条件。线程会使调试变得更加困难。</p>
<p>SceneTree<br>在 Godot 渲染器中，每个节点都是单独处理的。因此，减少节点的数量、让每个节点多做一些工作，可以获得更好的性能。<br>SceneTree 比较奇怪的一点是：你有时可以通过从 SceneTree 中删除节点，而非暂停或隐藏节点这种方式来获得更好的性能，不一定要删除一个从场景树中分离出来的的节点。例如，你可以保留一个节点的引用，使用 Node.remove_child(node) 将该节点从场景树中分离出来，然后使用 Node.add_child(node) 将其重新加回场景树。对于在游戏中添加和删除区域，这一点十分有用。</p>
<p>你可以通过使用服务器API来完全避免使用 SceneTree。</p>
<p>物理<br>以下是一些加速物理的技巧：</p>
<ul>
<li>尝试使用渲染简单的几何图形来处理碰撞形状，虽然在通常情况下对终端用户来说这一点并不明显，但可以大大提高性能。</li>
<li>尝试禁用不在视野中&#x2F;在当前区域之外的物理物体的物理效果，在视野中&#x2F;在当前区域之内时则给这些物理对象启用物理效果（例如，你允许每个区域有8个怪物，并允许重新启用这些怪物的物理效果）。</li>
</ul>
<p>物理的另一个关键方面是物理刻速率。在一些游戏中，你可以大大降低物理刻率，比如说，你可以不用每秒更新物理 60 次，而只需每秒更新 30 次甚至 20 次。这样可以大大降低 CPU 的负载。</p>
<p>改变物理刻速率的缺点是，当物理更新速率与每秒渲染的帧数不匹配时，可能会出现抖动。另外，降低物理刻速率会增加输入延迟。建议在大多数以玩家实时移动为特色的游戏中，坚持使用默认的物理刻速率（60 Hz）。</p>
<p>抖动的解决方案是使用固定时间步长插值， 其中涉及 平滑多个帧的渲染位置和旋转，以匹配 物理。Godot 具有内置的物理插值，您可以阅读有关 这里 。在性能方面，与运行物理滴答相比，插值是一个非常便宜的作。它的速度快了几个数量级，因此这可以显着提高性能，同时还可以减少抖动。</p>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>了解和调查GPU瓶颈与CPU上的情况略有不同. 这是因为, 通常情况下, 你只能通过改变你给GPU的指令来间接改变性能. 另外, 测量起来可能更困难. 在许多情况下, 衡量性能的唯一方法是通过检查每帧渲染时间的变化.</p>
<p>绘制调用、状态更变、API<br>Godot 通过图形 API（Vulkan、OpenGL、OpenGL ES 或 WebGL）向 GPU 发送指令。<br>期间涉及到的通信和驱动流程可能存在相当大的开销，使用 OpenGL、OpenGL ES 和 WebGL 时尤为明显。<br>如果我们能以驱动和 GPU 喜欢的方式提供这些指令，就可以大大提升性能。</p>
<p>OpenGL中几乎每一个API命令都需要一定的验证, 以确保GPU处于正确的状态.<br>即使是看似简单的命令, 也会导致一连串的幕后工作.<br>因此, 我们的目标是将这些指令减少到最低限度, 并尽可能地将相似的对象分组, 以便它们可以一起渲染, 或者以最少的数量进行这些昂贵的状态变化.</p>
<p>2D<br>在 2D 中，单独处理每个项目的成本可能高得令人望而却步——屏幕上很容易有数千个项目。这就是 2D 批处理的原因 被使用。将多个相似项分组 一起并通过单个绘制调用批量渲染，而不是进行 每个项目单独的抽奖调用。此外，这意味着状态变化， 材料和纹理的变化可以保持在最低限度。</p>
<p>3D<br>在 3D 中，我们的目标仍然是尽量减少绘制调用和状态更改。但是，将多个对象批量合并到单个绘制调用中可能会更加困难。3D 网格往往包含数百或数千个三角形，而实时组合大型网格的成本非常高。随着每个网格的三角形数量增加，加入它们的成本很快就会超过任何收益。一个更好的选择是提前加入网格（彼此相关的静态网格）。这可以由设计师完成，也可以使用插件在 Godot 中以编程方式完成。<br>在 3D 中将对象批处理在一起也是有成本的。渲染为一个的多个对象不能单独剔除。如果将屏幕外的整个城市连接到屏幕上的一片草叶，则仍将被渲染。因此，在尝试将 3D 对象批处理在一起时，应始终考虑对象的位置和剔除。尽管如此，连接静态对象的好处通常超过其他考虑因素，特别是对于大量远处或低多边形对象。</p>
<p>复用着色器和材质<br>Godot 渲染器和其它的渲染器不同，是以尽量减少 GPU 状态更改为目标的。StandardMaterial3D 可以在所需着色器相似时很好地复用材质。如果是用自定义着色器，那么请尽量进行复用。Godot 的优先级是：</p>
<p>复用材质：场景中不同的材质越少, 渲染的速度就越快. 如果一个场景有大量的物体(数以百计或数以千计), 可以尝试重复使用这些材质. 在最坏的情况下, 使用图集来减少纹理变化的数量.</p>
<p>复用着色器：如果材质无法复用，至少要尝试复用着色器。注意：即使 StandardMaterial3D 具有不同的参数，共享相同配置（可用勾选框启用或禁用该功能）的 StandardMaterial3D 之间也会自动复用着色器。</p>
<p>例如，如果一个场景中有 20,000 个物体，每个物体有 20,000 种不同的材质，渲染就会很慢。如果同一个场景中有 20,000 个物体，但只使用 100 种材质，渲染就会快得多。</p>
<p>像素成本与顶点成本<br>你可能听说过, 一个模型中的多边形数量越少, 它的渲染速度就越快. 这其实是 相对的 , 取决于许多因素.</p>
<p>在现代PC和控制台, 顶点成本很低.GPU最初只渲染三角形. 这意味着每一帧:</p>
<p>所有顶点都必须由 CPU 进行转换（包括剪裁）。</p>
<p>所有顶点都必须从主 RAM 发送到 GPU 内存。</p>
<p>如今，所有这些都在 GPU 内部处理，大大提高了性能。3D 设计师通常对多边形计数性能有错误的感觉，因为 3D 建模软件（如 Blender、3ds Max 等）需要将几何图形保存在 CPU 内存中才能进行编辑，从而降低了实际性能。游戏引擎更多地依赖 GPU，因此它们可以更高效地渲染许多三角形。</p>
<p>在移动设备上, 情况则不同. 个人电脑和控制台的GPU是粗暴的怪物, 可以从电网中获取所需的电力. 移动GPU被限制在一个很小的电池里, 所以它们需要更高的功率效率.</p>
<p>为了提高工作效率, 移动GPU试图避免 overdraw . 当屏幕上的同一个像素被渲染了不止一次时, 就会出现Overdraw. 想象一下, 一个有几座建筑的小镇. 在绘制之前,GPU不知道哪些是可见的, 哪些是隐藏的. 例如, 一栋房子可能被画出来, 然后在它前面又画了一栋房子(这意味着同一像素的渲染发生了两次).PC GPU通常不怎么关心这个问题, 只是把更多的像素处理扔给硬件以提高性能(这也会增加功耗).</p>
<p>在移动设备上使用更多的电力是不可能的，所以移动设备使用一种叫做基于图块的渲染的技术，将屏幕划分为一个网格。每个单元格都保存着绘制的三角形列表，并按深度进行排序，以尽量减少过度绘制。这种技术提高了性能，降低了功耗，但对顶点性能造成了影响。因此，可以处理更少的顶点和三角形进行绘制。</p>
<p>此外，当屏幕的一小部分区域内存在包含大量几何体的小物体时，基于分块的渲染会遇到困难。这会迫使移动 GPU 对单个屏幕单元施加很大的压力，从而显著降低性能，因为所有其他单元必须等待该单元完成后才能显示当前帧。</p>
<p>总而言之, 在移动端不要担心顶点数量, 但 避免顶点集中在屏幕的一小部分 . 如果一个角色, NPC, 车辆等离得很远(这意味着它看起来很小), 就使用一个较小的细节级别模型(LOD). 即使在桌面GPU上, 最好也不要让三角形小于屏幕上一个像素的大小.</p>
<p>使用时要注意额外的顶点处理：</p>
<p>蒙皮（骨骼动画）</p>
<p>变形（形态键）</p>
<p>Vertex-lit objects (common on mobile)<br>顶点光照对象（在移动设备上常见）</p>
<p>像素&#x2F;片段着色器和填充速率<br>与顶点处理相比，片段（每像素）着色的成本历年来急剧增加。屏幕分辨率已经提高：4K 屏幕的面积为 8,294,400 像素，而旧式 640×480 VGA 屏幕的面积为 307,200 像素。面积是 27 倍！此外，片段着色器的复杂性也呈爆炸式增长。基于物理的渲染需要对每个片段进行复杂的计算。</p>
<p>你可以很容易地测试一个项目是否受到填充率限制. 关闭V-Sync以防止每秒帧数的上限, 然后比较使用大窗口运行时的每秒帧数和使用非常小的窗口运行时的帧数. 如果使用阴影, 你也可以从同样减少阴影贴图大小中获益. 通常, 你会发现使用小窗口的FPS会增加不少, 这说明你在某种程度上受到了填充率的限制. 另一方面, 如果FPS几乎没有增加, 那么你的瓶颈就在其他地方.</p>
<p>您可以通过减少 GPU 必须执行的工作量来提高填充率受限项目的性能。为此，你可以简化着色器（如果你使用的是 StandardMaterial3D，则可能会关闭昂贵的选项），或者减少所用纹理的数量和大小。此外，当使用非着色粒子时，请考虑在其材质中强制顶点着色，以降低着色成本。</p>
<blockquote>
<p>在支持的硬件上，可以使用 可变速率着色 降低着色过程的损耗，并且不影响最终图片边缘的锐度。<br>在针对移动设备时, 考虑使用你能合理负担得起的最简单的着色器.</p>
</blockquote>
<p>读取纹理<br>片段着色器的另一个因素是读取纹理的成本。读取纹理是一项昂贵的操作，尤其是在一个片段着色器中从多个纹理中读取时。另外，考虑到过滤可能会进一步减慢它的速度（mipmap 之间的三线性过滤，以及平均）。读取纹理在功耗方面也很昂贵，这在手机上是个大问题。</p>
<p>如果你使用第三方着色器或编写自己的着色器, 请尽量使用需要尽可能少的纹理读取的算法.</p>
<p>纹理压缩<br>默认情况下,Godot在导入3D模型时使用视频RAM(VRAM)压缩来压缩纹理. 视频RAM压缩在存储时不如PNG或JPG有效, 但在绘制足够大的纹理时, 会极大地提高性能.</p>
<p>这是因为纹理压缩的主要目标是在内存和GPU之间减少带宽.</p>
<p>在3D中, 物体的形状更多地取决于几何体而不是纹理, 所以压缩一般不明显. 在2D中, 压缩更多的是取决于纹理内部的形状, 所以2D压缩产生的伪影比较明显.</p>
<p>作为警告, 大多数Android设备不支持具有透明度的纹理的纹理压缩(仅不透明), 因此请记住这一点.</p>
<p>备注</p>
<p>即便在 3D 中，“像素画”纹理也应该禁用 VRAM 压缩，因为压缩会对外观产生负面影响，较低的分辨率也无法得到显著的性能提升。</p>
<p>后期处理和阴影<br>就片段着色活动而言, 后期处理效果和阴影也可能很昂贵. 始终测试这些对不同硬件的影响.</p>
<p>减少阴影图的大小可以提高性能 , 无论是在写还是读取阴影贴图方面. 除此之外, 提高阴影性能的最好方法是关闭尽可能多的灯光和物体的阴影. 较小或较远的OmniLights&#x2F;SpotLights通常可以禁用它们的阴影, 而对视觉影响很小.</p>
<p>透明度和混合<br>透明物体对渲染效率带来了特殊的问题. 不透明的对象(尤其是在3D中)基本上可以以任意顺序渲染,Z-缓冲区将确保只有最前面的对象得到阴影. 透明或混合对象则不同, 在大多数情况下, 它们不能依赖Z-缓冲区, 必须以 “画家顺序”(即从后到前)渲染才能看起来正确.</p>
<p>透明对象的填充率也特别差, 因为每一个项目都要绘制, 即使之面会在上面绘制其他透明对象.</p>
<p>不透明的对象不需要这样做. 它们通常可以利用Z-缓冲区, 只先向Z-缓冲区写入数据, 然后只在 “胜利” 的片段上执行片段着色器, 也就是在某一像素处处于前面的对象.</p>
<p>在多个透明对象重叠的情况下, 透明度特别昂贵. 通常情况下, 使用透明区域越小越好, 以尽量降低这些填充率要求, 尤其是在移动端. 事实上, 在很多情况下, 渲染更复杂的不透明几何体最终可能比使用透明度来 “作弊” 更快.</p>
<p>多平台建议<br>如果你的目标是在多个平台上发布，请尽早在所有平台上（尤其是移动平台上）进行经常性得测试。在桌面上开发游戏，但在最后一刻试图将其移植到移动设备，这是灾难的根源。</p>
<p>一般来说，你应该针对最低的共性设计游戏，然后为更强大的平台添加可选的增强功能。例如，你可能希望在同时针对桌面和移动平台的情况下，使用兼容性渲染方法。</p>
<p>移动端和图块渲染<br>如上所述, 移动设备上的GPU与桌面上的GPU工作方式有很大不同. 大多数移动设备都使用图块渲染器. 图块渲染器将屏幕分割成规则大小的图块, 这些图块可以放入超快的缓存中, 从而减少了对主内存的读和写操作次数.</p>
<p>不过也有一些缺点. 图块渲染会让某些技术变得更加复杂, 执行起来也更加昂贵. 依赖于不同图块渲染的结果, 或者依赖于早期操作的结果被保存的图块可能会非常慢. 要非常小心地测试着色器, 视图纹理和后期处理的性能.</p>
<p>使用 MultiMesh 优化<br>对于需要不断处理（且保留一定控制的）大量实例（成千上万），建议直接使用服务器进行优化。</p>
<p>当对象数量达到数十万或数百万时, 这些方法都不再有效. 尽管如此, 根据要求, 还有另一种可能的优化方法.</p>
<h3 id="3D-1"><a href="#3D-1" class="headerlink" title="3D"></a>3D</h3><p>剔除<br>Godot会自动执行视图视锥剔除, 以防止渲染视口外的物体. 这对于发生在小范围内的游戏来说效果很好, 然而在较大的关卡中, 事情很快就会变得很麻烦.</p>
<p>遮挡剔除<br>比如走在一个小镇上, 你可能只能看到你所在的街道上的几栋建筑, 以及天空和几只飞过头顶的鸟. 然而就一个天真的渲染器而言, 你仍然可以看到整个小镇. 它不会只渲染你前面的建筑, 它会渲染那后面的街道, 与那条街上的人, 那后面的建筑. 你很快就会遇到这样的情况: 你试图渲染比可见的东西多10倍或100倍的东西.</p>
<p>事情并没有看上去那么糟糕，因为 Z 缓冲区通常允许 GPU 仅完全遮蔽位于前方的物体。这被称为深度预处理，且在使用 Forward+ 或 Compatibility 渲染方法时 Godot 会默认启用。但是，不需要的对象仍然会降低性能。</p>
<p>我们可以减少渲染量的一种方法是利用遮挡 。Godot 4.0 及更高版本提供了一种使用遮挡器节点进行遮挡剔除的新方法。请参阅遮挡剔除 ，了解有关在场景中设置遮挡剔除的说明。</p>
<p>备注<br>在某些情况下，你可能需要调整关卡设计以增加更多遮挡机会。例如，你可能需要添加更多墙壁以防止玩家看得太远，否则会因失去遮挡剔除的机会而降低性能。</p>
<p>透明物体<br>Godot通过 Material 和 Shader 对对象进行排序以提高性能. 然而, 这对透明物体来说是不可能的. 透明物体从后往前渲染, 以便与后面的物体混合. 因此, 尽量少使用透明对象 . 如果一个物体有一小部分是透明的, 尽量让这部分成为一个独立的表面, 有自己的材质.</p>
<p>更多信息请参阅 GPU 优化 文档。</p>
<p>细节程度（LOD）<br>在某些情况下, 特别是在远处, 用简单的版本**代替复杂的几何图形可能是个好主意. 最终用户可能看不出什么区别. 考虑看看远处的大量树木. 有几种策略可以替换不同距离的模型. 你可以使用较低的多边形模型, 或者使用透明度来模拟更复杂的几何体.</p>
<p>Godot 4 提供了多种控制细节层次的方法：</p>
<p>使用 网格的细节级别（LOD） 进行网格导入的自动方法。</p>
<p>在3D节点中使用 可见范围（HLOD） 配置的手动方法。</p>
<p>Decals 和 lights 也可以使用它们各自的 Distance Fade 属性从细节级别中获益。</p>
<p>虽然它们可以单独使用，但一起使用时这些方法最有效。例如，你可以设定可见范围来隐藏距离玩家太远而无法注意到的粒子效果。同时，你可以依靠网格LOD来使粒子效果的网格在远处算绘时细节较少。</p>
<p>可见范围也是为远处几何体设定冒充者的好方法（见下文）。</p>
<p>Billboard 和 imposter<br>使用透明度处理 LOD 的最简单版本是广告牌。例如，你可以使用单个透明四边形来表示远处的一棵树。除非彼此前面有很多棵树，否则这可以非常便宜地渲染。在这种情况下，透明度可能会开始侵蚀填充率（有关填充率的更多信息，请参阅《GPU 优化》）。</p>
<p>另一种方法是不只渲染一棵树, 而是将一些树作为一组来渲染. 如果你能看到一个区域, 但在游戏中不能实际接近它, 这可能是特别有效的.</p>
<p>你可以通过预先渲染对象的不同角度的视图来制作冒牌货. 或者你甚至可以更进一步, 周期性地将一个物体的视图重新渲染到一个纹理上, 作为一个冒牌货使用. 在远处, 你需要将观察者移动相当长的距离, 视角才会发生显著变化. 这可能是复杂的工作, 但可能是值得的, 这取决于你正在制作的项目类型.</p>
<p>Use automatic instancing<br>使用自动实例化 <br>This is only implemented in the Forward+ renderer, not Mobile or Compatibility.<br>这仅在 Forward+ 渲染器中实现，而不是在移动或兼容性中实现。</p>
<p>If you have many identical objects in your scene, you can use automatic instancing to reduce the number of draw calls. This automatically happens for MeshInstance3D nodes that use the same mesh and material: no manual setup is required.<br>如果场景中有许多相同的对象，则可以使用自动实例化来减少绘制调用的数量。对于使用相同网格和材质的 MeshInstance3D 节点，这会自动发生：无需手动设置。</p>
<p>For automatic instancing to be effective, the material must be opaque or alpha-tested (alpha scissor or alpha hash). Alpha-blended or depth pre-pass materials are never instanced this way. Instead, you must use MultiMesh as described below.<br>要使自动实例化有效，材质必须是不透明的或经过 alpha 测试（alpha 剪刀或 alpha 哈希）。Alpha 混合或深度预传递材质永远不会以这种方式实例化。相反，你必须使用 MultiMesh，如下所述。</p>
<p>Use manual instancing (MultiMesh)<br>使用手动实例化（MultiMesh）<br>如果必须在同一地点或附近绘制多个相同的对象, 请尝试使用 MultiMesh 来代替.MultiMesh允许以很小的性能代价来绘制成千上万的对象, 这使得它非常适合用于绘制羊群, 草地, 粒子以及其他任何有成千上万相同对象的地方.</p>
<p>另请参阅《使用 MultiMesh》文档。</p>
<p>烘焙照明<br>照明对象是最昂贵的渲染操作之一。实时照明、阴影（尤其是多个光源）和全局光照都特别昂贵。对于低功耗的移动设备来说，它们可能简化得太多而无法处理。</p>
<p>考虑使用烘焙照明，尤其是移动设备。这看起来很棒，但缺点是它不是动态的。有时，这是值得做出的权衡。</p>
<p>有关使用烘焙光照贴图的说明，请参阅 使用光照贴图全局照明。为了获得最佳性能，你应该将灯光的烘焙模式设置为Static（静态），而不是默认的Dynamic（动态），因为这将跳过具有烘焙光照的网格上的实时光照。</p>
<p>使用 Static 烘焙模式的灯光的缺点是，它们无法将阴影投射到具有烘焙照明的网格上。这可以使具有室外环境和动态对象的场景看起来平坦。性能和质量之间的良好平衡是 DirectionalLight3D 节点保持 Dynamic，并对大多数（如果不是全部）泛光灯和聚光灯使用 Static。</p>
<p>动画和皮肤<br>在某些平台上，动画和顶点动画（例如蒙皮和变形）可能非常昂贵。你可能需要大幅降低动画模型的多边形数量，或限制任意时间在屏幕上的模型数量。你还可以降低远处或遮挡网格的动画速率，或者如果玩家不太可能注意到动画被停止时完全暂停动画。</p>
<p>VisibleOnScreenEnabler3D 和 VisibleOnScreenNotifier3D 节点可用于此目的。</p>
<p>庞大的世界<br>如果你要制作大型游戏, 则与小型游戏可能会有所不同.</p>
<p>大型的世界可能需要用碎片建立, 可以在你在世界中移动时按需加载, 这可以防止内存使用失控, 也可以将所需的处理限制在局部区域.</p>
<p>由于大型世界中的浮点错误，渲染和物理也可能出现故障。可以使用 大世界坐标 解决该问题。如果无法使用大型世界坐标，你可以使用一些技术，例如围绕玩家定位世界（而不是相反），或定期移动原点以使事物以 Vector3(0, 0, 0) 为中心。</p>
<p>用 MultiMeshInstance3D 动画化数以千计条鱼<br>本教程探索了游戏 ABZU 中使用的一种技术, 该技术使用顶点动画和静态网格实例, 来渲染和制作成千上万的鱼动画.<br>在 Godot 中，这可以通过自定义着色器和  MultiMeshInstance3D 来实现。使用以下技术，即使在低端硬件上，也可以渲染数千个动画对象。<br>我们将从一条鱼的动画开始. 然后, 我们将看到如何将该动画扩展到数千条鱼.</p>
<p>动画化一条鱼<br>我们将从单条鱼开始。将鱼模型加载到 MeshInstance3D 中，然后添加一个新的 ShaderMaterial。<br>这是我们用于示例图像的鱼，你可以使用任何你喜欢的鱼模型。<br>本教程中的鱼模型由 QuaterniusDev 制作，并以知识共享许可共享。CC0 1.0 通用 (CC0 1.0) 公共领域贡献 <a target="_blank" rel="noopener" href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a></p>
<p>通常，你会使用骨骼和 Skeleton3D 来为对象制作动画。但是，骨骼是在 CPU 上进行动画处理的，因此您最终必须每帧计算数千个作，并且不可能拥有数千个对象。在顶点着色器中使用顶点动画，可以避免使用骨骼，而是可以在几行代码中完全在 GPU 上计算完整的动画。</p>
<p>动画由四个关键帧动作组成:</p>
<ol>
<li>从一边运动到另一边</li>
<li>绕着鱼的中心作旋转运动</li>
<li>平移波动运动</li>
<li>平移扭转运动</li>
</ol>
<p>所有的动画代码都在顶点着色器中，并由 uniform 控制运动量。我们使用 uniform 来控制运动的强度，这样你就可以在编辑器中调整动画，并实时看到结果，而不用重新编译着色器。</p>
<p>所有的运动都将使用余弦波应用于模型空间中的 VERTEX . 我们希望顶点在模型空间中, 使运动总是相对于鱼的方向. 例如,side-to-side将始终使鱼在其左至右的方向上来回移动, 而不是在世界方向的 x 轴上.</p>
<p>为了控制动画的速度，我们将通过使用 TIME 定义自己的时间变量开始。<br><code>float time = TIME * time_scale;</code></p>
<p>我们将实施的第一项议案是左右运动. 它可以通过 TIME 的 cos 抵消 VERTEX.x 来制作. 每次渲染网格时, 所有顶点都会移动到 “cos(时间)” 的数量.</p>
<p>&#x2F;&#x2F;side_to_side is a uniform float<br><code>VERTEX.x += cos(time) * side_to_side;</code></p>
<p>生成的动画看起来是这样的:<br>接下来，我们添加轴心点。因为鱼以 (0, 0) 为中心，我们所要做的只是将 VERTEX 乘以旋转矩阵，使其围绕鱼的中心旋转。<br>我们构造一个旋转矩阵, 如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//angle is scaled by 0.1 so that the fish only pivots and doesn&#x27;t rotate all the way around</span><br><span class="line">//pivot is a uniform float</span><br><span class="line">float pivot_angle = cos(time) * 0.1 * pivot;</span><br><span class="line">mat2 rotation_matrix = mat2(vec2(cos(pivot_angle), -sin(pivot_angle)), vec2(sin(pivot_angle), cos(pivot_angle)));</span><br></pre></td></tr></table></figure>
<p>然后我们把它乘以 VERTEX.xz，应用到 x 和 z 轴上。<br><code>VERTEX.xz = rotation_matrix * VERTEX.xz;</code><br>在只应用轴心的情况下，你会看到这个：<br>接下来的两个动作需要沿着鱼的脊柱平移. 为此, 我们需要一个新的变量, body . body 是一个浮点数，在鱼的尾部是 0 ，在头部是 1 .<br><code>float body = (VERTEX.z + 1.0) / 2.0; //for a fish centered at (0, 0) with a length of 2</code></p>
<p>下一个运动是沿着鱼的长度向下移动的余弦波. 为了让它沿着鱼的脊柱移动, 我们用脊柱的位置来偏移输入到 cos 的位置, 也就是我们在上面定义的变量 body。<br>&#x2F;&#x2F;wave is a uniform float<br><code>VERTEX.x += cos(time + body) * wave;</code><br>这看起来很像我们上面定义的左右运动, 但在这个例子中, 通过使用 body 来偏移 cos，沿着脊柱的每个顶点在波浪中都有不同的位置, 使它看起来像是沿着鱼移动的波浪.<br>最后一个动作是扭转，也就是沿着脊柱滚动。类似轴心运动，我们首先构造一个旋转矩阵。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//twist is a uniform float</span><br><span class="line">float twist_angle = cos(time + body) * 0.3 * twist;</span><br><span class="line">mat2 twist_matrix = mat2(vec2(cos(twist_angle), -sin(twist_angle)), vec2(sin(twist_angle), cos(twist_angle)));</span><br></pre></td></tr></table></figure>
<p>我们在 xy 轴上应用旋转, 使鱼看起来绕着它的脊柱滚动. 要做到这一点, 鱼的脊柱需要以 z 轴为中心.<br><code>VERTEX.xy = twist_matrix * VERTEX.xy;</code><br>这是应用扭曲的鱼:<br>如果我们一个接一个地应用这些运动, 就得到一个类似液体凝胶似的运动.<br>通常鱼主要使用身体的后半部分游泳，所以我们需要将平移运动限制在鱼的后半部分。为此，我们创建一个新变量 mask （遮罩）。<br>mask 是个浮点数，从鱼头的 0 过渡到鱼尾的 1 ，我们用 smoothstep 来控制在哪里进行由 0 到 1 的过渡。<br>&#x2F;&#x2F;mask_black and mask_white are uniforms<br><code>float mask = smoothstep(mask_black, mask_white, 1.0 - body);</code><br>下面是把 COLOR 设置成 mask 后这条鱼的样子：<br>我们在做波浪运动的地方乘以 mask 就可以把动作限制在后半部分。<br>&#x2F;&#x2F;wave motion with mask<br><code>VERTEX.x += cos(time + body) * mask * wave;</code><br>为了将遮罩应用于扭曲, 我们使用 mix . mix 允许在完全旋转的顶点和未旋转的顶点之间混合顶点位置. 需要使用 mix 而不是将 mask 乘以旋转后的 VERTEX , 因为不是将运动加到 VERTEX 上, 而是用旋转后的版本替换 VERTEX . 如果把它乘以 mask , 就会把鱼缩小.<br>&#x2F;&#x2F;twist motion with mask<br><code>VERTEX.xy = mix(VERTEX.xy, twist_matrix * VERTEX.xy, mask);</code><br>将四个动作组合在一起, 就得到了最终的动画效果.<br>继续发挥 uniform 的作用, 以改变鱼的游泳周期. 你会发现, 你可以用这四个动作创造出各种各样的游泳方式.</p>
<p>制作一群鱼<br>Godot 使用 MultiMeshInstance3D 节点可以轻松渲染数千个相同的对象。</p>
<p>MultiMeshInstance3D 节点的创建和使用与 MeshInstance3D 节点相同。在本教程中，我们将把 MultiMeshInstance3D 节点命名为 School，因为它将包含一群鱼。<br>拥有 MultiMeshInstance3D 后，添加一个 MultiMesh，然后使用上面的着色器向该 MultiMesh 添加网格 。</p>
<p>MultiMeshes 使用三个额外的实例属性来绘制 Mesh：变换（旋转、平移、缩放）、颜色和自定义。自定义用于使用 Color 传入 4 个多用途变量。</p>
<p>instance_count 指定要绘制的网格的实例数量。现在，将 instance_count 保留为 0，因为当 instance_count 大于 0 时，你不能更改任何其他参数。我们稍后将在 GDScript 中设置 instance_count。</p>
<p>transform_format 指定使用的变换是 3D 还是 2D。对于本教程，请选择 3D。</p>
<p>对于 color_format 和 custom_data_format，你可以在 None、Byte、Float 之间选择。None 意味着你不会将这些数据（无论是每个实例的 COLOR 变量还是 INSTANCE_CUSTOM）传递给着色器。Byte 意味着组成你传入的颜色的每一个数字将被存储为 8 位，而 Float 意味着每一个数字将被存储为浮点数（32 位）。Float 速度较慢但更精确，Byte 占用内存较少、速度较快，但你可能会看到一些视觉上的伪像。</p>
<p>现在，将 instance_count 设置为你想要的鱼的数量。</p>
<p>接下来, 我们需要设置每个实例的变换.</p>
<p>有两种方法可以为 MultiMesh 设置每个实例的变换。第一种方法完全在编辑器中，并在《MultiMeshInstance3D 教程》中进行了描述。</p>
<p>第二种方法是, 遍历所有实例, 并在代码中设置它们的变换. 下面, 我们使用GDScript遍历所有实例, 并将它们的变换设置为随机位置.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range($School.multimesh.instance_count):</span><br><span class="line">  var position = Transform3D()</span><br><span class="line">  position = position.translated(Vector3(randf() * 100 - 50, randf() * 50 - 25, randf() * 50 - 25))</span><br><span class="line">  $School.multimesh.set_instance_transform(i, position)</span><br></pre></td></tr></table></figure>
<p>运行该脚本，将会在 MultiMeshInstance3D 位置周围的框中，把鱼放置在随机位置。<br>你应该已经注意到所有鱼的游泳动作都是同步的了吧？这样看上去非常机械。下一步我们要做的就是让每一条鱼都处于游泳周期的不同位置，这样整个鱼群看起来就会更自然。</p>
<p>动画鱼群<br>使用 cos 函数给鱼做动画的一个好处是，它们只需要一个 time 参数。为了让每条鱼在游泳周期中处于单独的位置，我们只需要偏移 time。<br>为此，我们将每个实例的自定义值 INSTANCE_CUSTOM 添加到 time 中。<br><code>float time = (TIME * time_scale) + (6.28318 * INSTANCE_CUSTOM.x);</code></p>
<p>接下来，我们需要向 INSTANCE_CUSTOM 传递一个值。通过在上面的 for 循环中添加一行来实现这一点。在 for 循环中，为每个实例分配一组四个随机浮点数来使用。<br><code>$School.multimesh.set_instance_custom_data(i, Color(randf(), randf(), randf(), randf()))</code></p>
<p>现在这些鱼在游泳周期中都有独特的位置。你可以通过使用 INSTANCE_CUSTOM 乘以 TIME 让它们游泳更快或更慢，从而让它们更个性化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将速度设置为正常速度的50至150</span><br><span class="line">float time = (TIME * (0.5 + INSTANCE_CUSTOM.y) * time_scale) + (6.28318 * INSTANCE_CUSTOM.x);</span><br></pre></td></tr></table></figure>
<p>甚至你还可以像更改每个实例的自定义值一样, 尝试更改每个实例的颜色.</p>
<p>此时你会遇到的一个问题是，鱼虽然有动画，但它们并没有移动。你可以通过每帧更新每条鱼的实例变换来移动它们。虽然这样做比每帧移动数千个 MeshInstance3D 要快，但速度可能仍然很慢。</p>
<p>在下一个教程中，我们将介绍如何使用GPUParticles3D来利用 GPU 并单独移动每条鱼，同时还能获得实例化的好处。</p>
<p>用粒子控制数千条鱼<br>MeshInstance3D 的问题在于更新其变换数组的成本很高。它非常适合在场景周围放置许多静态对象。但在场景周围移动对象仍然很困难。<br>为了使每个实例以有趣的方式移动，我们将使用一个 GPUParticles3D 节点。粒子通过在 Shader 中计算和设置每个实例的信息来利用 GPU 加速。</p>
<p>首先创建一个 Particles 节点。然后在“Draw Passes”下将粒子的“Draw Pass 1”设置为你的 Mesh。然后在“Process Material”下创建一个新的 ShaderMaterial。</p>
<p>将 shader_type 设置为 particles。<br><code>shader_type particles</code></p>
<p>然后添加以下两个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">float rand_from_seed(in uint seed) &#123;</span><br><span class="line">  int k;</span><br><span class="line">  int s = int(seed);</span><br><span class="line">  if (s == 0)</span><br><span class="line">    s = 305420679;</span><br><span class="line">  k = s / 127773;</span><br><span class="line">  s = 16807 * (s - k * 127773) - 2836 * k;</span><br><span class="line">  if (s &lt; 0)</span><br><span class="line">    s += 2147483647;</span><br><span class="line">  seed = uint(s);</span><br><span class="line">  return float(seed % uint(65536)) / 65535.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint hash(uint x) &#123;</span><br><span class="line">  x = ((x &gt;&gt; uint(16)) ^ x) * uint(73244475);</span><br><span class="line">  x = ((x &gt;&gt; uint(16)) ^ x) * uint(73244475);</span><br><span class="line">  x = (x &gt;&gt; uint(16)) ^ x;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些函数来自默认的 ParticleProcessMaterial。它们用于从每个粒子的 RANDOM_SEED 生成一个随机数。</p>
<p>粒子着色器的一个独特之处在于一些内置变量可以跨帧保存。TRANSFORM、COLOR 和 CUSTOM 都可以在网格着色器中访问，也可以在下次运行时在粒子着色器中访问。</p>
<p>接下来，设置你的 start() 函数。粒子着色器包含一个 start() 函数和一个 process() 函数。</p>
<p>start() 函式中的代码仅在粒子系统启动时运作。process() 函式中的代码将始终运作。</p>
<p>我们需要生成 4 个随机数：其中 3 个用于创建一个随机位置，1 个用于游泳周期的随机偏移。</p>
<p>首先，使用上面提供的 hash() 函数在 start() 函数内生成 4 个种子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint alt_seed1 = hash(NUMBER + uint(1) + RANDOM_SEED);</span><br><span class="line">uint alt_seed2 = hash(NUMBER + uint(27) + RANDOM_SEED);</span><br><span class="line">uint alt_seed3 = hash(NUMBER + uint(43) + RANDOM_SEED);</span><br><span class="line">uint alt_seed4 = hash(NUMBER + uint(111) + RANDOM_SEED);</span><br></pre></td></tr></table></figure>
<p>然后，使用这些种子生成随机数，使用 rand_from_seed：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CUSTOM.x = rand_from_seed(alt_seed1);</span><br><span class="line">vec3 position = vec3(rand_from_seed(alt_seed2) * 2.0 - 1.0,</span><br><span class="line">                     rand_from_seed(alt_seed3) * 2.0 - 1.0,</span><br><span class="line">                     rand_from_seed(alt_seed4) * 2.0 - 1.0);</span><br></pre></td></tr></table></figure>
<p>最后，将 position 赋值给 <code>TRANSFORM[3].xyz</code>，它是保存位置信息的变换的一部分。<br><code>TRANSFORM[3].xyz = position * 20.0;</code><br>请记住，到目前为止所有这些代码都位于 start() 函数内部。</p>
<p>网格的顶点着色器, 可以完全复用前一教程中的.</p>
<p>现在每一帧你都可以单独移动每条鱼了，可以直接增加 TRANSFORM 也可以设置 VELOCITY。</p>
<p>让我们通过在 start() 函数中设置 VELOCITY 来变换鱼。<br><code>VELOCITY.z = 10.0;</code><br>这是设置 VELOCITY 的最基本方法，每个粒子（或鱼）都有相同的速度。</p>
<p>只要设置 VELOCITY，你就可以让鱼自由游动。例如，尝试下面的代码。<br><code>VELOCITY.z = cos(TIME + CUSTOM.x * 6.28) * 4.0 + 6.0;</code></p>
<p>这将为每条鱼在 2 和 10 之间设置不同的速度。</p>
<p>如果你在 process() 函式中设定速度，你也可以让每条鱼随着时间的推移改变其速度。</p>
<p>如果你在上一个教程中使用了 CUSTOM.y，你也可以基于 VELOCITY 来设置游泳动画的速度。直接用 CUSTOM.y 就好了。<br><code>CUSTOM.y = VELOCITY.z * 0.1;</code><br>代码产生的效果如图:</p>
<p>使用 ParticleProcessMaterial，你可以根据需要使鱼的行为变得简单或复杂。在本教程中，我们只设置了速度，但在你自己的着色器中，你还可以设置 COLOR、旋转、缩放（通过 TRANSFORM）。有关粒子着色器的更多信息，请参阅《粒子着色器参考》。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程允许同时执行代码。它允许从主线程卸载工作。<br>创建线程请使用如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var thread: Thread</span><br><span class="line"></span><br><span class="line"># The thread will start here.</span><br><span class="line">func _ready():</span><br><span class="line">	thread = Thread.new()</span><br><span class="line">	# You can bind multiple arguments to a function Callable.</span><br><span class="line">	thread.start(_thread_function.bind(&quot;Wafflecopter&quot;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run here and exit.</span><br><span class="line"># The argument is the bound data passed from start().</span><br><span class="line">func _thread_function(userdata):</span><br><span class="line">	# Print the userdata (&quot;Wafflecopter&quot;)</span><br><span class="line">	print(&quot;I&#x27;m a thread! Userdata is: &quot;, userdata)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Thread must be disposed (or &quot;joined&quot;), for portability.</span><br><span class="line">func _exit_tree():</span><br><span class="line">	thread.wait_to_finish()</span><br></pre></td></tr></table></figure>
<p>然后, 你的函数将在一个单独的线程中运行, 直到它返回. 即使函数已经返回, 线程也必须收集它, 所以调用 Thread.wait_to_finish() , 它将等待线程完成(如果还没有完成), 然后妥善处理它.</p>
<p>警告<br>创建线程是一项缓慢的作，尤其是在 Windows 上。为避免不必要的性能开销，请确保在需要大量处理之前创建线程，而不是实时创建线程。<br>例如，如果你在游戏过程中需要多个线程，你可以在关卡加载时创建线程，然后才真正开始处理它们。<br>此外，互斥锁的锁定和解锁也可能是一项昂贵的作。锁定时应小心;避免过于频繁（或过长时间）锁定。</p>
<p>Mutex<br>并不总是支持从多个线程访问对象或数据(如果你这样做, 会导致意外行为或崩溃). 请阅读 线程安全的 API 文档, 了解哪些引擎API支持多线程访问.</p>
<p>在处理自己的数据或调用自己的函数时, 通常情况下, 尽量避免从不同的线程直接访问相同的数据. 你可能会遇到同步问题, 因为数据被修改后,CPU核之间并不总是更新. 当从不同线程访问一个数据时, 一定要使用 Mutex .</p>
<p>当调用 Mutex.lock() 时, 一个线程确保所有其他线程如果试图 锁 同一个mutex, 就会被阻塞(进入暂停状态). 当通过调用 Mutex.unlock() 来解锁该mutex时, 其他线程将被允许继续锁定(但每次只能锁定一个).</p>
<p>下面是一个使用 Mutex 的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var counter := 0</span><br><span class="line">var mutex: Mutex</span><br><span class="line">var thread: Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The thread will start here.</span><br><span class="line">func _ready():</span><br><span class="line">	mutex = Mutex.new()</span><br><span class="line">	thread = Thread.new()</span><br><span class="line">	thread.start(_thread_function)</span><br><span class="line"></span><br><span class="line">	# Increase value, protect it with Mutex.</span><br><span class="line">	mutex.lock()</span><br><span class="line">	counter += 1</span><br><span class="line">	mutex.unlock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Increment the value from the thread, too.</span><br><span class="line">func _thread_function():</span><br><span class="line">	mutex.lock()</span><br><span class="line">	counter += 1</span><br><span class="line">	mutex.unlock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Thread must be disposed (or &quot;joined&quot;), for portability.</span><br><span class="line">func _exit_tree():</span><br><span class="line">	thread.wait_to_finish()</span><br><span class="line">	print(&quot;Counter is: &quot;, counter) # Should be 2.</span><br></pre></td></tr></table></figure>


<p>Semaphore信号量<br>有时您希望您的线程 “按需” 工作。换句话说，告诉它什么时候工作，当它什么都不做时让它暂停。为此，使用了信号量 。功能 Semaphore.wait（） 用于在线程中暂停它，直到一些数据到达。</p>
<p>而主线程则使用 Semaphore.post() 来表示数据已经准备好被处理:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">var counter := 0</span><br><span class="line">var mutex: Mutex</span><br><span class="line">var semaphore: Semaphore</span><br><span class="line">var thread: Thread</span><br><span class="line">var exit_thread := false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The thread will start here.</span><br><span class="line">func _ready():</span><br><span class="line">	mutex = Mutex.new()</span><br><span class="line">	semaphore = Semaphore.new()</span><br><span class="line">	exit_thread = false</span><br><span class="line"></span><br><span class="line">	thread = Thread.new()</span><br><span class="line">	thread.start(_thread_function)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _thread_function():</span><br><span class="line">	while true:</span><br><span class="line">		semaphore.wait() # Wait until posted.</span><br><span class="line"></span><br><span class="line">		mutex.lock()</span><br><span class="line">		var should_exit = exit_thread # Protect with Mutex.</span><br><span class="line">		mutex.unlock()</span><br><span class="line"></span><br><span class="line">		if should_exit:</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">		mutex.lock()</span><br><span class="line">		counter += 1 # Increment counter, protect with Mutex.</span><br><span class="line">		mutex.unlock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func increment_counter():</span><br><span class="line">	semaphore.post() # Make the thread process.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func get_counter():</span><br><span class="line">	mutex.lock()</span><br><span class="line">	# Copy counter, protect with Mutex.</span><br><span class="line">	var counter_value = counter</span><br><span class="line">	mutex.unlock()</span><br><span class="line">	return counter_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Thread must be disposed (or &quot;joined&quot;), for portability.</span><br><span class="line">func _exit_tree():</span><br><span class="line">	# Set exit condition to true.</span><br><span class="line">	mutex.lock()</span><br><span class="line">	exit_thread = true # Protect with Mutex.</span><br><span class="line">	mutex.unlock()</span><br><span class="line"></span><br><span class="line">	# Unblock by posting.</span><br><span class="line">	semaphore.post()</span><br><span class="line"></span><br><span class="line">	# Wait until it exits.</span><br><span class="line">	thread.wait_to_finish()</span><br><span class="line"></span><br><span class="line">	# Print the counter.</span><br><span class="line">	print(&quot;Counter is: &quot;, counter)</span><br></pre></td></tr></table></figure>


<p>线程安全的 API<br>线程<br>线程是用来平衡各CPU和核心的处理能力.Godot支持多线程, 但不是在整个引擎中.</p>
<p>下面是可以在Godot的不同区域使用多线程的方法列表.</p>
<p>全局作用域<br>全局范围单例都是线程安全的。支持从线程访问服务器（对于 RenderingServer 和 Physics 服务器，请确保在项目设置中启用了线程或线程安全操作！）。</p>
<p>这使它们成为在服务器中创建数十万个实例并从线程控制它们的代码的理想选择. 当然, 还需要更多的代码, 因为这是直接使用的而不是嵌入场景树中使用.</p>
<p>场景树<br>与活动场景树的交互是线程 不 安全的. 当在线程之间发送数据时, 请确保使用mutexes. 如果你想从一个线程调用函数, 可以使用 call_deferred 函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Unsafe:</span><br><span class="line">node.add_child(child_node)</span><br><span class="line"># Safe:</span><br><span class="line">node.add_child.call_deferred(child_node)</span><br></pre></td></tr></table></figure>
<p>但是, 可以在激活的场景树外创建场景块(以树形式排列的节点). 这样, 可以在线程中构建或实例化部分场景, 然后将其添加到主线程中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var enemy_scene = load(&quot;res://enemy_scene.scn&quot;)</span><br><span class="line">var enemy = enemy_scene.instantiate()</span><br><span class="line">enemy.add_child(weapon) # Set a weapon.</span><br><span class="line">world.add_child.call_deferred(enemy)</span><br></pre></td></tr></table></figure>
<p>不过, 只有当你有 一个 线程加载数据时, 这才真正有用. 从多个线程加载或创建场景块可能有效, 但你要冒着资源被多线程调整的风险(在Godot中只加载一次), 从而导致意外行为或崩溃.</p>
<p>只有当你 “真正” 知道自己在做什么, 并且确信一个资源没有被多个资源使用或设置时, 才可以使用多个线程来生成场景数据. 否则, 直接使用服务端的API(它是完全线程安全的)而不接触场景或资源会更安全.</p>
<p>渲染<br>默认情况下，实例化能够渲染 2D 或 3D 内容的节点（比如 Sprite）不是线程安全的。要让渲染做到线程安全，请将项目设置中的Rendering &gt; Driver &gt; Thread Model设为 Multi-Threaded。</p>
<p>请注意，Multi-Thtreaded 线程模型有若干已知的问题，所以无法胜任所有场景。</p>
<p>你应该避免调用涉及与其他线程上的 GPU 直接交互的函数，例如创建新纹理或修改和检索图像数据，这些操作可能会导致性能停滞，因为它们需要与 RenderingServer 同步，因为数据需要传输到 GPU 或在 GPU 上更新。</p>
<p>GDScript 数组、字典<br>在 GDScript 中，可以从多个线程读取和写入元素，但是任何改变容器大小的操作（调整大小、添加或删除元素）都需要锁定互斥锁。</p>
<p>资源<br>不支持从多个线程修改唯一资源。但是支持在多个线程上处理引用，因此在单个线程上加载资源（场景、纹理、网格等）也可以在单个线程上加载和操作，然后添加到主线程上的活动场景中。此处的限制如上所述，必须注意不要同时从多个线程加载相同的资源，因此最简单的方法是使用一个线程来加载和修改资源，然后使用主线程来添加它们。</p>
<h2 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h2><h3 id="物理介绍"><a href="#物理介绍" class="headerlink" title="物理介绍"></a>物理介绍</h3><h3 id="Using-Jolt-Physics"><a href="#Using-Jolt-Physics" class="headerlink" title="Using Jolt Physics"></a>Using Jolt Physics</h3><h3 id="使用-RigidBody"><a href="#使用-RigidBody" class="headerlink" title="使用 RigidBody"></a>使用 RigidBody</h3><h3 id="使用-Area2D"><a href="#使用-Area2D" class="headerlink" title="使用 Area2D"></a>使用 Area2D</h3><h3 id="使用-CharacterBody2D-3D"><a href="#使用-CharacterBody2D-3D" class="headerlink" title="使用 CharacterBody2D&#x2F;3D"></a>使用 CharacterBody2D&#x2F;3D</h3><h3 id="发射射线"><a href="#发射射线" class="headerlink" title="发射射线"></a>发射射线</h3><h3 id="布娃娃系统"><a href="#布娃娃系统" class="headerlink" title="布娃娃系统"></a>布娃娃系统</h3><h3 id="运动学角色（2D）"><a href="#运动学角色（2D）" class="headerlink" title="运动学角色（2D）"></a>运动学角色（2D）</h3><h3 id="Using-SoftBody3D"><a href="#Using-SoftBody3D" class="headerlink" title="Using SoftBody3D"></a>Using SoftBody3D</h3><h3 id="碰撞形状（2D）"><a href="#碰撞形状（2D）" class="headerlink" title="碰撞形状（2D）"></a>碰撞形状（2D）</h3><h3 id="碰撞形状（3D）"><a href="#碰撞形状（3D）" class="headerlink" title="碰撞形状（3D）"></a>碰撞形状（3D）</h3><h3 id="大世界坐标"><a href="#大世界坐标" class="headerlink" title="大世界坐标"></a>大世界坐标</h3><h3 id="物理插值"><a href="#物理插值" class="headerlink" title="物理插值"></a>物理插值</h3><h3 id="物理问题的故障排除"><a href="#物理问题的故障排除" class="headerlink" title="物理问题的故障排除"></a>物理问题的故障排除</h3><h2 id="平台相关"><a href="#平台相关" class="headerlink" title="平台相关"></a>平台相关</h2><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h3 id="iOS-插件"><a href="#iOS-插件" class="headerlink" title="iOS 插件"></a>iOS 插件</h3><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h3 id="Godot-的游戏主机支持"><a href="#Godot-的游戏主机支持" class="headerlink" title="Godot 的游戏主机支持"></a>Godot 的游戏主机支持</h3><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="编辑器插件"><a href="#编辑器插件" class="headerlink" title="编辑器插件"></a>编辑器插件</h3><ol>
<li><p>区分插件<br>区分编辑器插件和非编辑器插件的方法是在存放插件的仓库中查找 plugin.cfg 文件。<br>如果仓库的 addons&#x2F; 中包含 plugin.cfg 文件，那么它就是编辑器插件。</p>
</li>
<li><p>安装插件<br>解压 ZIP 压缩包，并将其包含的 addons&#x2F; 文件夹移动到你的项目文件夹中。</p>
</li>
<li><p>启用插件<br>打开编辑器顶部的项目 &gt; 项目设置，然后转到插件选项卡。<br>如果插件被正确打包，你应该会在插件列表中看到它。点击启用勾选框以启用该插件。（不需要重启）</p>
</li>
</ol>
<h4 id="制作插件"><a href="#制作插件" class="headerlink" title="制作插件"></a>制作插件</h4><p>本教程将指导你创建两个插件，以便你了解它们的工作原理并能够开发自己的插件。<br>第一个是可以添加到项目中的任何场景的自定义节点，另一个是添加到编辑器的自定义停靠面板。</p>
<p>首先需要创建两个文件: 一个是 plugin.cfg 用于配置和具有此功能的工具脚本. 插件在项目文件夹里面有一个标准路径, 比如 addons&#x2F;plugin_name.Godot提供了一个属性框, 用于生成这些文件并将它们放在需要的位置.<br>在主工具栏中，点击项目下拉菜单，然后点击项目设置…。然后转到插件选项卡，点击右上角的创建新插件按钮。<br>你会看到出现了一个对话框，类似这样：<br>每个字段中文本属性都描述了它会影响到哪些配置文件的值.</p>
<p>如果要继续使用该例子，请使用下列的值：</p>
<p>制作主屏幕插件<br>导入插件<br>3D 小工具插件<br>检查器插件<br>可视化着色器插件</p>
<h3 id="在编辑器中运行代码"><a href="#在编辑器中运行代码" class="headerlink" title="在编辑器中运行代码"></a>在编辑器中运行代码</h3><h2 id="渲染-2"><a href="#渲染-2" class="headerlink" title="渲染"></a>渲染</h2><h3 id="使用视口"><a href="#使用视口" class="headerlink" title="使用视口"></a>使用视口</h3><h3 id="多分辨率"><a href="#多分辨率" class="headerlink" title="多分辨率"></a>多分辨率</h3><h3 id="修复抖动、卡顿和输入延迟"><a href="#修复抖动、卡顿和输入延迟" class="headerlink" title="修复抖动、卡顿和输入延迟"></a>修复抖动、卡顿和输入延迟</h3><h3 id="合成器"><a href="#合成器" class="headerlink" title="合成器"></a>合成器</h3><h3 id="渲染器"><a href="#渲染器" class="headerlink" title="渲染器"></a>渲染器</h3><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><h3 id="GDScript"><a href="#GDScript" class="headerlink" title="GDScript"></a>GDScript</h3><p>GDScript 示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># 一个脚本文件就是一个类！</span><br><span class="line"></span><br><span class="line"># （可选）在编辑器对话框中显示的图标：</span><br><span class="line">@icon(&quot;res://path/to/optional/icon.svg&quot;)</span><br><span class="line"></span><br><span class="line"># （可选）类名定义，使该类可在整个项目中全局访问</span><br><span class="line">class_name MyClass</span><br><span class="line"></span><br><span class="line"># 继承关系：当前类继承自 BaseClass</span><br><span class="line">extends BaseClass</span><br><span class="line"></span><br><span class="line"># 成员变量（字段）</span><br><span class="line">var a = 5</span><br><span class="line">var s = &quot;Hello&quot;</span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">var dict = &#123;&quot;key&quot;: &quot;value&quot;, 2: 3&#125;</span><br><span class="line">var other_dict = &#123;key = &quot;value&quot;, other_key = 2&#125;</span><br><span class="line">var typed_var: int            # 带类型声明的变量</span><br><span class="line">var inferred_type := &quot;String&quot; # 类型从初始值推断（字符串）</span><br><span class="line"></span><br><span class="line"># 常量（不可修改）</span><br><span class="line">const ANSWER = 42</span><br><span class="line">const THE_NAME = &quot;Charly&quot;</span><br><span class="line"></span><br><span class="line"># 枚举类型</span><br><span class="line">enum &#123;UNIT_NEUTRAL, UNIT_ENEMY, UNIT_ALLY&#125;  # 匿名枚举，值从0开始递增</span><br><span class="line">enum Named &#123;THING_1, THING_2, ANOTHER_THING = -1&#125;  # 命名枚举，可自定义值</span><br><span class="line"></span><br><span class="line"># 内置向量类型</span><br><span class="line">var v2 = Vector2(1, 2)      # 2D 向量</span><br><span class="line">var v3 = Vector3(1, 2, 3)   # 3D 向量</span><br><span class="line"></span><br><span class="line"># 函数定义</span><br><span class="line">func some_function(param1, param2, param3):</span><br><span class="line">	const local_const = 5  # 局部常量</span><br><span class="line"></span><br><span class="line">	if param1 &lt; local_const:</span><br><span class="line">		print(param1)</span><br><span class="line">	elif param2 &gt; 5:</span><br><span class="line">		print(param2)</span><br><span class="line">	else:</span><br><span class="line">		print(&quot;Fail!&quot;)</span><br><span class="line"></span><br><span class="line">	for i in range(20):  # 循环 0 到 19</span><br><span class="line">		print(i)</span><br><span class="line"></span><br><span class="line">	while param2 != 0:   # 当 param2 不为 0 时循环</span><br><span class="line">		param2 -= 1</span><br><span class="line"></span><br><span class="line">	match param3:        # 匹配语句（类似 switch）</span><br><span class="line">		3:</span><br><span class="line">			print(&quot;param3 is 3!&quot;)</span><br><span class="line">		_:</span><br><span class="line">			print(&quot;param3 is not 3!&quot;)</span><br><span class="line"></span><br><span class="line">	var local_var = param1 + 3</span><br><span class="line">	return local_var</span><br><span class="line"></span><br><span class="line"># 重写父类中同名函数。</span><br><span class="line"># 如果仍需调用父类函数，请使用 &quot;super&quot;：</span><br><span class="line">func something(p1, p2):</span><br><span class="line">	super(p1, p2)  # 调用父类的 something 方法</span><br><span class="line"></span><br><span class="line"># 也可以显式调用父类的其他方法：</span><br><span class="line">func other_something(p1, p2):</span><br><span class="line">	super.something(p1, p2)  # 通过 super 调用父类的 something 方法</span><br><span class="line"></span><br><span class="line"># 内部类（嵌套类）</span><br><span class="line">class Something:</span><br><span class="line">	var a = 10</span><br><span class="line"></span><br><span class="line"># 构造函数（初始化方法）</span><br><span class="line">func _init():</span><br><span class="line">	print(&quot;Constructed!&quot;)</span><br><span class="line">	var lv = Something.new()     # 创建内部类的实例</span><br><span class="line">	print(lv.a)                  # 输出：10</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">match</td>
<td align="left">相当于 switch 语句，但提供了一些附加功能。将 switch 替换为 match。删除 case。删除 break。将 default 替换为单个下划线。</td>
</tr>
<tr>
<td align="left">when</td>
<td align="left">用于 match 语句中的模式防护。</td>
</tr>
<tr>
<td align="left">break</td>
<td align="left">退出当前 for 或 while 循环的执行。</td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">立即跳到 for 或 while 循环的下一个迭代。</td>
</tr>
<tr>
<td align="left">pass</td>
<td align="left">语法上要求在不希望执行代码的语句中使用，例如在空函数中使用。</td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">从函数当中返回一个值。</td>
</tr>
<tr>
<td align="left">class</td>
<td align="left">定义内部类。见内部类。</td>
</tr>
<tr>
<td align="left">class_name</td>
<td align="left">将脚本定义为具有指定名称的全局可访问类。见注册具名类。</td>
</tr>
<tr>
<td align="left">extends</td>
<td align="left">定义当前类的父类。</td>
</tr>
<tr>
<td align="left">is</td>
<td align="left">检测变量是否继承自给定的类，或检测该变量是否为给定的内置类型。</td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">通常情况下用来检测字符串、列表、范围、字典、节点中是否存在某个值，而和 for 关键字连用时，则用于遍历字符串、列表、范围、字典、节点中的内容。</td>
</tr>
<tr>
<td align="left">as</td>
<td align="left">尝试将值转换为给定类型的值。</td>
</tr>
<tr>
<td align="left">self</td>
<td align="left">引用当前类实例。见 self。</td>
</tr>
<tr>
<td align="left">super</td>
<td align="left">解析父类作用域内的方法。见继承。</td>
</tr>
<tr>
<td align="left">signal</td>
<td align="left">定义信号。见信号。</td>
</tr>
<tr>
<td align="left">func</td>
<td align="left">定义函数。见函数。</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">将一个函数声明为静态函数，或将一个成员变量声明为静态成员变量。</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">定义常量。见常量。</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left">定义枚举。见枚举。</td>
</tr>
<tr>
<td align="left">var</td>
<td align="left">定义变量。见变量。</td>
</tr>
<tr>
<td align="left">breakpoint</td>
<td align="left">用来设置脚本编辑器辅助调试断点的关键字。与在脚本编辑器每行最左侧点击红点所创建的断点不同，breakpoint 关键字可以储存在脚本内部。在不同设备上使用版本工具进行调试时，由 breakpoint 关键字创建的断点仍旧有效。</td>
</tr>
<tr>
<td align="left">preload</td>
<td align="left">预加载类或变量。见类作为资源。</td>
</tr>
<tr>
<td align="left">await</td>
<td align="left">等待信号或协程完成。见等待信号和协程。</td>
</tr>
<tr>
<td align="left">yield</td>
<td align="left">以前的版本中用于协程，现保留为关键字，以便旧版本迁移至新版本。</td>
</tr>
<tr>
<td align="left">assert</td>
<td align="left">断言条件，若断言失败则记录错误。非调试版本中会忽略断言语法。见 Assert 关键字。</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">用于代表函数不返回任何值。</td>
</tr>
<tr>
<td align="left">PI</td>
<td align="left">PI（π）常数。</td>
</tr>
<tr>
<td align="left">TAU</td>
<td align="left">TAU（τ）常数。</td>
</tr>
<tr>
<td align="left">INF</td>
<td align="left">无穷常量，用于比较和计算结果。</td>
</tr>
<tr>
<td align="left">NAN</td>
<td align="left">NAN（非数）常量，用作计算后不可能得到的结果。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x[index]</code></td>
<td align="left">下标</td>
</tr>
<tr>
<td align="left"><code>x.attribute</code></td>
<td align="left">属性引用</td>
</tr>
<tr>
<td align="left"><code>foo()</code></td>
<td align="left">函数调用</td>
</tr>
<tr>
<td align="left"><code>await x</code></td>
<td align="left">等待信号或协程</td>
</tr>
<tr>
<td align="left"><code>x is Node</code><br><code>x is not Node</code></td>
<td align="left">类型检查<br>另见 is_instance_of() 函数。</td>
</tr>
<tr>
<td align="left"><code>x ** y</code></td>
<td align="left">幂（乘方）<br>将 x 与其自身相乘 y 次，类似于调用 pow() 函数。</td>
</tr>
<tr>
<td align="left"><code>~x</code></td>
<td align="left">按位取反</td>
</tr>
<tr>
<td align="left"><code>+x</code><br><code>-x</code></td>
<td align="left">取同 &#x2F; 取负（相反数）</td>
</tr>
<tr>
<td align="left"><code>x * y</code><br><code>x / y</code><br><code>x % y</code></td>
<td align="left">乘法&#x2F;除法&#x2F;余数<br><code>%</code> 运算符也用于字符串的格式化。<br>注意：这些运算符的运算机制与其在 C++ 中的运算机制一致，而对于使用 Python、JavaScript 等语言的用户则可能会存在在其意料之外的运算机制，详情见表后。</td>
</tr>
<tr>
<td align="left"><code>x + y</code><br><code>x - y</code></td>
<td align="left">加法（或连接）&#x2F;减法</td>
</tr>
<tr>
<td align="left"><code>x &lt;&lt; y</code><br><code>x &gt;&gt; y</code></td>
<td align="left">位移位</td>
</tr>
<tr>
<td align="left"><code>x &amp; y</code></td>
<td align="left">按位与</td>
</tr>
<tr>
<td align="left"><code>x ^ y</code></td>
<td align="left">按位异或</td>
</tr>
<tr>
<td align="left"><code>x | y</code></td>
<td align="left">按位或</td>
</tr>
<tr>
<td align="left"><code>x == y</code><br><code>x != y</code><br><code>x &lt; y</code><br><code>x &gt; y</code><br><code>x &lt;= y</code><br><code>x &gt;= y</code></td>
<td align="left">比较<br>详情见表后。</td>
</tr>
<tr>
<td align="left"><code>x in y</code><br><code>x not in y</code></td>
<td align="left">检查包含关系<br><code>in</code> 也在 for 关键字的语法中使用。</td>
</tr>
<tr>
<td align="left"><code>not x</code><br><code>!x</code></td>
<td align="left">布尔“非”及其不推荐使用的形式</td>
</tr>
<tr>
<td align="left"><code>x and y</code><br><code>x &amp;&amp; y</code></td>
<td align="left">布尔“与”及其不推荐使用的形式</td>
</tr>
<tr>
<td align="left"><code>x or y</code><br><code>x || y</code></td>
<td align="left">布尔“或”及其不推荐使用的形式</td>
</tr>
<tr>
<td align="left"><code>真表达式 if 条件 else 假表达式</code></td>
<td align="left">三元（目）运算符 if&#x2F;else</td>
</tr>
<tr>
<td align="left"><code>x as Node</code></td>
<td align="left">类型转换</td>
</tr>
</tbody></table>
<p>一些运算符的运算机制可能会与你所预期的运算机制有所不同：</p>
<ol>
<li>若运算符 &#x2F; 两端的数值均为 int，则进行整数除法而非浮点数除法。例如： 5 &#x2F;2 &#x3D;&#x3D; 2 中该算式的结果为 2 而非 2.5。<br> 若希望进行浮点数运算，请将该运算符两端的其中一个数值的类型改为 float ，如直接使用浮点数（ x &#x2F; 2.0 ）、转换类型（ float(x) &#x2F; y ）、乘以 1.0 （ x * 1.0 &#x2F; y ）等。</li>
<li>运算符 % 仅适用于整型数值的取余运算，对于小数的取余运算，请使用 fmod() 方法。</li>
<li>对于负值，% 运算符和 fmod() 函数会使用 截断算法 进行运算，而非向负无穷大舍入，此时余数会带有符号（即余数可能为负）。<br> 如果你需要数学意义上的余数，请改用 posmod() 和 fposmod() 函数。</li>
<li>&#x3D;&#x3D; 和 !&#x3D; 运算符在有些情况下允许比较不同类型的值（例如 1 &#x3D;&#x3D; 1.0 的结果为真），但在其他情况下可能会发生运行时错误。<br> 若你不能确定操作数的类型，可使用 is_same() 函数来进行安全比较（但请注意，该函数对类型和引用更加严格）。<br> 要比较浮点数，请改用 is_equal_approx() 和 is_zero_approx() 函数。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$NodePath</td>
<td align="left">get_node(“NodePath”) 的简写</td>
</tr>
<tr>
<td align="left">%UniqueNode</td>
<td align="left">get_node(“%UniqueNode”) 的简写</td>
</tr>
</tbody></table>
<blockquote>
<p>整数和浮点数中的数字可用 _ 分隔，方便阅读。</p>
</blockquote>
<p>注解<br>@onready 注解<br>能够将成员变量的初始化推迟到调用 _ready() 时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var my_label</span><br><span class="line">func _ready():</span><br><span class="line">	my_label = get_node(&quot;MyLabel&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@onready var my_label = get_node(&quot;MyLabel&quot;)</span><br></pre></td></tr></table></figure>

<p>在 GDScript 中，一行语句可通过反斜杠（\）接续到下一行。</p>
<h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><p>如何阅读 Godot API<br>继承,派生,简要描述,描述,教程,属性,方法,信号,枚举,常量,属性说明,方法描述</p>
<p>调试<br>输出面板<br>调试器面板<br>调试菜单选项<br>使用远程调试部署<br>使用网络文件系统进行小型部署<br>显示碰撞区域</p>
<p>分组<br>与标签类似。你可以将节点加入若干个分组之中，然后在代码中通过 SceneTree 来：</p>
<ul>
<li>获取某个分组中的节点列表。</li>
<li>对分组中的所有节点调用方法。</li>
<li>向分组中的所有节点发送通知。<br>这个功能可以用来组织大型场景、解耦代码。</li>
</ul>
<h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><h3 id="着色器简介"><a href="#着色器简介" class="headerlink" title="着色器简介"></a>着色器简介</h3><p>着色器（Shader）是一种在图形处理单元（GPU）上运行的特殊程序。<br>类似 Godot 的现代渲染引擎都会用着色器来执行所有绘制操作：图形卡可以并行执行成千上万条指令，可以达到惊人的渲染速度。</p>
<p>因为天生就是并行的，所以着色器处理信息的方式与普通的程序有所不同。着色器代码是单独针对顶点或像素执行的。<br>无法在帧与帧之间存储数据。因此，使用着色器时，你需要使用与其他编程语言不同的编码和思考方式。<br>假设您要将纹理中的所有像素更新为给定颜色。在 GDScript 中，您的代码将使用 for 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for x in range(width):</span><br><span class="line">	for y in range(height):</span><br><span class="line">		set_color(x, y, some_color)</span><br></pre></td></tr></table></figure>
<p>在着色器中，你的代码已经是循环的一部分了，所以对应的代码应该类似这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fragment() &#123;</span><br><span class="line">    COLOR = some_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>图形卡会为需要绘制的每一个像素调用若干次 fragment() 函数。后面会详细说明。</p>
</blockquote>
<p>Godot 所提供的着色语言是基于流行的 OpenGL 着色语言（GLSL）的简化。引擎会为你处理一些底层的初始化工作，让编写复杂着色器更为简单。</p>
<p>在 Godot 中，着色器由若干主函数组成，这些函数被称为”<strong>处理器函数</strong>“。处理器函数是着色器程序的入口。有七种不同的处理器函数。</p>
<ol>
<li>vertex() 函数会为网格中的所有顶点各运行一次，用来设置顶点的位置和其他与顶点相关的变量。在 canvas_item 着色器和空间着色器中使用。</li>
<li>fragment() 函数会为网格所覆盖的所有像素各运行一次。这个函数会用到 vertex() 函数输出的值，这些值会在顶点之间进行插值。在 canvas_item 着色器和空间着色器中使用。</li>
<li>light() 函数会为每个像素和每个灯光各运行一次。这个函数会用到 fragment() 函数以及前几次运行中的变量。在 canvas_item 着色器和空间着色器中使用。</li>
<li>start() 函数会在粒子系统中的每个粒子出生时各运行一次。在粒子着色器中使用。</li>
<li>process() 函数会为粒子系统中的每个粒子每帧时各运行一次。在粒子着色器中使用。</li>
<li>sky() 函数会在辐射度立方体贴图需要更新时为辐射度立方体贴图中的每个像素各运行一次，也会为当前屏幕上的每个像素运行一次。在天空着色器中使用。</li>
<li>fog() 函数会为体积雾片段体素缓冲中与 FogVolume 相交的每个片段体素运行一次。在雾着色器中使用。<br>警告<br>如果启用了 vertex_lighting 渲染模式，或者在项目设置中启用了 Rendering &gt; Quality &gt; Shading &gt; Force Vertex Shading（渲染 &gt; 质量 &gt; 着色 &gt; 强制顶点着色），则不会运行 light() 函数。在移动平台上默认启用。<blockquote>
<p>Godot 还为用户编写完全自定义的 GLSL 着色器暴露了 API。</p>
</blockquote>
</li>
</ol>
<p>着色器类型<br>编写的着色器必须指定类型（2D、3D、粒子、天空、雾），不存在所有场景都可以使用的通用配置。<br>不同的类型支持不同的渲染模式、内置变量、处理函数。</p>
<p>在 Godot 中，所有的着色器都需要在第一行指定它们的类型，类似这样：<br><code>shader_type spatial;</code></p>
<p>有以下类型可用：</p>
<ol>
<li>用于 3D 渲染的 spatial。</li>
<li>用于 2D 渲染的 canvas_item。</li>
<li>用于粒子系统的 particles。</li>
<li>用于渲染 Skies 的 sky。</li>
<li>用于渲染 FogVolumes 的 fog。</li>
</ol>
<p>渲染模式<br>可以在着色器的第二行，也就是在着色器类型之后，指定渲染模式，类似这样：<br><code>shader_type spatial;</code><br><code>render_mode unshaded, cull_disabled;</code></p>
<p>渲染模式会修改 Godot 应用着色器的方式。<br>例如，unshaded 模式会让引擎跳过内置的光线处理器函数。</p>
<p>每种着色器类型都有不同的渲染模式。<br>每种着色器类型的完整渲染模式列表请参阅参考手册。</p>
<p>顶点处理器<br><code>vertex（）</code><br>处理函数对中的每个顶点调用一次<code>空间</code>和<code>canvas_item</code>着色器。</p>
<p>你的世界中的几何体上，每一个顶点都有位置、颜色等属性。<br>该函数会修改这些值，并将其传入片段函数。你也可以借助 <code>varying</code> 向片段着色器传递额外的数据。</p>
<p>默认情况下，Godot 会为你对顶点信息进行变换，这是将几何体投影到屏幕上所必须的。<br>可以使用渲染模式来自行变换数据；示例见 Spatial 着色器文档。</p>
<p>片段处理器<br><code>fragment（）</code> 处理函数用于设置每个像素的 Godot 材质参数。此代码在对象或图元绘制的每个可见像素上运行。它仅在空间着色器和 canvas_item 着色器中可用。</p>
<p>片段函数的标准用途是设置用于计算光照的材质属性。例如，你可以为 ROUGHNESS、RIM、TRNASMISSION 等设置值，告诉光照函数光照应该如何处理对应的片段。这样就可以控制复杂的着色管线，而不必让用户编写过多的代码。如果你不需要这一内置功能，那么你可以忽略它，自行编写光照处理函数，Godot 会将其优化掉。例如，如果你没有向 RIM 写入任何值，那么 Godot 就不会计算边缘光照。编译时，Godot 会检查是否使用了 RIM；如果没有，那么它就会把对应的代码删除。因此，你就不会在没有使用的效果上浪费算力。</p>
<p>光照处理器<br><code>light()</code> 处理器也会在每一个像素上运行，并且同时还会在每一个影响该对象的灯光上运行。如果没有灯光影响该对象则不会运行。它会被用于 fragment() 处理器，一般会在 fragment() 函数中进行材质属性设置时执行。<br>2D 和 3D 中的工作方式不同；每种工作方式的详细描述请参阅它们对应的文档 <code>CanvasItem</code> 着色器 和 <code>Spatial</code> 着色器。</p>
<h3 id="着色参考"><a href="#着色参考" class="headerlink" title="着色参考"></a>着色参考</h3><p>着色语言<br>Godot 使用类似于 GLSL ES 3.0 的着色语言。<br>数据类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td>Void 数据类型，只对不返回任何内容的函数有用。</td>
</tr>
<tr>
<td><code>bool</code></td>
<td>布尔数据类型，只能包含 true 或 false。</td>
</tr>
<tr>
<td><code>bvec2</code></td>
<td>布尔的两分量向量。</td>
</tr>
<tr>
<td><code>bvec3</code></td>
<td>布尔的三分量向量。</td>
</tr>
<tr>
<td><code>bvec4</code></td>
<td>布尔的四分量向量。</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32 位有符号标量整数。</td>
</tr>
<tr>
<td><code>ivec2</code></td>
<td>有符号整数的双分量向量。</td>
</tr>
<tr>
<td><code>ivec3</code></td>
<td>有符号整数的三分量向量。</td>
</tr>
<tr>
<td><code>ivec4</code></td>
<td>有符号整数的四分量向量。</td>
</tr>
<tr>
<td><code>uint</code></td>
<td>无符号标量整数；不能包含负数。</td>
</tr>
<tr>
<td><code>uvec2</code></td>
<td>无符号整数的两分量向量。</td>
</tr>
<tr>
<td><code>uvec3</code></td>
<td>无符号整数的三分量向量。</td>
</tr>
<tr>
<td><code>uvec4</code></td>
<td>无符号整数的四分量向量。</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32 位浮点标量。</td>
</tr>
<tr>
<td><code>vec2</code></td>
<td>浮点值的两分量向量。</td>
</tr>
<tr>
<td><code>vec3</code></td>
<td>浮点值的三分量向量。</td>
</tr>
<tr>
<td><code>vec4</code></td>
<td>浮点值的四分量向量。</td>
</tr>
<tr>
<td><code>mat2</code></td>
<td>2x2 矩阵，按列主序存储。</td>
</tr>
<tr>
<td><code>mat3</code></td>
<td>3x3 矩阵，按列主序存储。</td>
</tr>
<tr>
<td><code>mat4</code></td>
<td>4x4 矩阵，按列主序存储。</td>
</tr>
<tr>
<td><code>sampler2D</code></td>
<td>用于绑定被读取为浮点数的 2D 纹理的采样器类型。</td>
</tr>
<tr>
<td><code>isampler2D</code></td>
<td>用于绑定被读取为有符号整数的 2D 纹理的采样器类型。</td>
</tr>
<tr>
<td><code>usampler2D</code></td>
<td>用于绑定被读取为无符号整数的 2D 纹理的采样器类型。</td>
</tr>
<tr>
<td><code>sampler2DArray</code></td>
<td>用于绑定被读取为浮点数的 2D 纹理数组的采样器类型。</td>
</tr>
<tr>
<td><code>isampler2DArray</code></td>
<td>用于绑定被读取为有符号整数的 2D 纹理数组的采样器类型。</td>
</tr>
<tr>
<td><code>usampler2DArray</code></td>
<td>用于绑定被读取为无符号整数的 2D 纹理数组的采样器类型。</td>
</tr>
<tr>
<td><code>sampler3D</code></td>
<td>用于绑定被读取为浮点数的 3D 纹理的采样器类型。</td>
</tr>
<tr>
<td><code>isampler3D</code></td>
<td>用于绑定被读取为有符号整数的 3D 纹理的采样器类型。</td>
</tr>
<tr>
<td><code>usampler3D</code></td>
<td>用于绑定被读取为无符号整数的 3D 纹理的采样器类型。</td>
</tr>
<tr>
<td><code>samplerCube</code></td>
<td>用于绑定被读取为浮点数的立方体贴图的采样器类型。</td>
</tr>
<tr>
<td><code>samplerCubeArray</code></td>
<td>用于绑定立方体贴图数组的采样器类型，读取为浮点数。仅支持 Forward+ 和 Mobile，不支持 Compatibility。</td>
</tr>
<tr>
<td><code>samplerExternalOES</code></td>
<td>外部采样器类型。仅支持 Compatibility&#x2F;Android 平台。</td>
</tr>
<tr>
<td>警告</td>
<td></td>
</tr>
<tr>
<td>局部变量不会初始化为默认值，例如 0.0。如果使用变量而不先赋值，它将包含该内存位置中已经存在的任何值，并且会出现不可预测的视觉故障。但是，uniforms 和 varyings 会初始化为默认值。</td>
<td></td>
</tr>
</tbody></table>
<p>类型转换<br>与 GLSL ES 3.0 一样，不允许在大小相同但类型不同的标量和向量之间进行隐式转换。<br>也不允许强制转换不同大小的类型。转换必须通过构造函数显式完成。</p>
<p>成员<br>向量类型的单个标量成员可通过“x”、“y”、“z”和“w”成员访问。或者，使用“r”、“g”、“b”和“a”也行且效果相同。<br>对于矩阵，请使用 m[column][row] 索引语法访问每个标量，或使用 m[column] 按列索引访问向量。例如，要从 mat4 转换矩阵（第 4 列，第 2 行）访问转换的 y 分量，请使用 m[3][1] 或 m[3].y。</p>
<p>构造<br>向量类型的构造必须始终通过：</p>
<h3 id="你的第一个着色器"><a href="#你的第一个着色器" class="headerlink" title="你的第一个着色器"></a>你的第一个着色器</h3><h3 id="使用-VisualShader"><a href="#使用-VisualShader" class="headerlink" title="使用 VisualShader"></a>使用 VisualShader</h3><h3 id="使用计算着色器"><a href="#使用计算着色器" class="headerlink" title="使用计算着色器"></a>使用计算着色器</h3><h3 id="屏幕读取着色器"><a href="#屏幕读取着色器" class="headerlink" title="屏幕读取着色器"></a>屏幕读取着色器</h3><h3 id="将-GLSL-转换为-Godot-着色器"><a href="#将-GLSL-转换为-Godot-着色器" class="headerlink" title="将 GLSL 转换为 Godot 着色器"></a>将 GLSL 转换为 Godot 着色器</h3><h3 id="着色器风格指南"><a href="#着色器风格指南" class="headerlink" title="着色器风格指南"></a>着色器风格指南</h3><h3 id="使用-SubViewport-作为纹理"><a href="#使用-SubViewport-作为纹理" class="headerlink" title="使用 SubViewport 作为纹理"></a>使用 SubViewport 作为纹理</h3><h3 id="自定义后期处理"><a href="#自定义后期处理" class="headerlink" title="自定义后期处理"></a>自定义后期处理</h3><h3 id="高级后期处理"><a href="#高级后期处理" class="headerlink" title="高级后期处理"></a>高级后期处理</h3><h3 id="树木的制作"><a href="#树木的制作" class="headerlink" title="树木的制作"></a>树木的制作</h3><h2 id="用户界面（UI）"><a href="#用户界面（UI）" class="headerlink" title="用户界面（UI）"></a>用户界面（UI）</h2><h3 id="UI-构件"><a href="#UI-构件" class="headerlink" title="UI 构件"></a>UI 构件</h3><h4 id="大小和锚点"><a href="#大小和锚点" class="headerlink" title="大小和锚点"></a>大小和锚点</h4><p>不同分辨率摆放控件不容易，需要考虑不同的宽高比、分辨率和用户缩放比例。<br>怎么弄？<br>通过编辑控件的<strong>锚点偏移量</strong>来实现，其行为类似于边距。<br>要访问这些设置，需要先选择<strong>自定义</strong>锚点预设。</p>
<p>每个控件都有四个边距：左、右、底、顶，分别与控件的边缘相对应。<br>都表示相对于父控件的左上角或视口（在没有父控件的情况下）的像素距离。</p>
<p>要使控件变宽，可以增大右边距和&#x2F;或减小左边距。这使你可以设置控件的精确位置和形状。</p>
<p>锚点属性调整偏移量相对于的位置 。每个偏移都有一个单独的锚点，可以从父项的开始到结束进行调整。因此，垂直（顶部、底部）锚点从 0.0（父级的顶部）调整为 1.0（父级的底部）， 其中 0.5 为中心，并且控制偏移量将相对于该点放置。水平（左、右）锚点类似地从父项的左到右调整。</p>
<p>请注意，当你希望控件的边缘位于锚点的上方或左侧时，必须将边距值更改为负数。</p>
<p>使控件居中<br>要将控件在其父控件内居中，请将锚点都设置为 0.5， 每侧边距为其相关尺寸的一半。例如， 下面的代码显示了如何将 TextureRect 在它的父节点内居中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var rect = TextureRect.new()</span><br><span class="line">rect.texture = load(&quot;res://icon.png&quot;)</span><br><span class="line">rect.anchor_left = 0.5</span><br><span class="line">rect.anchor_right = 0.5</span><br><span class="line">rect.anchor_top = 0.5</span><br><span class="line">rect.anchor_bottom = 0.5</span><br><span class="line">var texture_size = rect.texture.get_size()</span><br><span class="line">rect.offset_left = -texture_size.x / 2</span><br><span class="line">rect.offset_right = texture_size.x / 2</span><br><span class="line">rect.offset_top = -texture_size.y / 2</span><br><span class="line">rect.offset_bottom = texture_size.y / 2</span><br><span class="line">add_child(rect)</span><br></pre></td></tr></table></figure>
<p>将每个锚定值设置为0.5, 将边缘的参考点移动到父锚点的中心. 在此基础上, 我们设置了负边距, 以便控件获得其自然大小.</p>
<p>布局预设<br>除了手动调整边距和锚点的值之外，你还可以使用视口上方工具栏中的“布局”菜单。其中有居中等诸多选项，可以用来对齐并调整节点的大小。</p>
<h3 id="GUI-外观与主题"><a href="#GUI-外观与主题" class="headerlink" title="GUI 外观与主题"></a>GUI 外观与主题</h3><p>虽然 Control 节点具有开箱即用的功能外观，但始终有独特性和特定于案例的调整空间。<br>为此，Godot 引擎包括一个用于 GUI 换肤（或主题化）的系统，它允许你自定义用户界面中每个控件的外观，包括你的自定义控件。<br>下面是这个系统的一个例子—— 一个游戏的 GUI 与引擎的默认 UI 主题完全不同：<br>除了为你的游戏实现独特的外观外，该系统还使开发人员能够为最终用户提供自定义选项，包括交互设置。 UI 主题以级联方式应用（即从父控件传播到其子控件），这意味着色盲用户的字体设置或调整，可以在从某处应用并影响整个 UI 树。当然，这个系统也可以用于游戏：基于英雄的游戏可以为选定的玩家角色改变其风格，或者你可以为基于团队的项目中的双方赋予不同的风格。</p>
<p>主题基础知识<br>皮肤系统由 Theme 资源驱动。每个 Godot 项目都有一个固有的默认主题，其中包含内置控制节点使用的设置。这就是使控件具有开箱即用的独特外观的原因。然而，主题仅用于描述配置，并且每个单独控件的工作仍然是按照显示自身所需的方式使用该配置。在实现 你自己的自定义控件时要记住这一点很重要。</p>
<p>备注<br>甚至 Godot 编辑器本身也依赖于默认主题。但它看起来与 Godot 项目不同，因为它在默认主题之上应用了自己高度定制的主题。原则上，这与在你的游戏中的工作方式完全相同，如下所述。</p>
<p>主题项目<br>存储在一个主题中的配置由主题项目组成。每个项目都有一个唯一的名称，并且必须是以下数据类型之一：</p>
<ol>
<li>color 值</li>
<li>常量，整型值，可用于控件的数字类型属性（例如 BoxContainer 的间隙设置）或布尔值标记（例如 Tree 中是否绘制关系线条）。</li>
<li>字体（font），常常被用于显示控件中的文字。字体包含了许多渲染设置，像字体的大小和颜色。之后呢，用另一个单独的控件来控制对齐属性和文字方向。</li>
<li>Font size整数值，与字体一同使用，决定文本显示的大小。</li>
<li>图标，纹理资源，通常用于显示图标。</li>
<li>样式盒<br>一个样式盒资源（StyleBox），是一个用来定义一个UI面板怎样展示的配置项集合。不只是用于面板控件（Panel），它还常常用于许多控件的背景设置和遮罩设置。<br>不同的控件将以不同的方式应用 StyleBox。尤其是 焦点样式框被绘制为其他样式框的覆盖层（例如 normal 或按下 ）以允许基本样式框保持可见。这意味着焦点样式框应设计为轮廓或半透明框，以便其背景保持可见。</li>
</ol>
<p>主题类型<br>为了更好地组织一个主题的结构，主题中的项目被划分为多个类型，并且每个项目只能属于单个类型。每个主题项目由其名称、数据类型和主题中的类型这个三元组来定义。这个三元组在主题中必须是唯一的。例如，Label 类型中不能有两个叫做 font_color 的颜色项目，但是在 LineEdit 类型中可以有另一个叫做 font_color 的项目。</p>
<p>Godot 的默认主题诞生之初就已经定义了众多的主题类型，它内建于每个使用了 UI 皮肤的控件节点中。在默认主题里上述例子都是目前再用的主题项目。你可以在每个控件的类参考手册中查看主题属性区域看看哪些项目是父类和子类都可用的。</p>
<p>子类可以使用为其父类定义的主题项，Button 及其派生类型就是很好实例。事实上，如果需要的话，每个控件都可以使用任何主题类型的单个主题项，但为了清晰可控，在引擎中尽量避免这样做。<br>牢记子类中，哪些过程是自动执行的很重要.不论什么时候内建控件在主题里面请求主题项目时，我们可以忽略主题类型仅通过它的类名知悉。之后呢，下次时我们能根据它的父级类名来使用.可以通过改变父级类，例如 Button，来影响所有派生类，而不是调整每一个类来实现。</p>
<p>还可以定义自己的主题类型，并另外自定义内置控件和您自己的控件。由于内置控件不知道自定义主题类型，因此必须使用脚本来访问这些项。所有控制节点都有多种方法，允许您从应用于它们的主题中获取主题项。这些方法接受主题类型作为参数之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var accent_color = get_theme_color(&quot;accent_color&quot;, &quot;MyType&quot;)</span><br><span class="line">label.add_theme_color_override(&quot;font_color&quot;, accent_color)</span><br></pre></td></tr></table></figure>
<p>为了提供更多的自定义可能性，类型还能够链接在一起成为变种。这是自定义主题类型的另一种使用场景。例如，主题可以包含 Header 类型，标记为基础 Label 类型的变种。那么各个 Label 控件就可以将其类型设为使用 Header 变种，主题请求主题项目的时候，这个变种都会先于其他类型使用。这样就可以在同一个 Theme 资源里为同样使用某个类的控件节点保存不同主题项目的预设值。</p>
<p>警告<br>只有默认主题或者自定义项目主题中的变种才会在“检查器”中列为可选项。在这两处之外定义的变种名称仍然可以手动输入，但是建议把所有变种都放到项目主题里面。</p>
<p>自定义控件<br>可以不用主题直接对各个控件节点进行自定义。这种方式称为本地重载。控件的类参考手册中列出的每个主题属性，无论是通过检查器面板还是脚本，都可以在该控件上直接重载。这样就可以针对 UI 中的特定部份进行精细的修改，不影响项目中包括该控件子类在内的其他内容。</p>
<p>本地重载对于提升用户界面的美观程度意义不大，如果你注重一致性的话就更是如此。然而，本地重载对于布局节点而言是不可或缺的。BoxContainer 和 GridContainer 等节点通过主题常量定义其子节点的间隙大小，MarginContainer 用主题项目来保存自定义边距。<br>控件存在本地主题项目重载时，会直接使用这个值，主题中所提供的值会被忽略。</p>
<p>自定义项目<br>所有全新项目使用的都是 Godot 提供的默认项目主题。默认主题本身是常量，无法修改，但可以通过自定义主题进行覆盖。设置自定义主题有两种方法：修改项目设置，或者修改场景树控件节点的节点属性。</p>
<p>There are two project settings that can be adjusted to affect your entire project: GUI &gt; Theme &gt; Custom allows you to set a custom project-wide theme, and GUI &gt; Theme &gt; Custom Font does the same to the default fallback font. When a theme item is requested by a control node the custom project theme, if present, is checked first. Only if it doesn’t have the item the default theme is checked.<br>可以调整两个项目设置以影响整个项目： GUI &gt; 主题 &gt; 自定义允许您设置自定义项目范围的主题， 以及 GUI &gt; 主题 &gt; 自定义字体 对默认回退字体执行相同的作。当控件请求主题项时 节点自定义项目主题（如果存在）将首先检查。只有当它没有 选中默认主题的项目。</p>
<p>在一个单独的主题资源中，你可以设置所有 Godot 控件的默认样式与外观,但是你可以做更多的细节调整.每一个控件节点同样拥有一个主题属性，通过这个属性你可以为一个控件的所有节点分支设置一个自定义的主题.那意味着那个控件与其所有的子类，和子类的子类，在回滚当前项目和默认主题之前自定义主题的资源将第一个被检查。</p>
<p>备注</p>
<p>计划设定作为一种变化的替代手段，可以让你通过设置自定义主题资源对几乎整个UI分支中的根控件节点做出相同的影响. 然而运行计划项目时可以充当预期效果展示,当单独场景直接预览或者运行时还将使用默认主题展示。为了解决这个问题你可以为每一个单独场景中的根控件设置相同的主题资源.</p>
<p>例如，你可以在项目主题中为按钮设置特定的样式，希望在弹出对话框中的按钮又有不同的外观。你可以为弹出窗口的根控件设置自定义主题资源，并在该资源中为按钮定义不同的样式。只要弹出窗口的根控件和按钮之间的节点链不中断，这些按钮就会使用最接近它们的主题资源中定义的样式。所有其他控件仍将使用整个项目的主题和默认的主题样式。</p>
<p>综上所述，对于任意控件，其主题项的查找会是这样的：</p>
<p>检查相同数据类型和名称的本地重写。</p>
<p>使用控件的类型变体、类名和父类名：</p>
<p>从自身开始检查每个控件，看看它是否设置了主题属性；</p>
<p>如果设置了，就在该主题中查找名称、数据、主题类型都相同的项目；</p>
<p>如果没有自定义主题，或者主题中没有匹配的条目，就前往父控件；</p>
<p>重复步骤 a 至 c，到场景树的根节点或者非控件节点为止。</p>
<p>如果存在项目范围的主题，就在这个主题中查找控件的类型变体、类名和父类名。</p>
<p>在默认主题中查找控件的类型变体、类名和父类名。</p>
<p>即便所有主题中都不存在对应的项目，也会返回一个针对该数据类型的默认值。</p>
<p>超越控件<br>主题是一种用来保存视觉效果配置的理想资源，也非常合理。<br>虽然其他节点并没有像控件节点一样内置针对主题的支持，但还是可以和使用其他资源一样来使用主题。</p>
<p>举个非控件使用主题的例子：在策略游戏中，相同单位需要根据队伍的不同而使用不同颜色的精灵。可以在主题资源中定义颜色的合集，精灵（在脚本的帮助下）就可以使用这些颜色来绘制纹理。这样做的最大好处是可以为红绿蓝队制作不同的主题但使用相同的主题项目，切换队伍只需要替换资源就可以了。</p>
<h3 id="控件节点教程"><a href="#控件节点教程" class="headerlink" title="控件节点教程"></a>控件节点教程</h3><p>主题编辑器是底部面板工具，当一个 Theme 资源被选中进行编辑时，面板会自动激活。面板包含了添加、删除和调整主题类型和主题项目的必要用户界面。面板有一个预览区，用于测试你做出的变化，以及一个窗口对话框，用于对主题项目进行批量操作。</p>
<h2 id="XR"><a href="#XR" class="headerlink" title="XR"></a>XR</h2><mark class="hl-label red">暂不考虑</mark>
<h3 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h3><p>内置了一套模块化扩展现实（XR）系统，该系统通过抽象化不同 XR 平台的底层实现细节，以简化跨平台 XR 应用的开发流程。<br>该系统的核心是 XRServer 类，它作为整个 XR 架构的中枢接口，允许开发者通过该接口发现并连接各类 XR 运行时环境。</p>
<h3 id="高级专题"><a href="#高级专题" class="headerlink" title="高级专题"></a>高级专题</h3><h3 id="Godot-XR-工具"><a href="#Godot-XR-工具" class="headerlink" title="Godot XR 工具"></a>Godot XR 工具</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wzcwzc10.github.io">微光zc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/">https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wzcwzc10.github.io" target="_blank">微光zc的网络小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Godot/">Godot</a><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/%E6%96%87%E6%A1%A3/">文档</a></div><div class="post-share"><div class="social-share" data-image="/./img/jufufu-ht.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>来一杯燃油饮</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/14/Godot4.4%20%E7%B1%BB%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/" title="Godot4.4 类参考总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Godot4.4 类参考总结</div></div><div class="info-2"><div class="info-item-1">Godot4.4 类参考总结</div></div></div></a><a class="pagination-related" href="/2025/09/14/Blender%E5%AF%BC%E5%85%A5PMX%E6%A8%A1%E5%9E%8B/" title="Blender导入PMX模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Blender导入PMX模型</div></div><div class="info-2"><div class="info-item-1">Blender导入PMX模型</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/14/Godot4.4%20%E7%B1%BB%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/" title="Godot4.4 类参考总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-14</div><div class="info-item-2">Godot4.4 类参考总结</div></div><div class="info-2"><div class="info-item-1">Godot4.4 类参考总结</div></div></div></a><a class="pagination-related" href="/2025/08/10/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%9C%89%E6%84%9F%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/" title="读Godot4.4文档有感（长期更新）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-10</div><div class="info-item-2">读Godot4.4文档有感（长期更新）</div></div><div class="info-2"><div class="info-item-1">读Godot4.4文档有感</div></div></div></a><a class="pagination-related" href="/2025/08/02/Godot%20IP%E5%9C%B0%E5%9D%80P2P%E8%81%94%E6%9C%BA/" title="Godot IP地址P2P联机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-02</div><div class="info-item-2">Godot IP地址P2P联机</div></div><div class="info-2"><div class="info-item-1">Godot IP地址P2P联机</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/jufufu-ht.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">微光zc</div><div class="author-info-description">一个有想法的极客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/178083315"><i class="fab fa-bilibili"></i><span>关注我！</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">世界全剧终，欢迎来到my blog！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%8C"><span class="toc-number">1.</span> <span class="toc-text">手册</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.1.</span> <span class="toc-text">最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Godot-%E4%B8%AD%E5%BA%94%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.1.</span> <span class="toc-text">在 Godot 中应用面向对象原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">场景组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E5%9C%B0%E5%BB%BA%E7%AB%8B%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">如何有效地建立关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%8A%82%E7%82%B9%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">选择节点树结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E8%84%9A%E6%9C%AC"><span class="toc-number">1.1.3.</span> <span class="toc-text">何时使用场景与脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">匿名类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%9A%84%E7%B1%BB%E5%9E%8B-%E6%B3%A8%E5%86%8C%E6%96%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">命名的类型(注册新类型)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Script-%E4%B8%8E-PackedScene-%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">Script 与 PackedScene 的性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%B8%B8%E8%A7%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">自动加载与常规节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E5%89%B2%E9%9F%B3%E9%A2%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">切割音频问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E6%88%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">管理共享功能或数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%BA%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">何时应使用自动加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BB%BB%E4%BD%95%E4%BA%8B%E6%83%85%E4%BD%BF%E7%94%A8%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.5.</span> <span class="toc-text">何时以及如何避免为任何事情使用节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.6.</span> <span class="toc-text">Godot 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">获取对象引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E6%88%96%E9%80%BB%E8%BE%91"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">从对象访问数据或逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-%E9%80%9A%E7%9F%A5"><span class="toc-number">1.1.7.</span> <span class="toc-text">Godot 通知</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-process%E3%80%81-physics-process%E3%80%81-input"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">对比 _process、_physics_process、*_input</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-init%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E5%AF%BC%E5%87%BA"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">对比 _init、初始化、导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-ready%E3%80%81-enter-tree%E3%80%81NOTIFICATION-PARENTED"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">对比 _ready、_enter_tree、NOTIFICATION_PARENTED</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%81%8F%E5%A5%BD"><span class="toc-number">1.1.8.</span> <span class="toc-text">数据偏好</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E3%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">数组、字典、对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%9A%E6%95%B4%E6%95%B0-VS-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">枚举：整数 VS 字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnimatedTexture-vs-AnimatedSprite2D-vs-AnimationPlayer-vs-AnimationTree"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%81%8F%E5%A5%BD"><span class="toc-number">1.1.9.</span> <span class="toc-text">逻辑偏好</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E8%BF%98%E6%98%AF%E5%85%88%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">先添加节点还是先修改属性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-VS-%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">加载 VS 预加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%9E%8B%E5%85%B3%E5%8D%A1%EF%BC%9A%E9%9D%99%E6%80%81-VS-%E5%8A%A8%E6%80%81"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">大型关卡：静态 VS 动态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.10.</span> <span class="toc-text">项目组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">风格指南</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5"><span class="toc-number">1.1.10.3.</span> <span class="toc-text">导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F"><span class="toc-number">1.1.10.4.</span> <span class="toc-text">大小写敏感</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.11.</span> <span class="toc-text">版本控制系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-number">1.2.</span> <span class="toc-text">故障排除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.</span> <span class="toc-text">编辑器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E7%95%8C%E9%9D%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">编辑器的界面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">项目管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inspector-Dock"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Inspector Dock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">项目设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">脚本编辑器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E9%BB%98%E8%AE%A4%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">编辑器默认快捷键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%95%8C%E9%9D%A2"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">自定义界面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XR-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">XR 编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">Android 编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">Web 编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.5.</span> <span class="toc-text">高级功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%95%99%E7%A8%8B"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">命令行教程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">使用外部的文本编辑器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%BC%96%E8%BE%91%E5%99%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.6.</span> <span class="toc-text">管理编辑器功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2D"><span class="toc-number">1.4.</span> <span class="toc-text">2D</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2D-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">2D 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E5%B8%83%E5%B1%82"><span class="toc-number">1.4.2.</span> <span class="toc-text">画布层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%94%BB%E5%B8%83%E5%8F%98%E6%8D%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">视口变换与画布变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%BB%E5%B8%83%E5%8F%98%E6%8D%A2"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">画布变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E4%BC%B8%E5%8F%98%E6%8D%A2"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">拉伸变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%8F%98%E6%8D%A2"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">窗口变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">变换顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">变换函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">提供自定义输入事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">1.4.4.</span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E7%81%AF%E5%85%89%E5%92%8C%E9%98%B4%E5%BD%B1"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">2D 灯光和阴影</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E7%BD%91%E6%A0%BC"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">2D 网格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E7%B2%BE%E7%81%B5%E5%8A%A8%E7%94%BB"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">2D 精灵动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">2D 粒子系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParticleProcessMaterial-2D-%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">ParticleProcessMaterial 2D 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="toc-number">1.4.4.6.</span> <span class="toc-text">2D 抗锯齿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%9B%BE"><span class="toc-number">1.4.4.7.</span> <span class="toc-text">2D 中的自定义绘图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2D-%E8%A7%86%E5%B7%AE"><span class="toc-number">1.4.4.8.</span> <span class="toc-text">2D 视差</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E4%B8%8E%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text">物理与移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">1.4.6.</span> <span class="toc-text">工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-TileSet"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">使用 TileSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-TileMap"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">使用 TileMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3D"><span class="toc-number">1.5.</span> <span class="toc-text">3D</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">3D 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">基础操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node3D-%E8%8A%82%E7%82%B9"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">Node3D 节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-3D-%E5%8F%98%E6%8D%A2"><span class="toc-number">1.5.2.</span> <span class="toc-text">使用 3D 变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AC%A7%E6%8B%89%E8%A7%92%E8%AF%B4%E4%B8%8D"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">对欧拉角说不</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">变换的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%8F%98%E6%8D%A2"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">操作变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%A6%E8%AF%AF%E5%B7%AE"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">度误差</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">获取信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">设置信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0%E6%8F%92%E5%80%BC"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">用四元数插值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%BC%8F%E5%87%A0%E4%BD%95%E4%BD%93"><span class="toc-number">1.5.3.</span> <span class="toc-text">程序式几何体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%EF%BC%88Mesh%EF%BC%89"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">网格（Mesh）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%9D%A2"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">表面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%9D%A2%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">表面数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7-1"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ArrayMesh"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">使用 ArrayMesh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-MeshDataTool"><span class="toc-number">1.5.3.6.</span> <span class="toc-text">使用 MeshDataTool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-SurfaceTool"><span class="toc-number">1.5.3.7.</span> <span class="toc-text">使用 SurfaceTool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ImmediateMesh"><span class="toc-number">1.5.3.8.</span> <span class="toc-text">使用 ImmediateMesh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA%EF%BC%9F"><span class="toc-number">1.5.3.9.</span> <span class="toc-text">应该使用哪一个？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-%E6%96%87%E6%9C%AC"><span class="toc-number">1.5.4.</span> <span class="toc-text">3D 文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93-1"><span class="toc-number">1.5.5.</span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3D-%E6%B8%B2%E6%9F%93%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">3D 渲染的局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86-3D-%E6%9D%90%E8%B4%A8%E4%B8%8E-ORM-3D-%E6%9D%90%E8%B4%A8"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">标准 3D 材质与 ORM 3D 材质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3D-%E7%81%AF%E5%85%89%E5%92%8C%E9%98%B4%E5%BD%B1"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">3D 灯光和阴影</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B4%B4%E8%8A%B1"><span class="toc-number">1.5.5.4.</span> <span class="toc-text">使用贴花</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%81%AF%E5%85%89%E5%92%8C%E7%9B%B8%E6%9C%BA%E5%8D%95%E4%BD%8D"><span class="toc-number">1.5.5.5.</span> <span class="toc-text">物理灯光和相机单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%883D%EF%BC%89"><span class="toc-number">1.5.5.6.</span> <span class="toc-text">粒子系统（3D）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E5%85%89%E7%85%A7"><span class="toc-number">1.5.5.7.</span> <span class="toc-text">高动态范围光照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7"><span class="toc-number">1.5.5.8.</span> <span class="toc-text">全局光照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%92%8C%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">1.5.5.9.</span> <span class="toc-text">环境和后期处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%93%E7%A7%AF%E9%9B%BE%E5%92%8C%E9%9B%BE%E4%BD%93%E7%A7%AF"><span class="toc-number">1.5.5.10.</span> <span class="toc-text">体积雾和雾体积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3D-%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="toc-number">1.5.5.11.</span> <span class="toc-text">3D 抗锯齿</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.6.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-MultiMeshInstance3D"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">使用 MultiMeshInstance3D</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E7%9A%84%E7%BB%86%E8%8A%82%E7%BA%A7%E5%88%AB%EF%BC%88LOD%EF%BC%89"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">网格的细节级别（LOD）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E8%8C%83%E5%9B%B4%EF%BC%88HLOD%EF%BC%89"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">可见范围（HLOD）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4"><span class="toc-number">1.5.6.4.</span> <span class="toc-text">遮挡剔除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%BE%A8%E7%8E%87%E7%BC%A9%E6%94%BE"><span class="toc-number">1.5.6.5.</span> <span class="toc-text">分辨率缩放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%80%9F%E7%8E%87%E7%9D%80%E8%89%B2"><span class="toc-number">1.5.6.6.</span> <span class="toc-text">可变速率着色</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7-2"><span class="toc-number">1.5.7.</span> <span class="toc-text">工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-CSG-%E8%AE%BE%E8%AE%A1%E5%85%B3%E5%8D%A1%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">使用 CSG 设计关卡原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-GridMap"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">使用 GridMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%BC%B9%E7%B0%A7%E8%87%82%E7%9A%84%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0%E7%9B%B8%E6%9C%BA"><span class="toc-number">1.5.7.3.</span> <span class="toc-text">带弹簧臂的第三人称相机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">1.6.</span> <span class="toc-text">动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.1.</span> <span class="toc-text">动画功能介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E8%BD%A8%E9%81%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">动画轨道类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AA%E7%BA%B8%E5%8A%A8%E7%94%BB"><span class="toc-number">1.6.3.</span> <span class="toc-text">剪纸动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2D-%E9%AA%A8%E6%9E%B6"><span class="toc-number">1.6.4.</span> <span class="toc-text">2D 骨架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-AnimationTree"><span class="toc-number">1.6.5.</span> <span class="toc-text">使用 AnimationTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91"><span class="toc-number">1.6.6.</span> <span class="toc-text">播放视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%B5%E5%BD%B1"><span class="toc-number">1.6.7.</span> <span class="toc-text">创建电影</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%BA%BF"><span class="toc-number">1.7.</span> <span class="toc-text">资产管线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">导入流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%9B%BE%E5%83%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">导入图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E9%9F%B3%E9%A2%91%E9%87%87%E6%A0%B7"><span class="toc-number">1.7.3.</span> <span class="toc-text">导入音频采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E7%BF%BB%E8%AF%91"><span class="toc-number">1.7.4.</span> <span class="toc-text">导入翻译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-3D-%E5%9C%BA%E6%99%AF"><span class="toc-number">1.7.5.</span> <span class="toc-text">导入 3D 场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-%E9%AA%A8%E6%9E%B6%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.7.6.</span> <span class="toc-text">3D 骨架重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA-3D-%E5%9C%BA%E6%99%AF"><span class="toc-number">1.7.7.</span> <span class="toc-text">导出 3D 场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91"><span class="toc-number">1.8.</span> <span class="toc-text">音频</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E6%80%BB%E7%BA%BF"><span class="toc-number">1.8.1.</span> <span class="toc-text">音频总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E7%89%B9%E6%95%88"><span class="toc-number">1.8.2.</span> <span class="toc-text">音频特效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E6%B5%81"><span class="toc-number">1.8.3.</span> <span class="toc-text">音频流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E4%B8%8E%E9%9F%B3%E9%A2%91%E5%92%8C%E9%9F%B3%E4%B9%90%E5%90%8C%E6%AD%A5"><span class="toc-number">1.8.4.</span> <span class="toc-text">将游戏玩法与音频和音乐同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BA%A6%E5%85%8B%E9%A3%8E%E5%BD%95%E9%9F%B3"><span class="toc-number">1.8.5.</span> <span class="toc-text">使用麦克风录音</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E8%BD%AC%E8%AF%AD%E9%9F%B3"><span class="toc-number">1.8.6.</span> <span class="toc-text">文本转语音</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.</span> <span class="toc-text">导出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.9.1.</span> <span class="toc-text">导出项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%8C%85%E3%80%81%E8%A1%A5%E4%B8%81%E3%80%81Mod"><span class="toc-number">1.9.2.</span> <span class="toc-text">导出包、补丁、Mod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%A0%87%E7%AD%BE"><span class="toc-number">1.9.3.</span> <span class="toc-text">功能标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-Windows-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.4.</span> <span class="toc-text">为 Windows 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-Android-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.5.</span> <span class="toc-text">为 Android 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-macOS-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.6.</span> <span class="toc-text">为 macOS 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-iOS-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.7.</span> <span class="toc-text">为 iOS 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-Web-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.8.</span> <span class="toc-text">为 Web 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2"><span class="toc-number">1.9.9.</span> <span class="toc-text">一键部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.10.</span> <span class="toc-text">为专用服务器导出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E6%95%B0%E6%8D%AE-I-O"><span class="toc-number">1.10.</span> <span class="toc-text">文件与数据 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.10.1.</span> <span class="toc-text">后台加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-number">1.10.2.</span> <span class="toc-text">Godot 项目中的文件路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F"><span class="toc-number">1.10.3.</span> <span class="toc-text">保存游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98"><span class="toc-number">1.10.4.</span> <span class="toc-text">运行时文件加载和保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96-API"><span class="toc-number">1.10.5.</span> <span class="toc-text">二进制序列化 API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">1.11.</span> <span class="toc-text">国际化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E7%9A%84%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">1.11.1.</span> <span class="toc-text">游戏的国际化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%94%B5%E5%AD%90%E8%A1%A8%E6%A0%BC%E8%BF%9B%E8%A1%8C%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="toc-number">1.11.2.</span> <span class="toc-text">使用电子表格进行本地化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-gettext%EF%BC%88PO-%E6%96%87%E4%BB%B6%EF%BC%89%E8%BF%9B%E8%A1%8C%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="toc-number">1.11.3.</span> <span class="toc-text">使用 gettext（PO 文件）进行本地化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81"><span class="toc-number">1.11.4.</span> <span class="toc-text">区域设置代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="toc-number">1.11.5.</span> <span class="toc-text">伪本地化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86"><span class="toc-number">1.12.</span> <span class="toc-text">输入处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-InputEvent"><span class="toc-number">1.12.1.</span> <span class="toc-text">使用 InputEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.12.2.</span> <span class="toc-text">输入示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E5%92%8C%E8%BE%93%E5%85%A5%E5%9D%90%E6%A0%87"><span class="toc-number">1.12.3.</span> <span class="toc-text">鼠标和输入坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BC%A0%E6%A0%87%E5%85%89%E6%A0%87"><span class="toc-number">1.12.4.</span> <span class="toc-text">自定义鼠标光标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E3%80%81%E6%89%8B%E6%9F%84%E5%92%8C%E6%91%87%E6%9D%86"><span class="toc-number">1.12.5.</span> <span class="toc-text">控制器、手柄和摇杆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%80%80%E5%87%BA%E8%AF%B7%E6%B1%82"><span class="toc-number">1.12.6.</span> <span class="toc-text">处理退出请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-number">1.13.</span> <span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E6%95%B0%E5%AD%A6"><span class="toc-number">1.13.1.</span> <span class="toc-text">向量数学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%AD%89%E5%90%91%E9%87%8F%E6%95%B0%E5%AD%A6"><span class="toc-number">1.13.2.</span> <span class="toc-text">高等向量数学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%8F%98%E6%8D%A2"><span class="toc-number">1.13.3.</span> <span class="toc-text">矩阵与变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC"><span class="toc-number">1.13.4.</span> <span class="toc-text">插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9D%E5%A1%9E%E5%B0%94%E3%80%81%E6%9B%B2%E7%BA%BF%E5%92%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">1.13.5.</span> <span class="toc-text">贝塞尔、曲线和路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90"><span class="toc-number">1.13.6.</span> <span class="toc-text">随机数生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA"><span class="toc-number">1.14.</span> <span class="toc-text">导航</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2D-%E5%AF%BC%E8%88%AA%E6%A6%82%E8%BF%B0"><span class="toc-number">1.14.1.</span> <span class="toc-text">2D 导航概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-%E5%AF%BC%E8%88%AA%E6%A6%82%E8%BF%B0"><span class="toc-number">1.14.2.</span> <span class="toc-text">3D 导航概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationServer"><span class="toc-number">1.14.3.</span> <span class="toc-text">使用 NavigationServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%88%AA%E5%9C%B0%E5%9B%BE"><span class="toc-number">1.14.4.</span> <span class="toc-text">使用导航地图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%88%AA%E5%8C%BA%E5%9D%97"><span class="toc-number">1.14.5.</span> <span class="toc-text">使用导航区块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC"><span class="toc-number">1.14.6.</span> <span class="toc-text">使用导航网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationPath"><span class="toc-number">1.14.7.</span> <span class="toc-text">使用 NavigationPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationPathQueryObject"><span class="toc-number">1.14.8.</span> <span class="toc-text">使用 NavigationPathQueryObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationAgent"><span class="toc-number">1.14.9.</span> <span class="toc-text">使用 NavigationAgent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationObstacle"><span class="toc-number">1.14.10.</span> <span class="toc-text">使用 NavigationObstacle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationLink"><span class="toc-number">1.14.11.</span> <span class="toc-text">使用 NavigationLink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-NavigationLayer"><span class="toc-number">1.14.12.</span> <span class="toc-text">使用 NavigationLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">1.14.13.</span> <span class="toc-text">导航调试工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC"><span class="toc-number">1.14.14.</span> <span class="toc-text">连接导航网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E8%A7%92%E8%89%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.14.15.</span> <span class="toc-text">支持不同角色类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E8%A7%92%E8%89%B2%E8%BF%90%E5%8A%A8"><span class="toc-number">1.14.16.</span> <span class="toc-text">支持不同角色运动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E8%A7%92%E8%89%B2%E5%8C%BA%E5%9F%9F%E6%9D%83%E9%99%90"><span class="toc-number">1.14.17.</span> <span class="toc-text">支持不同角色区域权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">1.15.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F"><span class="toc-number">1.15.1.</span> <span class="toc-text">高级多人游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C-HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-number">1.15.2.</span> <span class="toc-text">进行 HTTP 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%B1%BB"><span class="toc-number">1.15.3.</span> <span class="toc-text">HTTP 客户端类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-SSL-%E8%AF%81%E4%B9%A6"><span class="toc-number">1.15.4.</span> <span class="toc-text">TLS&#x2F;SSL 证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-WebSockets"><span class="toc-number">1.15.5.</span> <span class="toc-text">Using WebSockets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebRTC"><span class="toc-number">1.15.6.</span> <span class="toc-text">WebRTC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">1.16.</span> <span class="toc-text">性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84"><span class="toc-number">1.16.1.</span> <span class="toc-text">常规</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU"><span class="toc-number">1.16.2.</span> <span class="toc-text">CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU"><span class="toc-number">1.16.3.</span> <span class="toc-text">GPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D-1"><span class="toc-number">1.16.4.</span> <span class="toc-text">3D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.16.5.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86"><span class="toc-number">1.17.</span> <span class="toc-text">物理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.17.1.</span> <span class="toc-text">物理介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Jolt-Physics"><span class="toc-number">1.17.2.</span> <span class="toc-text">Using Jolt Physics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-RigidBody"><span class="toc-number">1.17.3.</span> <span class="toc-text">使用 RigidBody</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Area2D"><span class="toc-number">1.17.4.</span> <span class="toc-text">使用 Area2D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-CharacterBody2D-3D"><span class="toc-number">1.17.5.</span> <span class="toc-text">使用 CharacterBody2D&#x2F;3D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B0%84%E5%B0%84%E7%BA%BF"><span class="toc-number">1.17.6.</span> <span class="toc-text">发射射线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%A8%83%E5%A8%83%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.17.7.</span> <span class="toc-text">布娃娃系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E5%8A%A8%E5%AD%A6%E8%A7%92%E8%89%B2%EF%BC%882D%EF%BC%89"><span class="toc-number">1.17.8.</span> <span class="toc-text">运动学角色（2D）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-SoftBody3D"><span class="toc-number">1.17.9.</span> <span class="toc-text">Using SoftBody3D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E5%BD%A2%E7%8A%B6%EF%BC%882D%EF%BC%89"><span class="toc-number">1.17.10.</span> <span class="toc-text">碰撞形状（2D）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E5%BD%A2%E7%8A%B6%EF%BC%883D%EF%BC%89"><span class="toc-number">1.17.11.</span> <span class="toc-text">碰撞形状（3D）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87"><span class="toc-number">1.17.12.</span> <span class="toc-text">大世界坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%8F%92%E5%80%BC"><span class="toc-number">1.17.13.</span> <span class="toc-text">物理插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-number">1.17.14.</span> <span class="toc-text">物理问题的故障排除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3"><span class="toc-number">1.18.</span> <span class="toc-text">平台相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android"><span class="toc-number">1.18.1.</span> <span class="toc-text">Android</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iOS-%E6%8F%92%E4%BB%B6"><span class="toc-number">1.18.2.</span> <span class="toc-text">iOS 插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web"><span class="toc-number">1.18.3.</span> <span class="toc-text">Web</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-%E7%9A%84%E6%B8%B8%E6%88%8F%E4%B8%BB%E6%9C%BA%E6%94%AF%E6%8C%81"><span class="toc-number">1.18.4.</span> <span class="toc-text">Godot 的游戏主机支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6"><span class="toc-number">1.19.</span> <span class="toc-text">插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E6%8F%92%E4%BB%B6"><span class="toc-number">1.19.1.</span> <span class="toc-text">编辑器插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E6%8F%92%E4%BB%B6"><span class="toc-number">1.19.1.1.</span> <span class="toc-text">制作插件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">1.19.2.</span> <span class="toc-text">在编辑器中运行代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93-2"><span class="toc-number">1.20.</span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%8F%A3"><span class="toc-number">1.20.1.</span> <span class="toc-text">使用视口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%88%86%E8%BE%A8%E7%8E%87"><span class="toc-number">1.20.2.</span> <span class="toc-text">多分辨率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%8A%96%E5%8A%A8%E3%80%81%E5%8D%A1%E9%A1%BF%E5%92%8C%E8%BE%93%E5%85%A5%E5%BB%B6%E8%BF%9F"><span class="toc-number">1.20.3.</span> <span class="toc-text">修复抖动、卡顿和输入延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%99%A8"><span class="toc-number">1.20.4.</span> <span class="toc-text">合成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-number">1.20.5.</span> <span class="toc-text">渲染器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC"><span class="toc-number">1.21.</span> <span class="toc-text">编写脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GDScript"><span class="toc-number">1.21.1.</span> <span class="toc-text">GDScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.21.2.</span> <span class="toc-text">核心特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.</span> <span class="toc-text">着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">1.22.1.</span> <span class="toc-text">着色器简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%8F%82%E8%80%83"><span class="toc-number">1.22.2.</span> <span class="toc-text">着色参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.3.</span> <span class="toc-text">你的第一个着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-VisualShader"><span class="toc-number">1.22.4.</span> <span class="toc-text">使用 VisualShader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.5.</span> <span class="toc-text">使用计算着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E8%AF%BB%E5%8F%96%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.6.</span> <span class="toc-text">屏幕读取着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86-GLSL-%E8%BD%AC%E6%8D%A2%E4%B8%BA-Godot-%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.7.</span> <span class="toc-text">将 GLSL 转换为 Godot 着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97"><span class="toc-number">1.22.8.</span> <span class="toc-text">着色器风格指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-SubViewport-%E4%BD%9C%E4%B8%BA%E7%BA%B9%E7%90%86"><span class="toc-number">1.22.9.</span> <span class="toc-text">使用 SubViewport 作为纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">1.22.10.</span> <span class="toc-text">自定义后期处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">1.22.11.</span> <span class="toc-text">高级后期处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E6%9C%A8%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="toc-number">1.22.12.</span> <span class="toc-text">树木的制作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%EF%BC%88UI%EF%BC%89"><span class="toc-number">1.23.</span> <span class="toc-text">用户界面（UI）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UI-%E6%9E%84%E4%BB%B6"><span class="toc-number">1.23.1.</span> <span class="toc-text">UI 构件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%94%9A%E7%82%B9"><span class="toc-number">1.23.1.1.</span> <span class="toc-text">大小和锚点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GUI-%E5%A4%96%E8%A7%82%E4%B8%8E%E4%B8%BB%E9%A2%98"><span class="toc-number">1.23.2.</span> <span class="toc-text">GUI 外观与主题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E8%8A%82%E7%82%B9%E6%95%99%E7%A8%8B"><span class="toc-number">1.23.3.</span> <span class="toc-text">控件节点教程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XR"><span class="toc-number">1.24.</span> <span class="toc-text">XR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B"><span class="toc-number">1.24.1.</span> <span class="toc-text">基础教程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E4%B8%93%E9%A2%98"><span class="toc-number">1.24.2.</span> <span class="toc-text">高级专题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-XR-%E5%B7%A5%E5%85%B7"><span class="toc-number">1.24.3.</span> <span class="toc-text">Godot XR 工具</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Blender%E5%AF%BC%E5%85%A5PMX%E6%A8%A1%E5%9E%8B/" title="Blender导入PMX模型">Blender导入PMX模型</a><time datetime="2025-09-14T04:00:00.000Z" title="发表于 2025-09-14 12:00:00">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/" title="读Godot4.4文档手册">读Godot4.4文档手册</a><time datetime="2025-08-19T11:00:00.000Z" title="发表于 2025-08-19 19:00:00">2025-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/14/Godot4.4%20%E7%B1%BB%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/" title="Godot4.4 类参考总结">Godot4.4 类参考总结</a><time datetime="2025-08-14T11:00:00.000Z" title="发表于 2025-08-14 19:00:00">2025-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/10/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%9C%89%E6%84%9F%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/" title="读Godot4.4文档有感（长期更新）">读Godot4.4文档有感（长期更新）</a><time datetime="2025-08-10T11:00:00.000Z" title="发表于 2025-08-10 19:00:00">2025-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/02/Godot%20IP%E5%9C%B0%E5%9D%80P2P%E8%81%94%E6%9C%BA/" title="Godot IP地址P2P联机">Godot IP地址P2P联机</a><time datetime="2025-08-02T10:00:00.000Z" title="发表于 2025-08-02 18:00:00">2025-08-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/./img/page-ym.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By 微光zc</span></div><div class="footer_custom_text">世界全剧终，欢迎来到my blog！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"data-lang":"zh-CN","data-reactions-enabled":"1","data-input-position":"top"}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'wzcwzc10/wzcwzc10.github.io',
      'data-repo-id': 'R_kgDOPIIccg',
      'data-category-id': 'DIC_kwDOPIIccs4CtHqc',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><div class="aplayer no-destroy" data-id="13985424074" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script id="canvas_nest" defer="defer" color="255,255,0" opacity="0.6" zIndex="-1" count="120" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="微光zc,ヾ(≧▽≦*)o,ヾ(^▽^*),ヾ(≧∇≦*)ゝ,ヾ(^_^)o,ヾ(•ω•`)o,ヾ(￣3￣.￣3),ヾ(￣▽￣),ヾ(￣0￣)o" data-fontsize="30px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:description\"]","link[rel=\"canonical\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html><script type="text/javascript" src="/js/crash_cheat.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sakana-widget@2.7.1/lib/sakana.min.css"><div id="sakana-widget" style="position:fixed;bottom:5px;right:80px;"></div><script>function initSakanaWidget() {
  const jufufuht = SakanaWidget.getCharacter('chisato');
  jufufuht.image = `https://wzcwzc10.github.io/img/jufufu.png`;
  jufufuht.initialState = {
    ...jufufuht.initialState,
    i: 0.001,
    d: 1,
  };
  SakanaWidget.registerCharacter('jufufuht', jufufuht);
  new SakanaWidget({ character: 'jufufuht' }).mount('#sakana-widget');

  const jufufu = SakanaWidget.getCharacter('takina');
  jufufu.image = `https://wzcwzc10.github.io/img/jufufu-ht.gif`;
  SakanaWidget.registerCharacter('jufufu', jufufu);
  new SakanaWidget({ character: 'jufufu' }).mount('#sakana-widget');
}
nextCharacter(jufufuht);</script><script async onload="initSakanaWidget()" src="https://cdn.jsdelivr.net/npm/sakana-widget@2.7.1/lib/sakana.min.js"></script>