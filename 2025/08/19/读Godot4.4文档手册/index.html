<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>读Godot4.4文档手册 | 微光zc的网络小窝</title><meta name="author" content="微光zc"><meta name="copyright" content="微光zc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="读Godot4.4文档手册">
<meta property="og:type" content="article">
<meta property="og:title" content="读Godot4.4文档手册">
<meta property="og:url" content="https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/index.html">
<meta property="og:site_name" content="微光zc的网络小窝">
<meta property="og:description" content="读Godot4.4文档手册">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wzcwzc10.github.io/img/jufufu-ht.gif">
<meta property="article:published_time" content="2025-08-19T11:00:00.000Z">
<meta property="article:modified_time" content="2025-08-25T10:57:54.341Z">
<meta property="article:author" content="微光zc">
<meta property="article:tag" content="Godot">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="文档">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wzcwzc10.github.io/img/jufufu-ht.gif"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "读Godot4.4文档手册",
  "url": "https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/",
  "image": "https://wzcwzc10.github.io/img/jufufu-ht.gif",
  "datePublished": "2025-08-19T11:00:00.000Z",
  "dateModified": "2025-08-25T10:57:54.341Z",
  "author": [
    {
      "@type": "Person",
      "name": "微光zc",
      "url": "https://wzcwzc10.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/./img/loading.gif"><link rel="canonical" href="https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '读Godot4.4文档手册',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/ziti.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="/components/bilibili-card/bilibili-card.dark.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/./img/page-bg.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/jufufu-ht.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 微光闲话</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/./img/page-ym.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/./img/yx.png" alt="Logo"><span class="site-name">微光zc的网络小窝</span></a><a class="nav-page-title" href="/"><span class="site-name">读Godot4.4文档手册</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 微光闲话</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">读Godot4.4文档手册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-19T11:00:00.000Z" title="发表于 2025-08-19 19:00:00">2025-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-25T10:57:54.341Z" title="更新于 2025-08-25 18:57:54">2025-08-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Godot/">Godot</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>69分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>本文参考<a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh-cn/4.x/index.html">Godot4.4中文文档</a>中<br>手册的内容进行了总结改进，去除了个人感觉无用的部分</p>
<h1 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h1><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="在-Godot-中应用面向对象原则"><a href="#在-Godot-中应用面向对象原则" class="headerlink" title="在 Godot 中应用面向对象原则"></a>在 Godot 中应用面向对象原则</h3><p>Godot 引擎主要提供了两种创建可复用对象的方式：脚本和场景。<br>虽没有真正在底层定义类但面向对象的编程原则任可应用到脚本和场景中。</p>
<h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>引擎提供了内置的类，如 Node 。你可以使用脚本扩展这些类来创建派生类型。<br>这些脚本严格来说并不是类，而是一种资源，用来告知引擎在某一内置类的基础上执行一系列初始化。</p>
<p>Godot 的内部类可以将一个类的数据注册进一个名为<strong>ClassDB</strong>的数据库可以在运行时访问类的信息。<br>ClassDB 包含类的信息，例：属性 方法 常量 信号</p>
<p>当对象在执行访问属性或调用方法等操作时，它就会检查 ClassDB 中对象和对象基类的记录，以确定对象是否支持该操作。<br>将 Script 附加到你的对象上，可以扩展 ClassDB 中该对象的方法、属性和信号。</p>
<p>脚本即使没有使用 extends 关键字，也会隐式地继承引擎的基础 RefCounted 类。<br>因此，你可以从代码中实例化不使用 extends 关键字的脚本。<br>不过由于扩展的是 RefCounted，无法把它们附加到 Node 上。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>场景是可复用、可实例化、可继承的节点组。<br>创建场景就类似于，有一个脚本去创建一些节点，并使用 add_child() 将它们添加为子节点。</p>
<p>我们经常为场景搭配一个带有脚本的根节点，并在脚本中使用这个场景下的节点。脚本是通过使用命令式代码为场景添加行为来扩展场景的。</p>
<p>场景的内容有助于定义：<br>脚本可使用哪些节点。<br>如何组织，初始化。<br>彼此之间有什么信号连接。</p>
<p>为什么这些对组织场景很重要？<br>因为场景的实例都是对象。<br>因此，许多适用于面向对象原则也适用于场景：单一职责、封装等。</p>
<p>场景就是对附着在根节点上的脚本的扩展，所以你可以将其解释为类的一部分。<br>此系列最佳实践中所解释的大部分技术都建立在这一点上。</p>
<h3 id="场景组织"><a href="#场景组织" class="headerlink" title="场景组织"></a>场景组织</h3><h4 id="如何有效地建立关系？"><a href="#如何有效地建立关系？" class="headerlink" title="如何有效地建立关系？"></a>如何有效地建立关系？</h4><ul>
<li>应尽可能设计没有依赖的场景。（创建的场景应该将其所需的一切保留在其内部）</li>
<li>如果场景必须与外部环境交互，建议使用依赖注入。</li>
<li>依赖注入涉及使高级 API 提供低级 API 的依赖关系。</li>
<li>为什么？依赖于其外部环境的类可能会无意中触发 Bug 和意外行为。</li>
</ul>
<p>✅ 核心目标：松耦合 + 高内聚<br>“一个类不应依赖外部环境来完成其核心功能。”<br>                        —— 这是良好设计的核心原则之一。</p>
<p>要做到这一点，就必须暴露数据，然后依靠父级上下文对其进行初始化<br>下面是五种方法：</p>
<ol>
<li>连接信号。<br>这样做极其安全，但只能用于“响应”行为，而不是启动行为。<br>按惯例，信号名称通常是过去式动词，如“entered”“skill_activated”“item_collected”（已进入、已激活技能、已收集道具）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.signal_name.connect(method_on_the_object)</span><br><span class="line"></span><br><span class="line"># Child 子 → 父（通知）</span><br><span class="line">signal_name.emit() # 触发父级定义的行为</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>调用方法。<br>用于启动行为。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.method_name = &quot;do&quot;</span><br><span class="line"></span><br><span class="line"># Child 父 → 子（指令）</span><br><span class="line">call(method_name) # Call parent-defined method (which child must own).</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>初始化 Callable 属性。<br>比调用方法更安全，因为不需要拥有这个方法的所有权。用于启动行为。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.func_property = object_with_method.method_on_the_object</span><br><span class="line"></span><br><span class="line"># Child 父 → 子（注入行为）</span><br><span class="line">func_property.call() # Call parent-defined method (can come from anywhere).</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>初始化 Node 或其他 Object 的引用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.target = self</span><br><span class="line"></span><br><span class="line"># Child 父 → 子（提供数据源）</span><br><span class="line">print(target) # Use parent-defined node.</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>初始化 NodePath。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Parent</span><br><span class="line">$Child.target_path = &quot;..&quot;</span><br><span class="line"></span><br><span class="line"># Child 子 → 外部（通过路径查找）</span><br><span class="line">get_node(target_path) # Use parent-defined NodePath.</span><br></pre></td></tr></table></figure>
<p>这些选项隐藏了子节点的访问点。这反过来又使子节点与环境保持<strong>松耦合</strong> （loosely coupled）。<br>人们可以在另外一个上下文中重新使用它，而不需要对API做任何额外的改变。</p>
<mark class="hl-label red">警告</mark>
<p>应该倾向于将数据保存在场景内部，尽管它对外部内容有一个依赖关系，甚至是一个松散耦合的依赖，仍然意味着节点将期望其环境中的某些内容为真。项目的设计理念应避免这种情况的发生。如果不这样做，代码的继承关系将迫使开发人员使用文档, 以在微观尺度上跟踪对象关系；这就是所谓的开发地狱。通常情况下，编写依赖于外部文档才能安全使用的代码，是很容易出错的。<br>为了避免创建和维护此类文档，可以将依赖节点（上面的子级）转换为工具脚本，该脚本实现 _get_configuration_warnings()。从中返回的一个非空字符串紧缩数组（PackedStringArray）将使场景停靠面板生成警告图标，其中包含上述字符串作为节点的工具提示。这个警告图标和没有定义 CollisionShape2D 子节点时 Area2D 节点旁出现的图标是一样的。这样，编辑器通过脚本代码自记录（self-document）场景，也就不需要在文档里记录一些与之重复的内容了。<br>这样的GUI可以更好地通知项目用户有关节点的关键信息. 它具有外部依赖性吗？这些依赖性是否得到满足？其他程序员, 尤其是设计师和作家, 将需要消息中的明确指示, 告诉他们如何进行配置.</p>
<h4 id="选择节点树结构"><a href="#选择节点树结构" class="headerlink" title="选择节点树结构"></a>选择节点树结构</h4><p>构造节点树的方法有无数种。但对于没把握的人而言，这份有用的指南可以给他们一个不错的结构样本作为开始。<br>main.gd, 脚本将作为你的游戏的主要控制器。<br>Node2D&#x2F;Node3D, 真正的游戏“世界”（2D或3D）。<br>GUI, 来管理项目所需的各种菜单和部件。<br>“Main”节点（main.gd）</p>
<ul>
<li>Node2D&#x2F;Node3D “World”（game_world.gd）</li>
<li>Control“GUI”（gui.gd）</li>
</ul>
<p>当变更关卡时，可以稍后换出“World”节点的子级。手动更换场景让用户完全控制他们的游戏世界如何过渡。<br>下一步是考虑项目需要什么样的游戏系统。如果有这么一个系统……<br>跟踪所有的内部数据<br>应该是全局可访问的<br>应该是独立存在的<br>…接下来他该创建一个自动加载“单例”节点了。</p>
<blockquote>
<p>对于较小的游戏，一个更简单且更少控制的做法是使用一个“Game”单例<br>简单地调用 SceneTree.change_scene_to_file() 方法，用于置换出主场景的内容。这种结构多少保留了“World”作为主要游戏节点。<br>任一 GUI 也需要是一个单例；作为 “World” 的临时部分，或被手动添加到根节点作为其直接子节点。否则 GUI 节点也会在场景转换时自行删除。</p>
</blockquote>
<p>如果一个系统需要修改另一个系统的数据，那么就应该把它们分别定义成单独的脚本或者场景，不应该使用自动加载。</p>
<p>游戏中的每个子系统都应该在 SceneTree 中占有自己的一席之地。只有在节点确实是父节点中的元素时才应当使用父子关系。如果移除父节点的话，同时将这些子节点移除是否说得通？说不通的话，就应该在层级结构中单独列出，两者成为兄弟节点或者其他关系。</p>
<blockquote>
<p>某些情况下，我们仍然会需要让这些单独的节点进行相对定位。<br>此时可以使用 RemoteTransform &#x2F; RemoteTransform2D 节点。让目标节点有条件地从 Remote* 节点继承选定的变换元素。<br>要分配 target 的 NodePath，请使用以下方法之一：</p>
<ol>
<li>一个可靠的第三方, 可能是一个父节点, 来协调分配任务.</li>
<li>一个分组, 轻松提取对所需节点的引用(假设只有一个目标).<br>什么时候你该这样做？当你必须精细管理，且一个节点必须在场景树上来回移动以保留自己时，就会出现两难的局面。例如……<br>添加一个“玩家”节点到一个“房间”节点。<br>需要改变房间了，所以必须删除当前房间节点。<br>在房间能被删除前，你必须保留玩家并&#x2F;或将其移走。</li>
</ol>
<ul>
<li>如果不关心内存，你可以……<ul>
<li>创建新的房间节点。</li>
<li>将玩家节点移动到新的房间节点。</li>
<li>删除旧房间。</li>
</ul>
</li>
<li>如果比较关注内存情况，那么就需要这样……<ul>
<li>将玩家节点移动到节点树的其他地方。</li>
<li>删除房间节点。</li>
<li>实例化并添加新的房间节点。</li>
<li>重新添加玩家节点到新房间中。<br>问题在于这里的角色是一种“特殊情况”；开发者必须知道需要以这种方式处理项目中的角色。因此，在团队中可靠地分享这些信息的唯一方法就是写文档。然而，在文档中记录实现细节是很危险的，会成为一种维护负担，使代码可读性下降，不必要地膨胀项目的知识内容。<br>在拥有更多的资产的，更复杂的游戏中，将整个玩家节点保留在 SceneTree 中的其他地方会更好。这样的好处是：<br>一致性更高。<br>没有“特殊情况”，不必写入文档也不必进行维护。<br>因为不需要考虑这些细节，所以也没有出错的机会。<br>相比之下，如果需要子节点不继承父节点的变换，那么就有以下选项：<br>声明式解决方案：在它们之间放置一个 Node。作为没有变换的节点，Node 不会将这些信息传递给其子节点。<br>命令式解决方案：对 CanvasItem 或者 Node3D 节点使用 top_level 属性。这样就会让该节点忽略其继承的变换（transform）。</li>
</ul>
</li>
</ul>
</blockquote>
<p>如果构建的是网络游戏，请记住哪些节点和游戏系统与所有玩家相关，而哪些只与权威服务器相关。<br>例如，用户并不需要所有人都拥有每个玩家的“PlayerController”逻辑的副本。相反，他们只需要自己的。<br>将它们保持在从“世界”分离的独立的分支中，可以帮助简化游戏连接等的管理。</p>
<p>场景组织的关键是用关系树而不是空间树来考虑 SceneTree。节点是否依赖于其父节点的存在？如果不是，那么它们可以自己在别的地方茁壮成长。如果它们是依赖性的，那么理所当然它们应该是父节点的子节点（如果它们还不是父节点场景的一部分，那么很可能是父节点场景的一部分）。</p>
<p>这是否意味着节点本身就是组件？并不是这样。Godot 的节点树形成的是聚合关系，不是组合关系。虽然依旧可以灵活地移动节点，但在默认情况下是没有进行移动的必要的。</p>
<h3 id="何时使用场景与脚本"><a href="#何时使用场景与脚本" class="headerlink" title="何时使用场景与脚本"></a>何时使用场景与脚本</h3><h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h4><p>单独使用脚本 可以 完全定义场景的内容. 从本质上讲,Godot编辑器所做的, 仅在其对象的C++构造函数中.<br>但是, 选择哪个来使用, 可能是一个两难问题. 创建脚本实例与创建引擎类相同, 而处理场景需要更改API:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const MyNode = preload(&quot;my_node.gd&quot;)</span><br><span class="line">const MyScene = preload(&quot;my_scene.tscn&quot;)</span><br><span class="line">var node = Node.new()</span><br><span class="line">var my_node = MyNode.new() # Same method call.</span><br><span class="line">var my_scene = MyScene.instantiate() # Different method call.</span><br><span class="line">var my_inherited_scene = MyScene.instantiate(PackedScene.GEN_EDIT_STATE_MAIN) # Create scene inheriting from MyScene.</span><br></pre></td></tr></table></figure>
<p>此外, 由于引擎和脚本代码之间的速度差异, 脚本的运行速度将比场景慢一些. 节点越大和越复杂, 将它构建为场景的理由就越多.</p>
<h4 id="命名的类型"><a href="#命名的类型" class="headerlink" title="命名的类型"></a>命名的类型</h4><p>脚本可以在编辑器中被注册为一个新类型。<br>这样做之后，在节点或资源创建对话框中，它就会被显示为一个新类型，并带有可选图标。<br>这样，用户就可以更加便捷地使用脚本，而不是必须…</p>
<ul>
<li>了解他们想要使用的脚本的基本类型.</li>
<li>创建一个该基本类型的实例.</li>
<li>将脚本添加到节点.</li>
</ul>
<p>通过注册一个脚本，该脚本类型将像系统中的其他节点和资源一样成为一个可以被创建的选项。创建对话框甚至还有一个搜索栏，可以按名称查找类型。<br>用于注册类型的系统有两种：</p>
<ol>
<li><p>自定义类型<br>仅限编辑器. 类型名称在运行时中不可访问.<br>不支持继承的自定义类型.<br>一个初始化工具. 使用脚本创建节点. 仅此而已.<br>编辑器没有对该脚本的类型感知, 或其与其他引擎类型或脚本的关系.<br>允许用户定义一个图标.<br>适用于所有脚本语言, 因为它抽象处理脚本资源.<br>设置使用 EditorPlugin.add_custom_type.<br>使用 EditorPlugin.add_custom_type 设置。</p>
</li>
<li><p>Script 类<br>编辑器和运行时均可访问.<br>显示全部继承关系.<br>使用脚本创建节点, 但也可以从编辑器更改或扩展类型.<br>编辑器知道脚本, 脚本类和引擎c++类之间的继承关系.<br>允许用户定义一个图标.<br>引擎开发人员必须手动添加对语言的支持(名称公开和运行时可访问性两者).<br>编辑器扫描项目文件夹, 并为所有脚本语言注册任何公开的名称. 为公开此信息, 每种脚本语言都必须实现自己的支持.</p>
</li>
</ol>
<p>这两种方法都向创建对话框添加名称, 特别是脚本类, 还允许用户在不加载脚本资源的情况下访问类别名称. 在任何地方都可以创建实例, 和访问常量或静态方法.</p>
<p>有了这些功能, 由于它赋予用户易用性, 人们可能希望它们的类型是没有场景的脚本. 那些正在开发的插件或创建供设计人员使用的内部工具, 将以这种方式使事情变得更轻松.</p>
<p>不足之处在于, 这也意味着很大程度上必须使用命令式编程.</p>
<h4 id="Script-与-PackedScene-的性能"><a href="#Script-与-PackedScene-的性能" class="headerlink" title="Script 与 PackedScene 的性能"></a>Script 与 PackedScene 的性能</h4><p>在选择场景和脚本时, 最后一个需要考虑的方面是执行速度.<br>随着对象内容的增加, 脚本创建和初始化所需的内容也会大大增加. 创建节点层次结构就说明了这一点. 每个Node的逻辑可能有几百行代码.<br>下面的代码示例创建一个新的 Node, 更改名称, 分配脚本, 将其未来的父级设置为其所有者, 以便保存到磁盘中, 最后将其添加为 “主” 节点的子级:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># main.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">func _init():</span><br><span class="line">	var child = Node.new()</span><br><span class="line">	child.name = &quot;Child&quot;</span><br><span class="line">	child.script = preload(&quot;child.gd&quot;)</span><br><span class="line">	add_child(child)</span><br><span class="line">	child.owner = self</span><br></pre></td></tr></table></figure>
<p>这样的脚本代码比引擎端的C++代码要慢很多. 每条指令都要调用脚本API, 导致后端要进行多次 “查找”, 以找到要执行的逻辑.</p>
<p>场景有助于避免这个性能问题。PackedScene （场景包）是场景继承的基础类型，定义了使用序列化数据创建对象的资源。引擎可以在后端批量处理场景，并提供比脚本好得多的性能。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最好的方法是考虑以下几点:<br>如果希望创建一个基本工具, 它将在几个不同的项目中重用, 以及可能提供给不同技能水平的人使用. 它很可能是一个脚本, 有一个自定义名称&#x2F;图标.<br>如果有人想创造一个特定于他们的游戏的概念, 那么它应该是一个场景. 场景比脚本更容易跟踪&#x2F;编辑, 并提供更多的安全性.<br>如果你想命名一个场景，那么你可以通过声明一个脚本类并给它一个场景作为常量来实现这一点。实际上，该脚本变成了一个命名空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># game.gd</span><br><span class="line">class_name Game # 它继承自 RefCounted，因此不会出现在节点创建对话框中。</span><br><span class="line">extends RefCounted</span><br><span class="line"></span><br><span class="line">const MyScene = preload(&quot;my_scene.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># main.gd</span><br><span class="line">extends Node</span><br><span class="line">func _ready():</span><br><span class="line">	add_child(Game.MyScene.instantiate())</span><br></pre></td></tr></table></figure>

<h3 id="自动加载与常规节点"><a href="#自动加载与常规节点" class="headerlink" title="自动加载与常规节点"></a>自动加载与常规节点</h3><p>Godot 提供了一个在项目根节点自动加载节点的功能，允许你在全局范围内访问它们，从而完成单例作用 单例（自动加载） 。<br>当你在代码中使用 SceneTree.change_scene_to_file 更改场景时，这些自动加载的节点不会被释放。<br>在本指南中, 你将学习到何时使用自动加载功能, 以及避免使用该功能的方法.</p>
<h4 id="切割音频问题"><a href="#切割音频问题" class="headerlink" title="切割音频问题"></a>切割音频问题</h4><p>其他引擎可能鼓励使用创建管理类, 单例将很多功能组织到一个全局可访问的对象中.<br>由于节点树和信号,Godot提供了许多避免全局状态的方法.</p>
<p>例如, 假设我们正在构建一个平台游戏, 并希望收集能够播放声音效果的硬币, 那么就有一个节点 AudioStreamPlayer. 如果在 AudioStreamPlayer 已经在播放声音时调用它, 新的声音就会打断第一个声音.</p>
<p>一种解决方案是写一个全局的、自动加载的音效管理器类。它会生成一个 AudioStreamPlayer 的节点池，每当一个新的音效请求出现时，它就会在这个节点池中找到可用的节点来播放。我们不妨就把该类命名为 Sound ，你可以通过 Sound.play(“coin_pickup.ogg”) 从你项目中的任何位置使用它。这在短期内解决了问题但是却造成了更多的麻烦：</p>
<ol>
<li>全局状态 : 一个对象现在负责所有对象的数据. 如果音效有错误, 或没有一个可用的 AudioStreamPlayer , 一切都会崩溃.</li>
<li>全局访问 : 意味着任何对象都可以从任何地方调用 Sound.play(sound_path) , 便不容易找到错误的来源了.</li>
<li>全局资源分配 : 由于从一开始就存储了一个 AudioStreamPlayer 节点池, 如果数量太少会遇到bug, 而数量太多则会占用更多的内存.</li>
</ol>
<blockquote>
<p>全局访问的问题在于，任何地方的代码都可能将错误的数据传递给我们例子中的 Sound 自动加载。因此，为了修复这个 bug，你需要检索的区域涵盖了整个项目。<br>当你将代码保存在场景中时, 音频可能仅涉及一个或两个脚本.</p>
</blockquote>
<p>与之形成对比的是, 每个场景在其内部, 保留尽可能多的 AudioStreamPlayer 节点, 所有这些问题都会消失:</p>
<ol>
<li>每个场景管理自己的状态信息. 如果数据有问题, 则只会在该场景中引起问题.</li>
<li>每个场景只访问自己的节点. 那么如果有一个bug, 很容易找到哪个节点有问题.</li>
<li>每个场景只分配所需数量的资源.</li>
</ol>
<h4 id="管理共享功能或数据"><a href="#管理共享功能或数据" class="headerlink" title="管理共享功能或数据"></a>管理共享功能或数据</h4><p>使用自动加载的另一个原因可能是你希望在许多场景中重复使用相同的方法或数据.<br>对于函数，可以使用 GDScript 中的 class_name 关键字创建一种新的 Node 类型，为单个场景提供该功能。<br>当涉及到数据时, 你可以:</p>
<ol>
<li>创建一个新类型的 Resource 来共享数据.</li>
<li>将数据存储在每个节点可以访问的对象中, 例如使用 owner 属性来访问场景的根节点.</li>
</ol>
<h4 id="何时应使用自动加载"><a href="#何时应使用自动加载" class="headerlink" title="何时应使用自动加载"></a>何时应使用自动加载</h4><p>GDScript 支持使用 static func 创建 static （静态） 函数，与 class_name 结合使用时还可以创建辅助函数库，无需创建实例来调用这些函数。 静态函数也有一些限制：不能引用成员变量、非静态（non-static）函数或 self。<br>从 Godot 4.1 开始，GDScript 还支持使用 static var 的 static （静态）变量，意味着你现在可以在类的实例之间共享变量，而无需创建单独的自动加载节点或脚本。<br>尽管如此，对于那些涵盖范围广泛的系统来说，使用自动加载的节点仍然可以简化你的代码。如果自动加载的节点管理自己的信息并且不侵入其他对象的数据，那么这就是一个创建处理广泛任务的系统（例如，任务或对话系统）的好方法。</p>
<blockquote>
<p>自动加载 不 完全是一个单例。没有什么可以阻止你实例化自动加载的节点的副本。它只是一个使节点作为场景树的根的子节点自动加载的工具，而与游戏的节点结构或运行哪个场景（比如通过按 F6 键运行当前场景）无关。<br>因此，你可以像这样，通过调用 get_node(“&#x2F;root&#x2F;Sound”) 来获取名为 Sound 的自动加载节点。</p>
</blockquote>
<h3 id="何时以及如何避免为任何事情使用节点"><a href="#何时以及如何避免为任何事情使用节点" class="headerlink" title="何时以及如何避免为任何事情使用节点"></a>何时以及如何避免为任何事情使用节点</h3><ol>
<li>Object：终极轻量级对象，原始的 Object 必须使用手动内存管理。尽管如此，创建自己的自定义数据结构——甚至是节点结构——也并不难，并且比 Node 类更轻量。</li>
</ol>
<p>示例：参见 Tree 节点。它支持对具有任意行数和列数的内容表，进行高级定制。用来生成可视化的数据实际上是 TreeItem 对象的树。</p>
<p>优势： 将 API 简化为较小范围的对象，有助于提高其可访问性、改善迭代时间。与其使用整个 Node 库，不如创建一组简略的 Object，节点可以从这些 Object 中生成和管理相应的子节点。</p>
<blockquote>
<p>处理它们时要小心. 可以将 Object 存储到变量中, 但是这些引用可能在没有警告的情况下失效. 例如, 如果对象的创建者决定删除它, 这将在下一次访问时, 触发错误状态.</p>
</blockquote>
<ol start="2">
<li>RefCounted：只比 Object 稍微复杂一点。它们会记录对自己的引用，只有当对自己没有另外的引用存在时，才会删除加载的内存。在大多数需要在自定义类中存取数据的情况下，很有用。</li>
</ol>
<p>示例：见 FileAccess 对象。它的功能就像普通 Object 一样，只是不需要人为删除。</p>
<p>优势: 与 Object 相同.</p>
<ol start="3">
<li>Resource ：只比 RefCounted 稍微复杂一点。它们天然具有将其对象属性序列化（即保存）到 Godot 资源文件，或从 Godot 资源文件中反序列化（即加载）的能力。</li>
</ol>
<p>示例 : 脚本, PackedScene (用于场景文件), 以及其他类型, 比如 AudioEffect 类. 每一个都可以保存和加载, 因此它们均是从 Resource 继承而来的.</p>
<p>优势：关于 Resource 与传统数据存储方法相比的优势已经说了 很多。然而，在使用 Resource 替代 Node 的情境下，Resource 的主要优点是与检查器的兼容性。虽然几乎和 Object&#x2F;Reference 一样轻量，它们仍然可以在检查器中显示并导出属性。这使它们在易用性上，可以媲美使用子节点的方式，而且如果有人计划在其场景中包含许多这类 Resource&#x2F;Node，它们还可以提高性能。</p>
<h3 id="Godot-接口"><a href="#Godot-接口" class="headerlink" title="Godot 接口"></a>Godot 接口</h3><p>脚本常常需要依赖其他对象来获取功能。这个过程分为两部分：</p>
<ol>
<li>获取对可能具有这些功能的对象的引用。</li>
<li>从对象访问数据或逻辑。</li>
</ol>
<h4 id="获取对象引用"><a href="#获取对象引用" class="headerlink" title="获取对象引用"></a>获取对象引用</h4><p>对所有 Object 来说，获得引用的最基础的方法，是通过另一个已获得引用的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = node.object # Property access.</span><br><span class="line">var obj = node.get_object() # Method access.</span><br></pre></td></tr></table></figure>
<p>同样的原则也适用于 RefCounted 对象。虽然用户经常以这种方式访问 Node 和 Resource，但还有其他方法可用。<br>除了访问属性和方法，也可以通过加载来获得 Resource。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># If you need an &quot;export const var&quot; (which doesn&#x27;t exist), use a conditional</span><br><span class="line"># setter for a tool script that checks if it&#x27;s executing in the editor.</span><br><span class="line"># The `@tool` annotation must be placed at the top of the script.</span><br><span class="line">@tool</span><br><span class="line"></span><br><span class="line"># Load resource during scene load.</span><br><span class="line">var preres = preload(path)</span><br><span class="line"># Load resource when program reaches statement.</span><br><span class="line">var res = load(path)</span><br><span class="line"></span><br><span class="line"># Note that users load scenes and scripts, by convention, with PascalCase</span><br><span class="line"># names (like typenames), often into constants.</span><br><span class="line">const MyScene = preload(&quot;my_scene.tscn&quot;) # Static load</span><br><span class="line">const MyScript = preload(&quot;my_script.gd&quot;)</span><br><span class="line"></span><br><span class="line"># This type&#x27;s value varies, i.e. it is a variable, so it uses snake_case.</span><br><span class="line">@export var script_type: Script</span><br><span class="line"></span><br><span class="line"># Must configure from the editor, defaults to null.</span><br><span class="line">@export var const_script: Script:</span><br><span class="line">	set(value):</span><br><span class="line">		if Engine.is_editor_hint():</span><br><span class="line">			const_script = value</span><br><span class="line"></span><br><span class="line"># Warn users if the value hasn&#x27;t been set.</span><br><span class="line">func _get_configuration_warnings():</span><br><span class="line">	if not const_script:</span><br><span class="line">		return [&quot;Must initialize property &#x27;const_script&#x27;.&quot;]</span><br><span class="line"></span><br><span class="line">	return []</span><br></pre></td></tr></table></figure>
<p>请注意以下几点：</p>
<ol>
<li>在一种语言中，有许多加载这些资源的方法。</li>
<li>在设计对象如何访问数据时，不要忘记，还可以将资源作为引用传递。</li>
<li>请记住，加载资源时只会获取引擎维护的缓存资源实例。如果要获取一个新对象，必须 复制 一个现有引用，或者使用 new() 从头实例化一个对象。</li>
</ol>
<p>节点同样也有另一种访问方式：场景树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">extends Node</span><br><span class="line"></span><br><span class="line"># Slow.</span><br><span class="line">func dynamic_lookup_with_dynamic_nodepath():</span><br><span class="line">	print(get_node(&quot;Child&quot;))</span><br><span class="line"></span><br><span class="line"># Faster. GDScript only.</span><br><span class="line">func dynamic_lookup_with_cached_nodepath():</span><br><span class="line">	print($Child)</span><br><span class="line"></span><br><span class="line"># Fastest. Doesn&#x27;t break if node moves later.</span><br><span class="line"># Note that `@onready` annotation is GDScript-only.</span><br><span class="line"># Other languages must do...</span><br><span class="line">#     var child</span><br><span class="line">#     func _ready():</span><br><span class="line">#         child = get_node(&quot;Child&quot;)</span><br><span class="line">@onready var child = $Child</span><br><span class="line">func lookup_and_cache_for_future_access():</span><br><span class="line">	print(child)</span><br><span class="line"></span><br><span class="line"># Fastest. Doesn&#x27;t break if node is moved in the Scene tree dock.</span><br><span class="line"># Node must be selected in the inspector as it&#x27;s an exported property.</span><br><span class="line">@export var child: Node</span><br><span class="line">func lookup_and_cache_for_future_access():</span><br><span class="line">	print(child)</span><br><span class="line"></span><br><span class="line"># Delegate reference assignment to an external source.</span><br><span class="line"># Con: need to perform a validation check.</span><br><span class="line"># Pro: node makes no requirements of its external structure.</span><br><span class="line">#      &#x27;prop&#x27; can come from anywhere.</span><br><span class="line">var prop</span><br><span class="line">func call_me_after_prop_is_initialized_by_parent():</span><br><span class="line">	# Validate prop in one of three ways.</span><br><span class="line"></span><br><span class="line">	# Fail with no notification.</span><br><span class="line">	if not prop:</span><br><span class="line">		return</span><br><span class="line"></span><br><span class="line">	# Fail with an error message.</span><br><span class="line">	if not prop:</span><br><span class="line">		printerr(&quot;&#x27;prop&#x27; wasn&#x27;t initialized&quot;)</span><br><span class="line">		return</span><br><span class="line"></span><br><span class="line">	# Fail and terminate.</span><br><span class="line">	# NOTE: Scripts run from a release export template don&#x27;t run `assert`s.</span><br><span class="line">	assert(prop, &quot;&#x27;prop&#x27; wasn&#x27;t initialized&quot;)</span><br><span class="line"></span><br><span class="line"># Use an autoload.</span><br><span class="line"># Dangerous for typical nodes, but useful for true singleton nodes</span><br><span class="line"># that manage their own data and don&#x27;t interfere with other objects.</span><br><span class="line">func reference_a_global_autoloaded_variable():</span><br><span class="line">	print(globals)</span><br><span class="line">	print(globals.prop)</span><br><span class="line">	print(globals.my_getter())</span><br></pre></td></tr></table></figure>

<h4 id="从对象访问数据或逻辑"><a href="#从对象访问数据或逻辑" class="headerlink" title="从对象访问数据或逻辑"></a>从对象访问数据或逻辑</h4><p>Godot 的脚本 API 是鸭子类型（duck-typed）的。<br>这意味着，当脚本执行某项操作时，Godot 不会通过<strong>类型</strong>来验证其是否支持该操作。相反，它会检查对象是否<strong>实现</strong>了这个被调用的方法。</p>
<p>例如，CanvasItem 类具有 visible&#96; 属性。暴露给脚本 API 的所有属性实际上都是与名称绑定的 setter 和 getter 对。如果有人尝试访问 CanvasItem.visible，那么 Godot 将按顺序执行以下检查：</p>
<ul>
<li>如果对象附加了脚本，它将尝试通过脚本设置属性。这使得脚本有机会通过覆盖属性的 setter 方法来覆盖在基础对象上定义的属性。</li>
<li>如果脚本没有该属性，它会在 ClassDB 中针对 CanvasItem 类及其所有继承类型执行 HashMap 查找以查找“visible”属性。如果找到，它会调用绑定的 setter 或 getter。有关 HashMap 的更多信息，请参阅《数据偏好》文档。</li>
<li>如果没有找到, 它会进行显式检查, 以查看用户是否要访问 script 或 meta 属性.</li>
<li>如果没有, 它将在 CanvasItem 及其继承的类型中检查 _set&#x2F;_get 实现(取决于访问类型). 这些方法可以执行逻辑, 从而给人一种对象具有属性的印象. _get_property_list 方法也是如此.<ul>
<li>请注意，即使对于不合法的符号名称也会发生这种情况，例如以数字开头或包含斜杠（&#x2F;）的名称。</li>
</ul>
</li>
</ul>
<p>因此，这个鸭子类型的系统可以在脚本、对象的类，或对象继承的任何类中定位属性，但仅限于扩展 Object 的对象。</p>
<p>Godot 提供了多种选项，来对这些访问执行运行时检查：</p>
<ul>
<li>鸭子类型属性的访问。Godot 将像上文所述的那样对它进行属性检查。如果对象不支持该操作，则执行将停止。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 所有对象都有类似鸭子类型（duck-typed）的 get、set 和 call 包装方法</span><br><span class="line">get_parent().set(&quot;visible&quot;, false)</span><br><span class="line"></span><br><span class="line"># 在方法调用中使用符号（symbol）访问器而非字符串，</span><br><span class="line"># 会隐式地调用 set 方法，而 set 方法又会通过属性查找顺序，</span><br><span class="line"># 调用绑定到该属性的 setter 方法。</span><br><span class="line">get_parent().visible = false</span><br><span class="line"></span><br><span class="line"># 请注意，如果定义了 _set 和 _get 方法来描述某个属性的存在，</span><br><span class="line"># 但该属性未在任何 _get_property_list 方法中被识别，</span><br><span class="line"># 那么 set() 和 get() 方法仍然可以正常工作，</span><br><span class="line"># 但符号访问方式会提示找不到该属性。</span><br></pre></td></tr></table></figure>
<p>方法检查。在 CanvasItem.visible 的例子中，我们可以像访问任何其他方法一样，访问 set_visible 和 is_visible。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">var child = get_child(0)</span><br><span class="line"></span><br><span class="line"># Dynamic lookup.</span><br><span class="line">child.call(&quot;set_visible&quot;, false)</span><br><span class="line"></span><br><span class="line"># Symbol-based dynamic lookup.</span><br><span class="line"># GDScript aliases this into a &#x27;call&#x27; method behind the scenes.</span><br><span class="line">child.set_visible(false)</span><br><span class="line"></span><br><span class="line"># Dynamic lookup, checks for method existence first.</span><br><span class="line">if child.has_method(&quot;set_visible&quot;):</span><br><span class="line">	child.set_visible(false)</span><br><span class="line"></span><br><span class="line"># Cast check, followed by dynamic lookup.</span><br><span class="line"># Useful when you make multiple &quot;safe&quot; calls knowing that the class</span><br><span class="line"># implements them all. No need for repeated checks.</span><br><span class="line"># Tricky if one executes a cast check for a user-defined type as it</span><br><span class="line"># forces more dependencies.</span><br><span class="line">if child is CanvasItem:</span><br><span class="line">	child.set_visible(false)</span><br><span class="line">	child.show_on_top = true</span><br><span class="line"></span><br><span class="line"># If one does not wish to fail these checks without notifying users,</span><br><span class="line"># one can use an assert instead. These will trigger runtime errors</span><br><span class="line"># immediately if not true.</span><br><span class="line">assert(child.has_method(&quot;set_visible&quot;))</span><br><span class="line">assert(child.is_in_group(&quot;offer&quot;))</span><br><span class="line">assert(child is CanvasItem)</span><br><span class="line"></span><br><span class="line"># Can also use object labels to imply an interface, i.e. assume it</span><br><span class="line"># implements certain methods.</span><br><span class="line"># There are two types, both of which only exist for Nodes: Names and</span><br><span class="line"># Groups.</span><br><span class="line"></span><br><span class="line"># Assuming...</span><br><span class="line"># A &quot;Quest&quot; object exists and 1) that it can &quot;complete&quot; or &quot;fail&quot; and</span><br><span class="line"># that it will have text available before and after each state...</span><br><span class="line"></span><br><span class="line"># 1. Use a name.</span><br><span class="line">var quest = $Quest</span><br><span class="line">print(quest.text)</span><br><span class="line">quest.complete() # or quest.fail()</span><br><span class="line">print(quest.text) # implied new text content</span><br><span class="line"></span><br><span class="line"># 2. Use a group.</span><br><span class="line">for a_child in get_children():</span><br><span class="line">	if a_child.is_in_group(&quot;quest&quot;):</span><br><span class="line">		print(quest.text)</span><br><span class="line">		quest.complete() # or quest.fail()</span><br><span class="line">		print(quest.text) # implied new text content</span><br><span class="line"></span><br><span class="line"># Note that these interfaces are project-specific conventions the team</span><br><span class="line"># defines (which means documentation! But maybe worth it?).</span><br><span class="line"># Any script that conforms to the documented &quot;interface&quot; of the name or</span><br><span class="line"># group can fill in for it.</span><br></pre></td></tr></table></figure>

<p>将访问权限外包给 Callable。当需要最大程度地摆脱依赖时，这种方法可能很有用。在这种情况下，人们依赖外部上下文来设置该方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># child.gd</span><br><span class="line">extends Node</span><br><span class="line">var fn = null</span><br><span class="line"></span><br><span class="line">func my_method():</span><br><span class="line">	if fn:</span><br><span class="line">		fn.call()</span><br><span class="line"></span><br><span class="line"># parent.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">@onready var child = $Child</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">	child.fn = print_me</span><br><span class="line">	child.my_method()</span><br><span class="line"></span><br><span class="line">func print_me():</span><br><span class="line">	print(name)</span><br></pre></td></tr></table></figure>

<h3 id="Godot-通知"><a href="#Godot-通知" class="headerlink" title="Godot 通知"></a>Godot 通知</h3><p>Godot 中的每个对象都实现了 _notification 方法。其目的是允许对象响应可能与之相关的各种引擎级回调。<br>例如，如果引擎告诉 CanvasItem 去“绘制”，则它将调用 _notification(NOTIFICATION_DRAW)。</p>
<p>在所有这些通知之中，有很多类似“绘制”这样经常需要在脚本中去覆盖的通知，多到 Godot 要提供专用函数的地步：<br>_ready(): NOTIFICATION_READY<br>_enter_tree(): NOTIFICATION_ENTER_TREE<br>_exit_tree(): NOTIFICATION_EXIT_TREE<br>_process(delta): NOTIFICATION_PROCESS<br>_physics_process(delta): NOTIFICATION_PHYSICS_PROCESS<br>_draw(): NOTIFICATION_DRAW</p>
<p>用户可能不会意识到 Node 之外的类型也有通知，例如：<br>Object::NOTIFICATION_POSTINITIALIZE：在对象初始化期间触发的回调。脚本无法访问。<br>Object::NOTIFICATION_PREDELETE：在引擎删除 Object 之前触发的回调，即析构函数。<br>并且 Node 中存在的许多回调没有任何专用的方法，但仍然非常有用。<br>Node::NOTIFICATION_PARENTED: 将子节点添加到另一个节点时，会触发此回调。<br>Node::NOTIFICATION_UNPARENTED: 将子节点从另一个节点下删除时，会触发此回调。<br>你可以在通用的 _notification() 方法中访问所有这些自定义通知。</p>
<blockquote>
<p>文档中被标记为“virtual”的方法（即虚方法）可以被脚本覆盖重写。<br>一个经典的例子是 Object 中的 <em>init 方法。虽然它没有等效的 NOTIFICATION</em>* 通知，但是引擎仍然会调用该方法。大多数语言（C#除外）都将其用作构造函数。</p>
</blockquote>
<p>所以说，应该在哪些情况下使用这些通知或虚函数呢？</p>
<h4 id="对比-process、-physics-process、-input"><a href="#对比-process、-physics-process、-input" class="headerlink" title="对比 _process、_physics_process、*_input"></a>对比 _process、_physics_process、*_input</h4><p>当需要使用“依赖于帧速率的 delta 时间增量”时，请使用 _process。如果需要尽可能频繁地更新对象数据，也应该在这里处理。频繁执行的逻辑检查和数据缓存操作，大多数都在这里执行。但也需要注意执行频率，如果不需要每帧都执行，则可以选择用定时器循环来替代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Allows for recurring operations that don&#x27;t trigger script logic</span><br><span class="line"># every frame (or even every fixed frame).</span><br><span class="line">func _ready():</span><br><span class="line">	var timer = Timer.new()</span><br><span class="line">	timer.autostart = true</span><br><span class="line">	timer.wait_time = 0.5</span><br><span class="line">	add_child(timer)</span><br><span class="line">	timer.timeout.connect(func():</span><br><span class="line">		print(&quot;This block runs every 0.5 seconds&quot;)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>当需要与帧速率无关的时间增量时，请使用 _physics_process。如果代码需要随着时间的推移进行一致的更新，不管时间推进速度是快还是慢，那么就应该在这里执行代码。频繁执行的运动学和对象变换操作，应在此处执行。</p>
<p>为了获得最佳性能，应尽可能避免在这些回调期间进行输入检查。_process 和 _physics_process 每次都会触发（默认情况下这些更新回调不会 “休眠”）。相反，*_input 回调仅在引擎实际检测到输入的帧上触发。</p>
<p>在 input 回调中同样可以检查输入动作。如果要使用增量时间，则可以使用相关的增量时间获取方法来获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Called every frame, even when the engine detects no input.</span><br><span class="line">func _process(delta):</span><br><span class="line">	if Input.is_action_just_pressed(&quot;ui_select&quot;):</span><br><span class="line">		print(delta)</span><br><span class="line"></span><br><span class="line"># Called during every input event.</span><br><span class="line">func _unhandled_input(event):</span><br><span class="line">	match event.get_class():</span><br><span class="line">		&quot;InputEventKey&quot;:</span><br><span class="line">			if Input.is_action_just_pressed(&quot;ui_accept&quot;):</span><br><span class="line">				print(get_process_delta_time())</span><br></pre></td></tr></table></figure>
<h4 id="对比-init、初始化、导出"><a href="#对比-init、初始化、导出" class="headerlink" title="对比 _init、初始化、导出"></a>对比 _init、初始化、导出</h4><p>如果脚本初始化它自己的没有场景的节点子树，则该代码将会在 _init() 中执行。其他属性或独立于 SceneTree 的初始化也应在此处运行。<br>_init() 在 _enter_tree() 或 _ready() 之前触发，但在脚本创建并初始化其属性之后。实例化场景时，属性值将按照以下顺序设置：<br>初始值赋值：为属性赋初始值，未指定初始值时赋默认值。Setter 函数即便存在也不会使用。<br><code>_init()</code> 赋值：在 _init() 中通过各种赋值改变属性的取值，会触发 setter 函数。<br>导出值赋值：如果在“检查器”中修改了导出属性的值，就会再次修改该属性的值，会触发 setter 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># test is initialized to &quot;one&quot;, without triggering the setter.</span><br><span class="line">@export var test: String = &quot;one&quot;:</span><br><span class="line">	set(value):</span><br><span class="line">		test = value + &quot;!&quot;</span><br><span class="line"></span><br><span class="line">func _init():</span><br><span class="line">	# Triggers the setter, changing test&#x27;s value from &quot;one&quot; to &quot;two!&quot;.</span><br><span class="line">	test = &quot;two&quot;</span><br><span class="line"></span><br><span class="line"># If someone sets test to &quot;three&quot; from the Inspector, it would trigger</span><br><span class="line"># the setter, changing test&#x27;s value from &quot;two!&quot; to &quot;three!&quot;</span><br></pre></td></tr></table></figure>
<p>因此，选择实例化脚本还是实例化场景，对初始化和引擎调用 setter 的次数都会产生影响。</p>
<h4 id="对比-ready、-enter-tree、NOTIFICATION-PARENTED"><a href="#对比-ready、-enter-tree、NOTIFICATION-PARENTED" class="headerlink" title="对比 _ready、_enter_tree、NOTIFICATION_PARENTED"></a>对比 _ready、_enter_tree、NOTIFICATION_PARENTED</h4><p>将场景实例化并首次添加到运行的场景树时，Godot 会沿着场景树从上至下实例化节点（调用 _init() 函数），再从根节点出发从上至下构建场景树。因此 _enter_tree() 是按照树的顺序从上至下一级一级调用的。场景树构建完成后，所有叶节点就会调用 _ready。一个节点的所有子节点都调用完该方法后，就会轮到该节点自己调用。此时就是逆着树的顺序从下至上一级一级调用的，最终到达根节点。</p>
<p>当实例化脚本或独立的场景时，节点不会在创建时被添加到 SceneTree 中，所以未触发 _enter_tree 回调。而只有 _init 调用发生。当场景被添加到 SceneTree 时，才会调用 _enter_tree 和 _ready。</p>
<p>如果需要触发作为节点设置父级到另一个节点而发生的行为, 无论它是否作为在主要&#x2F;活动场景中的部分发生, 都可以使用 PARENTED 通知. 例如, 这有一个将节点方法连接到其父节点上自定义信号, 而不会失败的代码段。对可能在运行时创建并以数据为中心的节点很有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">var parent_cache</span><br><span class="line"></span><br><span class="line">func connection_check():</span><br><span class="line">	return parent_cache.has_user_signal(&quot;interacted_with&quot;)</span><br><span class="line"></span><br><span class="line">func _notification(what):</span><br><span class="line">	match what:</span><br><span class="line">		NOTIFICATION_PARENTED:</span><br><span class="line">			parent_cache = get_parent()</span><br><span class="line">			if connection_check():</span><br><span class="line">				parent_cache.interacted_with.connect(_on_parent_interacted_with)</span><br><span class="line">		NOTIFICATION_UNPARENTED:</span><br><span class="line">			if connection_check():</span><br><span class="line">				parent_cache.interacted_with.disconnect(_on_parent_interacted_with)</span><br><span class="line"></span><br><span class="line">func _on_parent_interacted_with():</span><br><span class="line">	print(&quot;I&#x27;m reacting to my parent&#x27;s interaction!&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="数据偏好"><a href="#数据偏好" class="headerlink" title="数据偏好"></a>数据偏好</h3><h4 id="数组、字典、对象"><a href="#数组、字典、对象" class="headerlink" title="数组、字典、对象"></a>数组、字典、对象</h4><p>Godot 把脚本 API 中的所有变量都存储在 Variant 中。Variant 可以存储兼容数据结构。<br>例如 Array （数组）、 Dictionary （字典）、 Object （对象）。</p>
<p>Godot 使用 Vector<Variant> 实现数组。引擎会将数组内容存储在一段连续的内存之中，也就是说，元素与元素之间是相邻的。</p>
<blockquote>
<p>这里的 Vector 是传统 C++ STL 库中数组对象的名称，是个“模板”类型，即它只能存储特定类型的数据（用尖括号表示）。<br>例如，PackedStringArray 其实就类似于 Vector<String>。<br>因为是在内存中连续存储，所以执行各种操作的性能如下：<br>迭代：最快，非常适合循环。</p>
</blockquote>
<ul>
<li>操作：把计数器加一即可获取下一个元素。</li>
</ul>
<p>插入、删除、移动：与位置相关，一般较慢。</p>
<ul>
<li>操作：元素的添加、删除、移动需要移动与之相邻的元素（腾出地方或者填充空缺）。</li>
<li>在末尾添加、删除很快。</li>
<li>在任意位置添加、删除较慢。</li>
<li>在开头添加、删除最慢。</li>
<li>如果需要在开头执行多次插入、删除操作，那么……<ol>
<li>反转数组。</li>
<li>通过循环在末尾执行数组更改。</li>
<li>再把数组反转回来。<br>  这样就只复制了两次数组（虽然比较慢，但还是常数时间），否则就得把平均大概一半的数组复制 N 遍（线性时间）。</li>
</ol>
</li>
</ul>
<p>取值、设值：因为是按位置存取的，所以最快。例如你可以请求第 0 个、第 2 个、第 10 个等等的元素，但不能按照元素的值来请求。</p>
<ul>
<li>操作：把起始位置做一次加法，得到所需的索引。</li>
</ul>
<p>查找：最慢。根据值获取索引，也就是位置。</p>
<ul>
<li><p>操作：必须遍历数组，一个个元素做比较，直到找到匹配的为止。</p>
<ul>
<li>性能同时也取决于是否需要查遍整个数组才能找到目标。</li>
</ul>
</li>
<li><p>如果数组能够保持一定的顺序，自定义搜索操作可以缩短到对数时间（相对而言很快）。不过外行用户不会对此感到满意。做法是每次编辑后都重新对 Array 进行排序，编写利用已排序特性的搜索算法。</p>
</li>
</ul>
<p>Godot 将 Dictionary 实现为 HashMap&lt;Variant, Variant, VariantHasher, StringLikeVariantComparator&gt; .引擎存储一个键值对的小数组（初始化为 2^3 或 8 条记录）。当人们尝试访问一个值时，他们会为其提供一个密钥。然后它对密钥进行哈希处理 ，即将它转换为一个数字。“哈希”用于计算数组中的索引。作为一个数组，HM 在映射到值的键的“表”中进行快速查找。当 HashMap 变得太满时，它会增加到 2 的下一个幂（因此，16 条记录，然后是 32 条记录，依此类推）并重建结构。</p>
<p>使用哈希是为了减少键的冲突几率。发生冲突时，哈希表必须重新计算索引号，将占据原有位置的值纳入考虑范围。<br>总之，这样做就能够以牺牲内存和一些较小的操作效率为代价，让所有记录的访问都达到常数时间。</p>
<ol>
<li><p>对每个键进行任意次哈希。<br>哈希操作是常量时间的，因此即使某个算法必须执行多次，只要哈希的计算次数与表的密度没有什么大关系，那么就能够保持较快的速度。这样……</p>
</li>
<li><p>保持不断增长的表规模.<br>HashMaps为了减少哈希冲突, 并保持访问速度, 在表中保留了未使用的内存的间隙. 这就是为什么它总是会以2幂为倍数扩展其容量.</p>
</li>
</ol>
<p>如大家所知，字典擅长的任务是数组所不擅长的。其操作细节概述如下：</p>
<ul>
<li>迭代 : 快速.<ul>
<li>操作: 遍历映射的内部散列向量. 返回每个键. 之后, 用户使用该键跳转到并返回所需的值.</li>
</ul>
</li>
<li>插入, 删除, 移动 : 最快.<ul>
<li>操作: 散列给定的键. 执行1个加法操作来查找适当的值(数组开始+偏移量). 移动其中的两个(一个插入, 一个擦除). 映射必须进行一些维护, 以保留其功能:<ol>
<li>更新记录的有序列表.</li>
<li>确定列表密度, 是否需要扩展列表容量.</li>
</ol>
</li>
<li>字典会记住用户插入键的顺序. 这使它能够执行可靠的迭代.</li>
</ul>
</li>
<li>取值, 设值 : 最快. 和 根据键 查找相同.<ul>
<li>操作: 和插入&#x2F;删除&#x2F;移动类似.</li>
</ul>
</li>
<li>查找 : 最慢. 标识值的键.<ul>
<li>操作: 必须遍历记录并比较该值, 直到找到匹配的为止.</li>
<li>请注意,Godot并未开箱即用地提供此功能(因为它们并非用于此任务).</li>
</ul>
</li>
</ul>
<p>Godot用愚蠢, 但动态的方式容纳数据容器实现对象. 提出问题时, 对象将查询数据源. 例如, 要回答”你是否有一个名为 position 的属性？”的问题, 它可能会询问其 script 或 ClassDB. 你可以在 在 Godot 中应用面向对象原则 文章中, 找到有关什么是对象以及它们如何工作的更多信息.</p>
<p>这里重要的细节是对象任务的复杂性. 每次执行这些多源查询时, 它运行 几个 迭代循环和哈希表查找. 此外, 查询是线性时间操作, 依赖于对象的继承层次结构大小. 如果 Object 查询的类(当前类)什么都没有找到, 则该请求将一直推迟到下一个基类, 一直到原始 Object 类为止. 虽然这些都是单独的快速操作, 但它必须进行如此多的检查, 于是这一事实使得它们比查找数据的两种方法都要慢.</p>
<blockquote>
<p>当开发人员提到脚本API有多慢时, 所引用的正是这一系列查询. 与编译后的, 应用程序知道在哪里可以找到任何东西的,C++代码相比, 不可避免的是, 脚本API操作将花费更长的时间. 他们必须定位任何相关数据的来源, 然后才能尝试访问它.<br>GDScript 很慢的原因是, 它执行的每个操作都要经过这个系统.<br>C#可以通过更优化的字节码, 以更快的速度处理一些内容. 但是, 如果C#脚本调用引擎类的内容, 或者脚本试图访问它的外部内容, 它会通过这个管道.<br>NativeScript C++甚至更进一步, 默认将所有内容都保持在内部. 对外部结构的调用将通过脚本API进行. 在NativeScript C++中, 注册方法以将其公开给脚本API是一项手动任务. 至此, 外部非C++类将使用API来查找它们.</p>
</blockquote>
<p>因此, 假设从引用扩展到创建数据结构, 比如一个 Array 或 Dictionary, 为什么选择一个 Object 而不是其他两个选项？<br>控件 : 对象能够创建更复杂的结构. 可以在数据上分层抽象, 以确保外部API不会响应内部数据结构的更改. 更重要的是, 对象可以有信号, 允许响应式行为. 对象带来了创建更复杂结构的能力.<br>清晰 : 当涉及到脚本和引擎类为对象定义的数据时, 对象是一个可靠的数据源. 属性可能不包含期望的值, 但是无需担心这个属性是否首先存在.<br>便利 : 如果已经有了类似的数据结构, 之后从现有类扩展, 可以使构建数据结构的任务变得容易得多. 相比之下, 数组和字典不能满足所有的用例.</p>
<p>对象还让用户有机会创建更专门化的数据结构。有了它，一个人可以设计自己的列表、二叉搜索树、堆、散列树、图、不相交集，以及其他选择。<br>“为什么不在树结构中使用节点？” 有人可能会问. 节点类包含与自定义数据结构无关的内容. 因此在构建树结构时, 构造自己的节点类型是很有帮助的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extends Object</span><br><span class="line">class_name TreeNode</span><br><span class="line"></span><br><span class="line">var _parent: TreeNode = null</span><br><span class="line">var _children := []</span><br><span class="line"></span><br><span class="line">func _notification(p_what):</span><br><span class="line">	match p_what:</span><br><span class="line">		NOTIFICATION_PREDELETE:</span><br><span class="line">			# Destructor.</span><br><span class="line">			for a_child in _children:</span><br><span class="line">				a_child.free()</span><br></pre></td></tr></table></figure>
<p>这里开始, 然后就可以创建具有特定功能的结构, 只会受到他们想象力的限制.</p>
<h4 id="枚举：整数-VS-字符串"><a href="#枚举：整数-VS-字符串" class="headerlink" title="枚举：整数 VS 字符串"></a>枚举：整数 VS 字符串</h4><p>大多数语言都提供了枚举类型，GDScript 也不例外。但与其他大多数语言不同的是，GDScript 的枚举允许开发者使用整数或字符串作为枚举值（后者只有在 GDScript 中使用 @export_enum 注解时才可以使用）。 那么问题来了：“该用哪一种枚举？”<br>简单回答一下就是：“你觉得哪个更舒服就选哪个。” 这是 GDScript 特有的特性，并非（C++、C#等）一般的 Godot 脚本所特有的特性；该语言将可用性置于性能之上。<br>在技术层面上，整数比较（常量时间）比字符串比较（线性时间）更快，若想保持其他语言中使用枚举的习惯，则应使用整数来表示枚举值。<br>当你想要 打印 枚举值时，使用整数的主要问题就出现了：尝试直接打印以 int 型保存的枚举 MY_ENUM 会打印 5 之类的东西，而不是像 MyEnum 这样的字符。若要打印以 int 型保存的枚举。必须编写一个字典来映射每个枚举所对应的字符串值。<br>如果开发者使用枚举的主要目的是打印值，并希望将它们作为相关概念组合在一起，那么将枚举作为字符串使用是有意义的。这样一来，也就不需要在打印上执行单独的数据结构了。</p>
<h4 id="AnimatedTexture-vs-AnimatedSprite2D-vs-AnimationPlayer-vs-AnimationTree"><a href="#AnimatedTexture-vs-AnimatedSprite2D-vs-AnimationPlayer-vs-AnimationTree" class="headerlink" title="AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree"></a>AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree</h4><p>在什么情况下应该使用Godot的各种动画类？对于Godot的新用户来说, 可能不是马上清楚答案.</p>
<p>AnimatedTexture 是引擎绘制一个动画循环, 而不是一个静态图像的纹理. 用户可以进行如下操作：</p>
<ol>
<li>它在纹理的每个部分移动的速率（FPS）。</li>
<li>纹理中包含的区域数(帧).</li>
</ol>
<p>Godot 的 RenderingServer 会按照规定的速度依次绘制区块。好处是不涉及引擎部分额外的逻辑。坏处是用户几乎没有控制权。</p>
<p>另外请注意，AnimatedTexture 是一种 Resource，与此处讨论的其他 Node 对象不同。可以创建 Sprite2D 节点，使用 AnimatedTexture 作为其纹理。或者（仅在其他方法无法满足要求时）可以将 AnimatedTexture 作为图块添加到 TileSet 中并将其与 TileMapLayer 集成到一起，从而获得自动动画化的背景。使用此方法时所有的渲染将在单个批处理内绘制调用。</p>
<p>AnimatedSprite2D 节点可以与 SpriteFrames 资源结合使用，使用户可以通过精灵表创建各种动画序列、在动画之间切换并控制它们的速度、区域偏移量和方向。这使得它们非常适合控制基于二维的帧动画。</p>
<p>若需要触发与动画更改相关的其他效果，例如创建粒子效果、调用函数或操作与帧动画无关的其他外围元素，则需要将一个 AnimationPlayer 节点与 AnimatedSprite2D 关联。</p>
<p>如果你想设计更复杂的二维动画系统，AnimationPlayer 也是你的必备工具，例如：</p>
<ol>
<li>剪纸动画：在运行时编辑精灵的变换。</li>
<li>二维网格动画：为精灵的纹理划分一个区域，并将骨架绑定在上面。然后动画化其中的骨骼，使骨骼按照彼此之间的关系，成比例地拉伸和弯曲纹理。</li>
</ol>
<p>虽然我们需要一个 AnimationPlayer, 来为游戏设计每个独立的动画序列, 它也可以用来混合复合动画, 也就是说, 在这些动画之间实现平滑的转换. 在为对象规划的动画之间, 也可能存在一个层次结构. 在这些情况下使用 AnimationTree 效果很出色. 可以在 这里 找到关于使用 AnimationTree 的深入指南.</p>
<h3 id="逻辑偏好"><a href="#逻辑偏好" class="headerlink" title="逻辑偏好"></a>逻辑偏好</h3><h4 id="先添加节点还是先修改属性？"><a href="#先添加节点还是先修改属性？" class="headerlink" title="先添加节点还是先修改属性？"></a>先添加节点还是先修改属性？</h4><p>运行时使用脚本初始化节点时，你可能需要对节点的名称、位置等属性进行修改。常见的纠结点在于，你应该什么时候去修改？</p>
<p>最佳实践是在节点加入场景树之前修改取值。部分属性的 setter 代码会更新其他对应的值，可能会比较慢！大多数情况下，这样的代码不会对游戏的性能产生影响，但对于程序式生成之类的重型使用场景，就可能让游戏卡成 PPT。</p>
<p>综上，最佳的做法就是先为节点设置初始值，然后再把它添加到场景树中。有值在被加入场景树之前不能被设置的例外情况，比如设置世界坐标的时候。</p>
<h4 id="加载-VS-预加载"><a href="#加载-VS-预加载" class="headerlink" title="加载 VS 预加载"></a>加载 VS 预加载</h4><p>在 GDScript 中，存在全局 preload 方法。它尽可能早地加载资源，以便提前进行“加载”操作，并避免在执行性能敏感的代码时加载资源。</p>
<p>其对应的 load 方法只有在执行 load 语句时才会加载资源。也就是说，它将立即加载资源。所以，在敏感进程中加载资源会造成速度减慢。load() 函数是可以被 所有 脚本语言访问的 ResourceLoader.load(path) 的别名。</p>
<p>那么, 预加载和加载到底在什么时候发生, 又应该什么时候使用这两种方法呢？我们来看一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># my_buildings.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line"># Note how constant scripts/scenes have a different naming scheme than</span><br><span class="line"># their property variants.</span><br><span class="line"></span><br><span class="line"># This value is a constant, so it spawns when the Script object loads.</span><br><span class="line"># The script is preloading the value. The advantage here is that the editor</span><br><span class="line"># can offer autocompletion since it must be a static path.</span><br><span class="line">const BuildingScn = preload(&quot;res://building.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># 1. The script preloads the value, so it will load as a dependency</span><br><span class="line">#    of the &#x27;my_buildings.gd&#x27; script file. But, because this is a</span><br><span class="line">#    property rather than a constant, the object won&#x27;t copy the preloaded</span><br><span class="line">#    PackedScene resource into the property until the script instantiates</span><br><span class="line">#    with .new().</span><br><span class="line">#</span><br><span class="line"># 2. The preloaded value is inaccessible from the Script object alone. As</span><br><span class="line">#    such, preloading the value here actually does not benefit anyone.</span><br><span class="line">#</span><br><span class="line"># 3. Because the user exports the value, if this script stored on</span><br><span class="line">#    a node in a scene file, the scene instantiation code will overwrite the</span><br><span class="line">#    preloaded initial value anyway (wasting it). It&#x27;s usually better to</span><br><span class="line">#    provide null, empty, or otherwise invalid default values for exports.</span><br><span class="line">#</span><br><span class="line"># 4. It is when one instantiates this script on its own with .new() that</span><br><span class="line">#    one will load &quot;office.tscn&quot; rather than the exported value.</span><br><span class="line">@export var a_building : PackedScene = preload(&quot;office.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># Uh oh! This results in an error!</span><br><span class="line"># One must assign constant values to constants. Because `load` performs a</span><br><span class="line"># runtime lookup by its very nature, one cannot use it to initialize a</span><br><span class="line"># constant.</span><br><span class="line">const OfficeScn = load(&quot;res://office.tscn&quot;)</span><br><span class="line"></span><br><span class="line"># Successfully loads and only when one instantiates the script! Yay!</span><br><span class="line">var office_scn = load(&quot;res://office.tscn&quot;)</span><br></pre></td></tr></table></figure>
<p>预加载允许脚本在加载脚本时处理所有加载. 预加载是有用的, 但也有一些时候, 人们并不希望这样. 为了区分这些情况, 我们可以考虑以下几点:</p>
<ol>
<li>如果无法确定何时可以加载脚本, 则预加载资源, 尤其是场景或脚本, 可能会导致进一步加载, 这是人们所不希望的. 这可能会导致无意中, 在原始脚本的加载操作之上的可变长度加载时间. 在原始脚本的加载操作之上, 这可能导致意外的, 可变长度的加载时间.</li>
<li>如果其他东西可以代替该值(例如场景导出的初始化), 则预加载该值没有任何意义. 如果打算总是自己创建脚本, 那么这一点并不是重要因素.</li>
<li>如果只希望“导入”另一个类资源（脚本或者场景），那么最好的解决方法就是使用预加载常量（Preloaded Constant）。不过也有例外的情况：<ol>
<li>如果“导入”的类有可能发生变化，那么就应该是属性，使用 @export 或 load() 初始化（或者甚至更晚一些才初始化）。</li>
<li>如果脚本需要大量依赖关系，又不想消耗太多内存，则可以在环境变化时动态地加载或卸载各种依赖关系。如果将资源预加载为常量，则卸载这些资源的唯一方法是卸载整个脚本。如果改为加载属性，则可以将它们设置为 null 并完全删除对资源的所有引用（扩展自 RefCounted 的类型会在指向其的所有引用均已消失时自动释放内存）。</li>
</ol>
</li>
</ol>
<h4 id="大型关卡：静态-VS-动态"><a href="#大型关卡：静态-VS-动态" class="headerlink" title="大型关卡：静态 VS 动态"></a>大型关卡：静态 VS 动态</h4><p>如果正在创建一个大型关卡, 哪种情况是最合适的？他们应该将关卡创建为一个静态空间吗？还是他们应该分阶段加载关卡, 并根据需要改变世界的内容？<br>答案很简单，“当性能需要的时候”。与这两种选择有关的困境是一种古老的编程选择：优化内存还是速度？<br>最简单的方法是使用静态关卡, 它可以一次加载所有内容. 但是, 这取决于项目, 这可能会消耗大量内存. 浪费用户的运行内存会导致程序运行缓慢, 或者计算机在同一时间尝试做的所有其他事情都会崩溃.<br>无论如何，应该将较大的场景分解为较小的场景（以利于资产重用）。然后，开发人员可以设计一个节点，该节点实时管理资源和节点的创建&#x2F;加载和删除&#x2F;卸载。具有大型多样环境或程序生成的元素的游戏，通常会实行这些策略，以避免浪费内存。<br>另一方面, 对动态系统进行编码更复杂, 即, 使用更多的编程逻辑, 这会导致出现错误和bug的机会. 如果不小心的话, 开发的系统, 会增加应用程序的技术成本.</p>
<p>因此, 最好的选择是…</p>
<ol>
<li>在小型游戏中使用静态关卡.</li>
<li>在开发中型&#x2F;大型游戏时, 如果有时间&#x2F;资源, 可以去创建一个可以对节点和资源的管理进行编码的库或插件. 如果随着时间的流逝而改进, 以提高可用性和稳定性, 那么它可能会演变成跨项目的可靠工具.</li>
<li>为一款中&#x2F;大型游戏编写动态逻辑代码, 因为你拥有编程技能, 但却没有时间或资源去完善代码(必须要完成游戏). 以后可能会进行重构, 将代码外包到插件中.</li>
</ol>
<p>有关在运行时中, 可以交换场景的各种方式的示例, 请参见文档 手动更改场景 .</p>
<h3 id="项目组织"><a href="#项目组织" class="headerlink" title="项目组织"></a>项目组织</h3><h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>Godot本质上是基于场景的, 并按原样使用文件系统, 而没有元数据或资产数据库.<br>与其他引擎不同, 场景本身包含许多资源, 因此文件系统中的文件数量要少得多.<br>考虑到这一点, 最常见的方法是将资产编组得尽可能接近场景；当项目变大时, 它使其更易于维护.<br>举例来说，人们通常可以将基本资产（例如精灵图像、3D 模型网格、材质和音乐等）放入一个文件夹中。然后，它们可以使用一个单独的文件夹来存储使用它们的构建关卡。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/project.godot</span><br><span class="line">/docs/.gdignore  # See &quot;Ignoring specific folders&quot; below</span><br><span class="line">/docs/learning.html</span><br><span class="line">/models/town/house/house.dae</span><br><span class="line">/models/town/house/window.png</span><br><span class="line">/models/town/house/door.png</span><br><span class="line">/characters/player/cubio.dae</span><br><span class="line">/characters/player/cubio.png</span><br><span class="line">/characters/enemies/goblin/goblin.dae</span><br><span class="line">/characters/enemies/goblin/goblin.png</span><br><span class="line">/characters/npcs/suzanne/suzanne.dae</span><br><span class="line">/characters/npcs/suzanne/suzanne.png</span><br><span class="line">/levels/riverdale/riverdale.scn</span><br></pre></td></tr></table></figure>

<h4 id="风格指南"><a href="#风格指南" class="headerlink" title="风格指南"></a>风格指南</h4><p>为了项目之间的一致性，我们建议遵循以下规范：</p>
<ol>
<li>使用 snake_case 风格为文件夹和文件命名(除了c#脚本). 这避免了在 Windows 上导出项目时可能出现的大小写敏感问题.C# 脚本是这个规则的一个例外, 因为按照惯例是用类名来对它们命名, 而类名应该是 PascalCase 风格.</li>
<li>使用 PascalCase 风格对节点进行命名, 这与内置的节点大小写风格一致.</li>
<li>通常, 将第三方资源放在顶级的 addons&#x2F; 文件夹中, 即使它们不是编辑器插件. 这样更加容易跟踪哪些文件是第三方文件. 当然这个规则也有一些例外: 如果你要使用第三方游戏资源创建角色, 将这些资源和角色场景及脚本放在同一文件夹下会更好.</li>
</ol>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>因此，现在可以从项目文件夹中透明地导入资产。</p>
<p>忽略具体文件夹<br>为防止 Godot 导入特定文件夹中的文件, 请在文件夹中创建一个名为 .gdignore 的空文件(以 . 号开头). 这对于加快初始项目导入非常有用.</p>
<blockquote>
<p>要在 Windows 上创建文件名以点开头的文件，请在文件名的前后都写一个点（“.gdignore.”）。确认之后 Windows 会自动移除末尾的点。<br>你也可以使用文本编辑器来创建它，例如记事本。或在命令提示符中输入以下命令：type nul &gt; .gdignore<br>一旦文件夹被忽略，其中资源就不能再使用 load() 和 preload() 方法加载。被忽略文件夹会从文件系统栏目中隐藏，从而减少混乱。<br>请注意 .gdignore 文件的内容会被忽略，因此该文件应当为空。它不像 .gitignore 文件一样支持模式匹配。</p>
</blockquote>
<h4 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h4><p>Windows 和最近版本的 macOS 默认使用不区分大小写的文件系统，而 Linux 发行版默认使用区分大小写的文件系统。由于 Godot 的 PCK 虚拟文件系统区分大小写，因此在导出项目后可能会导致问题。为了避免这种情况，建议对项目中的所有文件都使用 snake_case 蛇形命名法（一般使用小写）。</p>
<h3 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h3><p>版本控制插件<br>Godot 旨在对版本控制系统（Version Control System，VCS）友好，并尽量生成可读且可合并的文件。<br>Godot 支持通过插件在编辑器本身中使用 VCS。可以在编辑器中的项目&gt; 版本控制下设置或关闭 VCS。</p>
<p>截至 2023 年 7 月，尚且只有一个 Git 插件可用，但社区可能会创建其他的 VCS 插件。</p>
<p>官方 Git 插件<br>有一个官方插件可以让你在编辑器中使用 Git。你可以在GitHub找到最新的版本。</p>
<p>最新的更新、文档和源代码可以在Godot iOS插件库找到 Godot iOS plugins repository。<br>最新的更新、文档和源代码可以在 Godot iOS 插件库找到 Godot iOS plugins repository。</p>
<p>从 VCS 中排除的文件<br>当第一次在编辑器中打开项目时，Godot 会自动创建一些文件和文件夹。 为了避免生成的数据使版本控制仓库膨胀，你应该将它们添加到 VCS 忽略中：<br>.godot&#x2F;：此文件夹存储各种项目缓存数据。</p>
<p>*.translation：这些文件是从 CSV 文件生成的导入后的的二进制翻译文件。</p>
<p>你可以选择在 Godot 项目管理器创建项目时自动生成版本控制元数据。当选择 Git 选项时，将在项目根目录中创建 .gitignore 和 .gitattributes 文件：<br>在现有的项目中，选择编辑器顶部的 项目 菜单，然后选择 版本控制 &gt; 生成版本控制元数据。这将与在项目管理器中执行的操作一样创建相同的文件。</p>
<p>在 Windows 上使用 Git<br>大多数 Git for Windows 客户端都将 core.autocrlf 设置为 true。可能会导致部分文件错误地被 Git 标记为已修改，因为这些文件的行尾被自动从 LF 转换成了 CRLF。</p>
<p>最好将此选项设置为：</p>
<p>git config –global core.autocrlf input</p>
<p>使用项目管理器或编辑器创建版本控制元数据时，会使用 .gitattributes 文件自动强制使用 LF 行尾，因此无需更改 Git 配置。</p>
<p>Git LFS<br>Git LFS（大文件存储）是一个 Git 扩展，允许您管理存储库中的大文件。它用 Git 中的文本指针替换大文件，同时将文件内容存储在远程服务器上。这对于管理大型资产（例如纹理、音频文件和 3D 模型）非常有用，而不会使 Git 存储库膨胀。</p>
<blockquote>
<p>使用 Git LFS 时，您需要确保在将任何文件提交到存储库之前已设置它。如果您已经将文件提交到存储库，则需要将它们从存储库中删除，并在设置 Git LFS 后重新添加它们。<br>可以使用 git lfs migrate 来转换存储库中的现有文件，但这更深入，需要对 Git 有很好的了解。<br>一种常见的方法是使用 Git LFS（和适当的 .gitattributes）设置一个新存储库，然后将文件从旧存储库复制到新存储库。这样，您可以确保所有文件从一开始就被 LFS 跟踪。</p>
</blockquote>
<p>要将 Git LFS 与 Godot 一起使用，您需要安装 Git LFS 扩展并将其配置为跟踪要管理的文件类型。您可以通过在终端中运行以下命令来执行此作：<br>这将在您的存储库中创建一个 .gitattributes 文件，该文件告诉 Git 对指定的文件类型使用 LFS。您可以通过修改 .gitattributes 文件来添加更多文件类型。例如，要跟踪所有 GLB 文件，您可以通过在终端中运行以下命令来执行此作：<br>git lfs track “*.glb”</p>
<p>当您添加或修改 LFS 跟踪的文件时，Git 会自动将它们存储在 LFS 中，而不是常规的 Git 历史记录中。您可以像常规 Git 文件一样推送和拉取 LFS 文件，但请记住，LFS 文件与 Git 历史记录的其余部分分开存储。这意味着您可能需要在将存储库克隆到的任何计算机上安装 Git LFS 才能访问 LFS 文件。<br>下面是一个示例 .gitattributes 文件，您可以将其用作 Git LFS 的起点。之所以选择这些文件类型，是因为它们常用，但您可以修改列表以包含项目中可能拥有的任何二进制类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># Normalize EOL for all files that Git considers text files.</span><br><span class="line">* text=auto eol=lf</span><br><span class="line"></span><br><span class="line"># Git LFS Tracking (Assets)</span><br><span class="line"></span><br><span class="line"># 3D Models</span><br><span class="line">*.fbx filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.gltf filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.glb filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.blend filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.obj filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Images</span><br><span class="line">*.png filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.svg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.jpg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.jpeg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.gif filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.tga filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.webp filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.exr filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.hdr filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.dds filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Audio</span><br><span class="line">*.mp3 filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.wav filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.ogg filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Font &amp; Icon</span><br><span class="line">*.ttf filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.otf filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.ico filter=lfs diff=lfs merge=lfs -text</span><br><span class="line"></span><br><span class="line"># Godot LFS Specific</span><br><span class="line">*.scn filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.res filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.material filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.anim filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.mesh filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.lmbake filter=lfs diff=lfs merge=lfs -text</span><br></pre></td></tr></table></figure>
<p>有关 Git LFS 的更多信息，请查看官方文档： <a target="_blank" rel="noopener" href="https://git-lfs.github.com/">https://git-lfs.github.com/</a> 和 <a target="_blank" rel="noopener" href="https://docs.github.com/en/repositories/working-with-files/managing-large-files%E3%80%82">https://docs.github.com/en/repositories/working-with-files/managing-large-files。</a></p>
<h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><ol>
<li>编辑器运行缓慢，占用所有的 CPU 和 GPU 资源<br>尤其是在 macOS 上，因为大多数 Mac 都有 Retina 显示屏。<br>由于 Retina 显示器的像素密度更高，因此所有内容都必须以更高的分辨率渲染。会增加 GPU 上的负载并降低感知性能。</li>
</ol>
<p>有几种衡量性能和电池续航的方法：</p>
<ul>
<li>在 3D 模式下，单击左上角的透视按钮并启用半分辨率。现在 3D 视口就会以半分辨率渲染，速度最多可以提高到原来的 4 倍。</li>
<li>打开编辑器设置并将低处理器模式睡眠（微秒）的值增加到 33000（30 FPS）。该值决定了渲染每帧画面之间所间隔的时间（微秒单位）。 较高的值将会使编辑器操作起来没有那么跟手，但可显著降低 CPU 和 GPU 使用率。</li>
<li>如果有某个节点导致编辑器连续重新绘制（例如粒子），请将其隐藏并在脚本中使用 _ready() 方法显示它。这样，它将隐藏在编辑器中，但仍在正在运行的项目中可见。</li>
</ul>
<ol start="2">
<li>编辑器在我的可变刷新率显示器（G-Sync&#x2F;FreeSync）上出现卡顿和闪烁的情<br>可变刷新率显示器需要不断调整其伽玛曲线，以便随着时间的推移发出一致的光量。<br>当刷新率变化很大时，这可能会导致图像的黑暗区域出现闪烁，这是因为 Godot 编辑器仅在必要时重绘。</li>
</ol>
<p>这有几种解决办法：</p>
<ul>
<li>在编辑器设置中启用界面 &gt; 编辑器 &gt; 持续更新。即使画面没有变化，编辑器也将不断渲染。请注意，这会增加功耗、加大热量和噪音排放。<br>为了缓解这种情况，你可以在编辑器设置中将低处理器模式睡眠（微秒）增加到 33000（30 FPS）。<br>该值决定了渲染每帧画面之间所间隔的时间（微秒单位）。<br>较高的值将会使编辑器操作起来没有那么跟手，但可显著降低 CPU 和 GPU 使用率。</li>
<li>在显示器或图形驱动程序中禁用可变刷新率。</li>
<li>VRR 闪烁这个问题在某些显示器上，可以通过你的显示器的 OSD 中的 VRR 控制或微调暗区选项来减少。这些选项可能会增加输入延迟或导致黑色失真。</li>
<li>如果使用 OLED 显示器，可以在编辑器设置中使用 Black (OLED) 编辑器主题预设。因为 OLED 显示器的出色的黑阶表现，这可以隐藏 VRR 闪烁。</li>
</ul>
<ol start="3">
<li>编辑器或项目花了很长时间才启动<br>使用基于 Vulkan 的渲染器（Forward+ 或 Mobile）时，首次启动将会花费较长的时间。<br>这是因为着色器需要先编译才能进行缓存。更新 Godot、更新显卡驱动或切换显卡后，着色器也需要重新缓存。</li>
</ol>
<p>如果这个问题在首次启动后依然存在，那么这是 Windows 上的一个已知错误，当你连接了特定的 USB 外设时就会出现 。特别是，海盗船的 iCUE 软件似乎引起了该错误。尝试将 USB 外设的驱动程序更新为最新版本。如果错误仍然存在，则需要在打开编辑器之前断开故障外围设备的连接。然后，你可以再次连接外围设备。</p>
<p>Portmaster 等防火墙软件可能会屏蔽调试端口，导致项目启动时间变长，并且无法在编辑器中使用调试功能（例如查看 print() 的输出）。变通方法是在“编辑器设置”中修改项目所使用的调试端口（网络 &gt; 调试 &gt; 远程端口）。默认值是 6007；可以尝试设成大于 1024 的值，比如 7007。</p>
<p>在 Windows 上，当首次加载项目时，如果电脑刚开机，Windows Defender 会导致项目启动时文件系统缓存验证耗时显著增加。对于文件较多的项目尤为明显。考虑通过以下步骤将项目文件夹添加到排除列表中：病毒与威胁防护 &gt; 病毒与威胁防护设置 &gt; 添加或删除排除项。</p>
<ol start="4">
<li>点击系统控制台后 Godot 编辑器没有响应<br>在启用了系统控制台的 Windows 上运行 Godot 时，你可以通过在命令窗口中单击来意外启用选择模式。Windows 的这种特定行为会暂停应用程序，以便你在系统控制台内选择文本。Godot 无法覆盖此系统特定的行为。</li>
</ol>
<p>要解决此问题，请选择系统控制台窗口，然后按 Enter 退出选择模式。</p>
<ol start="5">
<li>手动移动 Godot 编辑器的 macOS Dock 图标之后出现多余的编辑器图标<br>如果你打开 Godot 编辑器并手动改变 dock 图标的位置，然后重启编辑器，你会在 dock 的最右边看到一个重复的 dock 图标。</li>
</ol>
<p>这是由于 macOS dock 的设计限制造成的。解决这个问题的唯一已知方法是将项目管理器和编辑器合并为一个进程，这意味着项目管理器在启动编辑器时不再产生一个单独的进程。虽然使用单一进程实例会带来一些好处，但由于任务的复杂性，完成这个功能没有列入我们近期的工作计划。</p>
<p>为了避免这个问题，保持 Godot 编辑器的 dock 图标在 macOS 创建的默认位置。</p>
<ol start="6">
<li>在项目管理器和编辑器窗口的左上角出现“NO DC”之类的文本<br>这是由于 NVIDIA 显卡驱动程序注入了覆盖显示信息造成的。</li>
</ol>
<p>要在 Windows 上禁用此覆盖，请在 NVIDIA 控制面板中将图形驱动程序设置恢复为默认值。</p>
<p>要在 Linux 上禁用此覆盖，请打开 nvidia-settings，转到 X Screen 0 &gt; OpenGL Settings，然后取消选中 Enable Graphics API Visual Indicator。</p>
<ol start="7">
<li>在项目管理器和编辑器窗口右下角出现一个麦克风或刷新的图标<br>这是由于 NVIDIA 图形驱动程序注入覆盖以显示 ShadowPlay 录制的即时重播信息造成的。此覆盖只能在 Windows 上看到，因为 Linux 不支持 ShadowPlay。</li>
</ol>
<p>要禁用此覆盖，请按 Alt + Z（NVIDIA 覆盖的默认快捷方式）并在 NVIDIA 覆盖中禁用设置 &gt; HUD 布局 &gt; 状态指示器。</p>
<p>你也可以选择安装取代 GeForce Experience 的新的 NVIDIA 程序 <a target="_blank" rel="noopener" href="https://www.nvidia.com/en-us/software/nvidia-app/">https://www.nvidia.com/en-us/software/nvidia-app/</a>，这样就不会遇到这个问题。与 GeForce Experience 不同的是，NVIDIA 程序会在屏幕的角落而不是每个窗口的角落绘制回放指示器。</p>
<ol start="8">
<li>编辑器或项目显示得过于锐利或模糊<br>可能是由于你的图形驱动程序强制对所有 Vulkan 或 OpenGL 应用程序进行图像锐化。</li>
</ol>
<p>你可以在图形驱动程序的控制面板中禁用此行为：<br>NVIDIA（Windows）：打开开始菜单，选择 NVIDIA 控制面板。打开左侧的管理 3D 设置选项卡。在中间的列表中，滚动到图像锐化，并将其设置为关闭锐化。<br>AMD（Windows）：打开开始菜单，选择 AMD 软件。点击右上角的设置 “齿轮 “图标。转到图形选项卡，然后禁用 Radeon 图像锐化。<br>如果编辑器或者项目看起来过于模糊，这可能是由于 FXAA 被你的显卡驱动强制应用到所有的 Vulkan 或者 OpenGL 应用程序上。<br>NVIDIA（Windows）：打开开始菜单并选择 NVIDIA 控制面板。打开左侧的管理 3D 设置选项卡。在中间的列表中， 滚动到平滑设置 - FXAA 并将其设置为应用程序控制的。<br>NVIDIA（Linux）：打开应用程序菜单，选择 NVIDIA X 服务器设置。在左侧选择 Antialiasing Settings，取消对 Enable FXAA 的勾选。<br>AMD（Windows）：打开开始菜单并选择 AMD Software。点击设置右上角的“齿轮”图标。转到图形选项卡， 滚动到底部并点击高级以展开其设置。禁用形态抗锯齿。</p>
<p>像是 vkBasalt 这种第三方开发的供应的工具可能会强迫所有的 Vulkan 应用程序开启锐化或者 FXAA。你可能也需要检查他们的设置。</p>
<p>当你变更过了显卡驱动和第三方工具中的设置后，重启 Godot 去应用这些设置。<br>如果你仍然希望在其他应用程序上强制锐化或 FXAA，建议你使用显卡驱动控制面板提供的应用程序配置系统，针对每个应用程序的进行设置。</p>
<ol start="9">
<li>此编辑器或项目看起来颜色很淡<br>在 Windows 上，这通常是由不正确的操作系统或显示器设置引起的，因为 Godot 目前不支持 HDR 输出（即使它可能在内部以 HDR 渲染）。</li>
</ol>
<p>由于<code>大多数显示器并非被设计为在 HDR 模式下显示 SDR 内容 &lt;https://tftcentral.co.uk/articles/heres-why-you-should-only-enable-hdr-mode-on-your-pc-when-you-are-viewing-hdr-content&gt;</code>__，建议在未运行使用 HDR 输出的应用程序时在 Windows 设置中禁用 HDR。在 Windows 11 上，可以通过按 Windows + Alt + B 来完成该操作（该快捷方式是 Xbox Game Bar 应用程序的一部分）。要根据当前正在运行的应用程序自动切换 HDR，你可以使用 AutoActions。</p>
<p>如果你坚持启用 HDR，可以通过确保显示器配置为使用 HGIG 色调映射（而不是 DTM），然后<code>使用 Windows HDR 校准应用程序 &lt;https://support.microsoft.com/en-us/windows/calibrate-your-hdr-display-using-the-windows-hdr-calibration-app-f30f4809-3369-43e4-9b02-9eabebd23f19&gt;</code>__ 来稍微改善结果。强烈建议在使用 HDR 时使用 Windows 11 而不是 Windows 10。不过，最终结果可能仍不如在显示器上禁用 HDR。</p>
<p>计划在未来版本中支持 HDR 导出。</p>
<ol start="10">
<li>从挂起状态恢复 PC 后，编辑器&#x2F;项目冻结或显示出现故障<br>当在 Linux 上使用 NVIDIA 的专用图形驱动程序时便会出现这个已知的问题。<br>目前还没有明确的解决方案，因为当涉及 OpenGL 或 Vulkan 时，Linux + NVIDIA 上的挂起通常会出现问题。<br>与 Forward+ 和 Mobile 渲染方法（使用 Vulkan ）相比，兼容性渲染方法（采用 OpenGL ）通常不太容易出现挂起相关问题。</li>
</ol>
<p>NVIDIA驱动程序提供了一个实验性选项可在挂起后保护视频内存用以解决这个问题。<br>据报道，该选项与较新的 NVIDIA 驱动程序版本配合使用效果更好。</p>
<p>为了避免丢失工作内容，请在使电脑进入睡眠状态之前将场景保存在编辑器中。</p>
<ol start="11">
<li>项目在编辑器中正常运行，但在导出后无法加载部分文件<br>这通常是由于忘记在导出对话框中指定非资源文件过滤器而导致的。<br>默认情况下，Godot 只会将实际的资源包含到 PCK 文件中。一些常用的文件，例如 JSON 文件，不会被视为资源。<br>例如，如果你在导出的项目中加载 test.json，则需要在非资源导出过滤器中指定 *.json。有关更多信息，请参阅 资源选项。</li>
</ol>
<p>另外，请注意，导出的项目永远不会包含名字以点开头的文件和文件夹。这是为了防止将 .git 等版本控制文件夹包含在导出的 PCK 文件中。</p>
<p>在 Windows 上，也可能是大小写敏感性的问题。如果你在脚本里引用资源时所使用的大小写与文件系统中的不符，在导出项目后就会载入失败。这是因为虚拟 PCK 文件系统是大小写敏感的，而 Windows 的文件系统是大小写不敏感的。</p>
<ol start="12">
<li>项目在从项目管理器打开后频繁崩溃或立即崩溃<br>这可能是由多个因素引起的，比如编辑器插件、GDExtension 插件或其他原因。<br>建议以恢复模式打开项目，并尝试找到并修复导致崩溃的原因。<br>有关更多信息，请参见 Project Manager page。</li>
</ol>
<h2 id="编辑器简介"><a href="#编辑器简介" class="headerlink" title="编辑器简介"></a>编辑器简介</h2><h3 id="编辑器的界面"><a href="#编辑器的界面" class="headerlink" title="编辑器的界面"></a>编辑器的界面</h3><h4 id="项目管理器"><a href="#项目管理器" class="headerlink" title="项目管理器"></a>项目管理器</h4><p>使用项目管理器不需要什么教程，自己实际体验就可以更好掌握</p>
<ul>
<li>项目的使用<ul>
<li>创建、删除、导入或运行游戏项目</li>
</ul>
</li>
<li>下载演示和模板<ul>
<li>从资产库下载开源项目模板和演示程序</li>
</ul>
</li>
<li>用标签管理项目<ul>
<li>创建、删除、编辑标签</li>
</ul>
</li>
<li>恢复模式<ul>
<li>从项目列表中选择项目，点击编辑按钮旁边的下拉箭头，然后选择“在恢复模式下编辑”。</li>
</ul>
</li>
</ul>
<h4 id="Inspector-Dock"><a href="#Inspector-Dock" class="headerlink" title="Inspector Dock"></a>Inspector Dock</h4><p>检查器扩展坞<br><img src="https://wzcwzc10.github.io/posts_img/godot/inspector_overview.webp"><br>如果不可见，可以通过导航到 编辑器 &gt; 编辑器设置 &gt; 编辑器停靠 &gt; 检查器</p>
<p>在内部，Godot 将项目的设置存储在一个 project.godot 文件中，这是一个 INI 格式的纯文本文件。<br>虽然这种格式易于阅读且对版本控制友好，但直接编辑并不太方便。<br>可以通过 项目设置 窗口来编辑这些设置。要打开项目设置，请从主菜单中选择 项目 &gt; 项目设置。</p>
<h3 id="XR-编辑器"><a href="#XR-编辑器" class="headerlink" title="XR 编辑器"></a>XR 编辑器</h3><h3 id="Android-编辑器"><a href="#Android-编辑器" class="headerlink" title="Android 编辑器"></a>Android 编辑器</h3><h3 id="Web-编辑器"><a href="#Web-编辑器" class="headerlink" title="Web 编辑器"></a>Web 编辑器</h3><h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><h3 id="管理编辑器功能"><a href="#管理编辑器功能" class="headerlink" title="管理编辑器功能"></a>管理编辑器功能</h3><h2 id="2D"><a href="#2D" class="headerlink" title="2D"></a>2D</h2><h2 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h2><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h2 id="资产管线"><a href="#资产管线" class="headerlink" title="资产管线"></a>资产管线</h2><h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><h3 id="音频总线"><a href="#音频总线" class="headerlink" title="音频总线"></a>音频总线</h3><p>Godot的音频引擎允许创建任意数量的音频总线, 并且可以向每个总线添加任意数量的效果处理器.<br>运行游戏的设备的硬件会限制总线的数量, 以及在性能开始下降之前可以使用的效果.</p>
<p>分贝标度<br>分贝(dB)标度是一个相对标度. 它等于声功率比的常用对数的20倍(20 × log10(P&#x2F;P&#x2F;0)).<br>每增&#x2F;减6分贝, 声幅就会加倍&#x2F;减半.12dB代表系数4,18dB代表系数8,20dB代表系数10,40dB代表系数100, 以此类推.<br>由于比例是对数的, 因此无法表示真零(无音频).<br>0 dB 是数字音频系统中可能的最大振幅. 这个限制不是人为的限制, 而是声音硬件的限制. 因振幅太高而无法完全反映在0dB以下的音频, 会产生一种被称为 削波 的失真.<br>为了避免削波，你应该调整混音，使master 总线（后面会有更多的介绍）永远不超过 0 dB。<br>低于0dB限制的每6dB, 声能就会 减半 . 这意味着-6dB的音量是0dB的一半. -12dB是-6dB的一半, 依此类推.<br>使用分贝时, -60dB和-80dB范围内的声音被认为是听不见的. 也就是说你的工作范围一般在-60dB和0dB之间.</p>
<p>音频总线(audio bus)音频通道 (audio channel)<br>音频总线可以在Godot 编辑器的底部面板中找到:<br>音频从扬声器播放出来之前通过的地方.<br>它可以 修改 和 重路由 音频数据.<br>音频总线有一个 VU表(播放声音时亮起的条形), 表示通过的信号的幅度.</p>
<p>最左边的总线是 主总线 .<br>此总线将混音输出到你的扬声器, 因此, 正如之前 分贝标度 部分所述, 请确保主总线中的混音水平永远低于 0 dB.<br>其余的音频总线可以灵活地进行路由.<br>在修改声音后, 它们会将其发送到左边的另一条总线上. 非主总线的目标总线可以被单独设置.<br>而右侧总线的音频会被路由至左侧总线, 这避免了无限循环.</p>
<h3 id="音频特效"><a href="#音频特效" class="headerlink" title="音频特效"></a>音频特效</h3><h3 id="音频流"><a href="#音频流" class="headerlink" title="音频流"></a>音频流</h3><h3 id="将游戏玩法与音频和音乐同步"><a href="#将游戏玩法与音频和音乐同步" class="headerlink" title="将游戏玩法与音频和音乐同步"></a>将游戏玩法与音频和音乐同步</h3><h3 id="使用麦克风录音"><a href="#使用麦克风录音" class="headerlink" title="使用麦克风录音"></a>使用麦克风录音</h3><h3 id="文本转语音"><a href="#文本转语音" class="headerlink" title="文本转语音"></a>文本转语音</h3><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><h2 id="文件与数据-I-O"><a href="#文件与数据-I-O" class="headerlink" title="文件与数据 I&#x2F;O"></a>文件与数据 I&#x2F;O</h2><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><h2 id="输入处理"><a href="#输入处理" class="headerlink" title="输入处理"></a>输入处理</h2><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="高级多人游戏"><a href="#高级多人游戏" class="headerlink" title="高级多人游戏"></a>高级多人游戏</h3><ol>
<li><p>高层API vs 底层 API<br>Godot 始终支持通过 UDP、 TCP 和一些更高级别的协议（如 SSL 和 HTTP ）进行标准的低级网络连接。<br>使用 Godot 的高级网络 API，牺牲了对低级网络的一些细度控制，有更强的易用性。</p>
</li>
<li><p>中层抽象<br>Godot 使用了一个中间层级的 MultiplayerPeer 对象。不应直接创建这种对象，它被设计为由多个 C++ 实现所提供。</p>
</li>
</ol>
<p>这个对象扩展自 PacketPeer 类，继承了所有用于序列化、发送和接收数据的方法。<br>此外，该对象还添加了设置对等体、传输模式等方法。它还包括让你知道对等体何时连接或断开的信号。</p>
<p>这个类接口可以抽象出大多数类型的网络层、拓扑结构和库。<br>默认情况下，Godot 会提供一个基于 ENet 的实现（ENetMultiplayerPeer）、一个基于 WebRTC 的实现（WebRTCMultiplayerPeer）以及一个基于WebSocket的实现（WebSocketPeer），而该类接口可以用来实现移动 API（用于特设的 WiFi、蓝牙等）或自定义设备&#x2F;控制台中特定的网络 API。</p>
<p>但大多数常见情况下，不鼓励直接使用这个对象，因为 Godot 提供了更高级别的网络使用方法。<br>只有当游戏对较低级别的API有特殊需求的情况下，才使用该对象。</p>
<ol start="3">
<li>服务器托管的注意事项<br>托管服务器时，LAN 上的客户端可以使用内网 IP 地址进行连接，该地址的格式通常是 192.168.<em>.</em>。 非 LAN&#x2F;Internet 客户端无法访问此内部 IP 地址。</li>
</ol>
<p>在 Windows 中， 你可以在命令提示符中输入 ipconfig 命令， 在 macOS 中，你可以在终端中输入 ifconfig 命令，在 Linux 中，你可以在终端中输入 ip addr 命令，来找到你的内网 IP 地址。</p>
<p>如果你在自己的机器上托管了服务器，并且想让非内网客户端连接，那么你可能需要将服务器端口 转发 到你的路由器，由于大多数家用网络都使用 NAT 技术，因此转发服务器端口是让你的服务器能通过互联网访问的必经步骤。Godot 的高级多人 API 只使用 UDP 协议，所以你的端口转发也必须是 UDP 协议的端口，不能只转发 TCP 协议的端口。</p>
<p>在转发了 UDP 端口之后，你需要确保你的服务器使用这个端口。可以前往这个网站 <a target="_blank" rel="noopener" href="https://icanhazip.com/">https://icanhazip.com/</a>去查询你的公网 IP 地址，然后把这个公网 IP 地址发送给想联机到你服务器的互联网客户端即可。</p>
<p>Godot 的高级多人联机 API 使用的是一个修改过的 ENet，包含全 IPv6 支持。</p>
<p>网络初始化</p>
<h3 id="进行-HTTP-请求"><a href="#进行-HTTP-请求" class="headerlink" title="进行 HTTP 请求"></a>进行 HTTP 请求</h3><h3 id="HTTP-客户端类"><a href="#HTTP-客户端类" class="headerlink" title="HTTP 客户端类"></a>HTTP 客户端类</h3><h3 id="TLS-SSL-证书"><a href="#TLS-SSL-证书" class="headerlink" title="TLS&#x2F;SSL 证书"></a>TLS&#x2F;SSL 证书</h3><h3 id="Using-WebSockets"><a href="#Using-WebSockets" class="headerlink" title="Using WebSockets"></a>Using WebSockets</h3><h3 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h2 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h2><h2 id="平台相关"><a href="#平台相关" class="headerlink" title="平台相关"></a>平台相关</h2><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><h2 id="用户界面（UI）"><a href="#用户界面（UI）" class="headerlink" title="用户界面（UI）"></a>用户界面（UI）</h2><h2 id="XR"><a href="#XR" class="headerlink" title="XR"></a>XR</h2><p>内置了一套模块化扩展现实（XR）系统，该系统通过抽象化不同 XR 平台的底层实现细节，以简化跨平台 XR 应用的开发流程。<br>该系统的核心是 XRServer 类，它作为整个 XR 架构的中枢接口，允许开发者通过该接口发现并连接各类 XR 运行时环境。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wzcwzc10.github.io">微光zc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/">https://wzcwzc10.github.io/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wzcwzc10.github.io" target="_blank">微光zc的网络小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Godot/">Godot</a><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/%E6%96%87%E6%A1%A3/">文档</a></div><div class="post-share"><div class="social-share" data-image="/./img/jufufu-ht.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>来一杯燃油饮</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/08/14/Godot4.4%20%E7%B1%BB%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/" title="Godot4.4 类参考总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Godot4.4 类参考总结</div></div><div class="info-2"><div class="info-item-1">全局@GDScript@GlobalScope 节点NodeAcceptDialogAnimatableBody2DAnimatableBody3DAnimatedSprite2DAnimatedSprite3DAnimationMixerAnimationPlayerAnimationTreeArea2DArea3DAspectRatioContainerAudioListener2DAudioListener3DAudioStreamPlayerAudioStreamPlayer2DAudioStreamPlayer3DBackBufferCopyBaseButtonBone2DBoneAttachment3DBoxContainerButtonCamera2DCamera3DCanvasGroupCanvasItemCanvasLayerCanvasModulateCenterContainerCharacterBody2DCharacterBody3DCheckBoxCheckButtonCodeEditCollisionObject2DCollisionObject3D...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/14/Godot4.4%20%E7%B1%BB%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/" title="Godot4.4 类参考总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-14</div><div class="info-item-2">Godot4.4 类参考总结</div></div><div class="info-2"><div class="info-item-1">全局@GDScript@GlobalScope 节点NodeAcceptDialogAnimatableBody2DAnimatableBody3DAnimatedSprite2DAnimatedSprite3DAnimationMixerAnimationPlayerAnimationTreeArea2DArea3DAspectRatioContainerAudioListener2DAudioListener3DAudioStreamPlayerAudioStreamPlayer2DAudioStreamPlayer3DBackBufferCopyBaseButtonBone2DBoneAttachment3DBoxContainerButtonCamera2DCamera3DCanvasGroupCanvasItemCanvasLayerCanvasModulateCenterContainerCharacterBody2DCharacterBody3DCheckBoxCheckButtonCodeEditCollisionObject2DCollisionObject3D...</div></div></div></a><a class="pagination-related" href="/2025/08/10/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%9C%89%E6%84%9F%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/" title="读Godot4.4文档有感（长期更新）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-10</div><div class="info-item-2">读Godot4.4文档有感（长期更新）</div></div><div class="info-2"><div class="info-item-1">本文参考Godot4.4中文文档中  关于 入门 手册的内容进行了总结改进，去除了个人感觉无用的部分  关于特性列表平台可运行编辑器以及导出项目的：Windows    macOS    Linux    Android（实验）    Web（实验） 可运行导出的项目：iOS    主机 编辑器特性：场景树编辑器脚本编辑器支持VS Code、VIM 等外部文本编辑器GDScript 调试器（支持多线程调试）可视化（性能）分析器性能监视工具（可自定义）脚本热重载场景热编辑远程检查器实时相机复制（移动编辑器中的相机，并在正在运行的项目中查看结果）内置离线类参考文档 插件：编辑器插件使用 GDScript 来创建插件资产库下载项目并直接导入 渲染 Forward+。最先进的渲染器，仅适用于桌面端。 Mobile。功能较少，但渲染简单场景的速度更快。适用于移动平台和桌面平台。(移动平台默认使用)以上渲染器使用 Vulkan、Direct3D 12 或 Metal 作为渲染驱动，使用 RenderingDevice 后端。 Compatibility，最低级的图形后端，在 OpenGL 3...</div></div></div></a><a class="pagination-related" href="/2025/07/28/Godot%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Godot基础学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-28</div><div class="info-item-2">Godot基础学习</div></div><div class="info-2"><div class="info-item-1">Godot介绍Godot 引擎是一款自由开源、由社区驱动的 2D 和 3D 游戏引擎！Godot官方中文文档  Godot 引擎是一款功能丰富的跨平台游戏引擎，可以通过统一的界面创建 2D 和 3D 游戏。它提供了一套全面的通用工具，因此用户可以专注于制作游戏，而无需重新发明轮子。游戏可以一键导出到多个平台，包括主流的桌面平台、移动平台、基于 Web 的平台以及主机平台。   Godot 在宽松的 MIT 许可证下完全自由且开源。用户的游戏乃至引擎的每一行代码，都归用户自己所有。Godot 的开发完全独立且由社区驱动，允许用户为满足期望而重塑引擎。它受到非盈利的 Godot 基金会的支持。   基本结构 Godot 开发核心——节点   游戏就是一棵由节点构成的树 大部分节点代表具体的功能 一个节点可有多个子节点   节点的集合——场景   游戏从主场景开始运行，主场景是游戏的根 其他场景就是枝叶，需要与主场景连接   场景间的通信兵——信号   信号机制是 Godot 内一种调用函数的机制 节点在发生某些事件时发出信号 无需在代码中硬连接节点就能相互通信  GDScript介绍...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/jufufu-ht.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">微光zc</div><div class="author-info-description">一个有想法的极客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/178083315"><i class="fab fa-bilibili"></i><span>关注我！</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">世界全剧终，欢迎来到my blog！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%8C"><span class="toc-number">1.</span> <span class="toc-text">手册</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.1.</span> <span class="toc-text">最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Godot-%E4%B8%AD%E5%BA%94%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.1.</span> <span class="toc-text">在 Godot 中应用面向对象原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">场景组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E5%9C%B0%E5%BB%BA%E7%AB%8B%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">如何有效地建立关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%8A%82%E7%82%B9%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">选择节点树结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E8%84%9A%E6%9C%AC"><span class="toc-number">1.1.3.</span> <span class="toc-text">何时使用场景与脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">匿名类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">命名的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Script-%E4%B8%8E-PackedScene-%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">Script 与 PackedScene 的性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%B8%B8%E8%A7%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">自动加载与常规节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E5%89%B2%E9%9F%B3%E9%A2%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">切割音频问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E6%88%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">管理共享功能或数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%BA%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">何时应使用自动加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BB%BB%E4%BD%95%E4%BA%8B%E6%83%85%E4%BD%BF%E7%94%A8%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.5.</span> <span class="toc-text">何时以及如何避免为任何事情使用节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.6.</span> <span class="toc-text">Godot 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">获取对象引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E6%88%96%E9%80%BB%E8%BE%91"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">从对象访问数据或逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Godot-%E9%80%9A%E7%9F%A5"><span class="toc-number">1.1.7.</span> <span class="toc-text">Godot 通知</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-process%E3%80%81-physics-process%E3%80%81-input"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">对比 _process、_physics_process、*_input</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-init%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E5%AF%BC%E5%87%BA"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">对比 _init、初始化、导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-ready%E3%80%81-enter-tree%E3%80%81NOTIFICATION-PARENTED"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">对比 _ready、_enter_tree、NOTIFICATION_PARENTED</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%81%8F%E5%A5%BD"><span class="toc-number">1.1.8.</span> <span class="toc-text">数据偏好</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E3%80%81%E5%AF%B9%E8%B1%A1%EF%83%81"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">数组、字典、对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%9A%E6%95%B4%E6%95%B0-VS-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">枚举：整数 VS 字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnimatedTexture-vs-AnimatedSprite2D-vs-AnimationPlayer-vs-AnimationTree"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%81%8F%E5%A5%BD"><span class="toc-number">1.1.9.</span> <span class="toc-text">逻辑偏好</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E8%BF%98%E6%98%AF%E5%85%88%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">先添加节点还是先修改属性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-VS-%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">加载 VS 预加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%9E%8B%E5%85%B3%E5%8D%A1%EF%BC%9A%E9%9D%99%E6%80%81-VS-%E5%8A%A8%E6%80%81"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">大型关卡：静态 VS 动态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.10.</span> <span class="toc-text">项目组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">风格指南</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5"><span class="toc-number">1.1.10.3.</span> <span class="toc-text">导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F"><span class="toc-number">1.1.10.4.</span> <span class="toc-text">大小写敏感</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.11.</span> <span class="toc-text">版本控制系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-number">1.2.</span> <span class="toc-text">故障排除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.</span> <span class="toc-text">编辑器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E7%95%8C%E9%9D%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">编辑器的界面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">项目管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inspector-Dock"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Inspector Dock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XR-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">XR 编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-%E7%BC%96%E8%BE%91%E5%99%A8%EF%83%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">Android 编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">Web 编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.5.</span> <span class="toc-text">高级功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%BC%96%E8%BE%91%E5%99%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.6.</span> <span class="toc-text">管理编辑器功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2D"><span class="toc-number">1.4.</span> <span class="toc-text">2D</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3D"><span class="toc-number">1.5.</span> <span class="toc-text">3D</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">1.6.</span> <span class="toc-text">动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%BA%BF"><span class="toc-number">1.7.</span> <span class="toc-text">资产管线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91"><span class="toc-number">1.8.</span> <span class="toc-text">音频</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E6%80%BB%E7%BA%BF"><span class="toc-number">1.8.1.</span> <span class="toc-text">音频总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E7%89%B9%E6%95%88"><span class="toc-number">1.8.2.</span> <span class="toc-text">音频特效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E6%B5%81"><span class="toc-number">1.8.3.</span> <span class="toc-text">音频流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E4%B8%8E%E9%9F%B3%E9%A2%91%E5%92%8C%E9%9F%B3%E4%B9%90%E5%90%8C%E6%AD%A5"><span class="toc-number">1.8.4.</span> <span class="toc-text">将游戏玩法与音频和音乐同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BA%A6%E5%85%8B%E9%A3%8E%E5%BD%95%E9%9F%B3"><span class="toc-number">1.8.5.</span> <span class="toc-text">使用麦克风录音</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E8%BD%AC%E8%AF%AD%E9%9F%B3"><span class="toc-number">1.8.6.</span> <span class="toc-text">文本转语音</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA"><span class="toc-number">1.9.</span> <span class="toc-text">导出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E6%95%B0%E6%8D%AE-I-O"><span class="toc-number">1.10.</span> <span class="toc-text">文件与数据 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">1.11.</span> <span class="toc-text">国际化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86"><span class="toc-number">1.12.</span> <span class="toc-text">输入处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-number">1.13.</span> <span class="toc-text">数学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA"><span class="toc-number">1.14.</span> <span class="toc-text">导航</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">1.15.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F"><span class="toc-number">1.15.1.</span> <span class="toc-text">高级多人游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C-HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-number">1.15.2.</span> <span class="toc-text">进行 HTTP 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%B1%BB"><span class="toc-number">1.15.3.</span> <span class="toc-text">HTTP 客户端类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-SSL-%E8%AF%81%E4%B9%A6"><span class="toc-number">1.15.4.</span> <span class="toc-text">TLS&#x2F;SSL 证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-WebSockets"><span class="toc-number">1.15.5.</span> <span class="toc-text">Using WebSockets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebRTC"><span class="toc-number">1.15.6.</span> <span class="toc-text">WebRTC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">1.16.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86"><span class="toc-number">1.17.</span> <span class="toc-text">物理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3"><span class="toc-number">1.18.</span> <span class="toc-text">平台相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6"><span class="toc-number">1.19.</span> <span class="toc-text">插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">1.20.</span> <span class="toc-text">渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC"><span class="toc-number">1.21.</span> <span class="toc-text">编写脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.22.</span> <span class="toc-text">着色器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%EF%BC%88UI%EF%BC%89"><span class="toc-number">1.23.</span> <span class="toc-text">用户界面（UI）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XR"><span class="toc-number">1.24.</span> <span class="toc-text">XR</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/19/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%89%8B%E5%86%8C/" title="读Godot4.4文档手册">读Godot4.4文档手册</a><time datetime="2025-08-19T11:00:00.000Z" title="发表于 2025-08-19 19:00:00">2025-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/14/Godot4.4%20%E7%B1%BB%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/" title="Godot4.4 类参考总结">Godot4.4 类参考总结</a><time datetime="2025-08-14T11:00:00.000Z" title="发表于 2025-08-14 19:00:00">2025-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/10/%E8%AF%BBGodot4.4%E6%96%87%E6%A1%A3%E6%9C%89%E6%84%9F%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/" title="读Godot4.4文档有感（长期更新）">读Godot4.4文档有感（长期更新）</a><time datetime="2025-08-10T11:00:00.000Z" title="发表于 2025-08-10 19:00:00">2025-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/02/Godot%20IP%E5%9C%B0%E5%9D%80P2P%E8%81%94%E6%9C%BA/" title="Godot IP地址P2P联机">Godot IP地址P2P联机</a><time datetime="2025-08-02T10:00:00.000Z" title="发表于 2025-08-02 18:00:00">2025-08-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/28/Godot%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/" title="Godot进阶学习">Godot进阶学习</a><time datetime="2025-07-28T10:00:00.000Z" title="发表于 2025-07-28 18:00:00">2025-07-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/./img/page-ym.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By 微光zc</span></div><div class="footer_custom_text">世界全剧终，欢迎来到my blog！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"data-lang":"zh-CN","data-reactions-enabled":"1","data-input-position":"top"}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'wzcwzc10/wzcwzc10.github.io',
      'data-repo-id': 'R_kgDOPIIccg',
      'data-category-id': 'DIC_kwDOPIIccs4CtHqc',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script src="https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js"></script><div class="aplayer no-destroy" data-id="13985424074" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script id="canvas_nest" defer="defer" color="255,255,0" opacity="0.6" zIndex="-1" count="120" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="微光zc,ヾ(≧▽≦*)o,ヾ(^▽^*),ヾ(≧∇≦*)ゝ,ヾ(^_^)o,ヾ(•ω•`)o,ヾ(￣3￣.￣3),ヾ(￣▽￣),ヾ(￣0￣)o" data-fontsize="30px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:description\"]","link[rel=\"canonical\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html><script type="text/javascript" src="/js/crash_cheat.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sakana-widget@2.7.1/lib/sakana.min.css"><div id="sakana-widget" style="position:fixed;bottom:5px;right:80px;"></div><script>function initSakanaWidget() {
  const jufufuht = SakanaWidget.getCharacter('chisato');
  jufufuht.image = `../img/jufufu-ht.gif`;
  jufufuht.initialState = {
    ...jufufuht.initialState,
    i: 0.001,
    d: 1,
  };
  SakanaWidget.registerCharacter('jufufuht', jufufuht);
  new SakanaWidget({ character: 'jufufuht' }).mount('#sakana-widget');

  const jufufu = SakanaWidget.getCharacter('takina');
  jufufu.image = `../img/jufufu.png`;
  SakanaWidget.registerCharacter('jufufu', jufufu);
  new SakanaWidget({ character: 'jufufu' }).mount('#sakana-widget');
}
nextCharacter(jufufuht);</script><script async onload="initSakanaWidget()" src="https://cdn.jsdelivr.net/npm/sakana-widget@2.7.1/lib/sakana.min.js"></script>